understanding cryptography

christof paar  jan pelzl

understanding
cryptography
a textbook for students and practitioners
foreword by bart preneel

123

prof. dr.-ing. christof paar
chair for embedded security
department of electrical engineering
and information sciences
ruhr-universitat bochum
44780 bochum
germany
cpaarcrypto.rub.de

dr.-ing. jan pelzl
escrypt gmbh  embedded security
zentrum fur it-sicherheit
lise-meitner-allee 4
44801 bochum
germany
jpelzlescrypt.com

isbn 978-3-642-04100-6
e-isbn 978-3-642-04101-3
doi 10.1007/978-3-642-04101-3
springer heidelberg dordrecht london new york
acm computing classification (1998) e.3, k.4.4, k.6.5.
library of congress control number 2009940447
c springer-verlag berlin heidelberg 2010

this work is subject to copyright. all rights are reserved, whether the whole or part of the material is
concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting,
reproduction on microfilm or in any other way, and storage in data banks. duplication of this publication
or parts thereof is permitted only under the provisions of the german copyright law of september 9,
1965, in its current version, and permission for use must always be obtained from springer. violations
are liable to prosecution under the german copyright law.
the use of general descriptive names, registered names, trademarks, etc. in this publication does not
imply, even in the absence of a specific statement, that such names are exempt from the relevant protective
laws and regulations and therefore free for general use.
cover design kuenkellopka gmbh
printed on acid-free paper
springer is part of springer science+business media (www.springer.com)

to
flora, maja, noah and sarah
as well as to
karl, greta and nele

while writing this book we noticed that for some reason the names of our spouses
and children are limited to five letters. as far as we know, this has no cryptographic
relevance.

foreword

academic research in cryptology started in the mid-1970s today it is a mature research discipline with an established professional organization (iacr, international
association for cryptologic research), thousands of researchers, and dozens of international conferences. every year more than a thousand scientific papers are published on cryptology and its applications.
until the 1970s, cryptography was almost exclusively found in diplomatic, military and government applications. during the 1980s, the financial and telecommunications industries deployed hardware cryptographic devices. the first mass-market
cryptographic application was the digital mobile phone system of the late 1980s.
today, everyone uses cryptography on a daily basis examples include unlocking
a car or garage door with a remote-control device, connecting to a wireless lan,
buying goods with a credit or debit card in a brick and mortar store or on the internet, installing a software update, making a phone call via voice-over-ip, or paying
for a ride on a public transport system. there is no doubt that emerging application
areas such as e-health, car telematics and smart buildings will make cryptography
even more ubiquitous.
cryptology is a fascinating discipline at the intersection of computer science,
mathematics and electrical engineering. as cryptology is moving fast, it is hard to
keep up with all the developments. during the last 25 years, the theoretical foundations of the area have been strengthened we now have a solid understanding of
security definitions and of ways to prove constructions secure. also in the area of
applied cryptography we witness very fast developments old algorithms are broken
and withdrawn and new algorithms and protocols emerge.
while several excellent textbooks on cryptology have been published in the last
decade, they tend to focus on readers with a strong mathematical background. moreover, the exciting new developments and advanced protocols form a temptation to
add ever more fancy material. it is the great merit of this textbook that it restricts
itself to those topics that are relevant to practitioners today. moreover, the mathematical background and formalism is limited to what is strictly necessary and it is
introduced exactly in the place where it is needed. this less is more approach is
very suitable to address the needs of newcomers in the field, as they get introduced

vii

viii

foreword

step by step to the basic concepts and judiciously chosen algorithms and protocols.
each chapter contains very helpful pointers to further reading, for those who want
to expand and deepen their knowledge.
overall, i am very pleased that the authors have succeeded in creating a highly
valuable introduction to the subject of applied cryptography. i hope that it can serve
as a guide for practitioners to build more secure systems based on cryptography, and
as a stepping stone for future researchers to explore the exciting world of cryptography and its applications.
leuven, august 2009

bart preneel

preface

cryptography has crept into everything, from web browsers and e-mail programs
to cell phones, bank cards, cars and even into medical implants. in the near future we will see many new exciting applications for cryptography such as radio
frequency identification (rfid) tags for anti-counterfeiting or car-to-car communications (weve worked on securing both of these applications). this is quite a
change from the past, where cryptography had been traditionally confined to very
specific applications, especially government communications and banking systems.
as a consequence of the pervasiveness of crypto algorithms, an increasing number
of people must understand how they work and how they can be applied in practice. this book addresses this issue by providing a comprehensive introduction to
modern applied cryptography that is equally suited for students and practitioners in
industry.
our book provides the reader with a deep understanding of how modern cryptographic schemes work. we introduce the necessary mathematical concepts in a
way that is accessible for every reader with a minimum background in college-level
calculus. it is thus equally well suited as a textbook for undergraduate or beginning graduate classes, or as a reference book for practicing engineers and computer
scientists who are interested in a solid understanding of modern cryptography.
the book has many features that make it a unique source for practitioners and students. we focused on practical relevance by introducing most crypto algorithms that
are used in modern real-world applications. for every crypto scheme, up-to-date security estimations and key length recommendations are given. we also discuss the
important issue of software and hardware implementation for every algorithm. in
addition to crypto algorithms, we introduce topics such as important cryptographic
protocols, modes of operation, security services and key establishment techniques.
many very timely topics, e.g., lightweight ciphers which are optimized for constrained applications (such as rfid tags or smart cards) or new modes of operations,
are also contained in the book.
a discussion section at the end of each chapter with annotated references provides plenty of material for further reading. for classroom use, these sections are

ix

x

preface

an excellent source for course projects. in particular, when used as a textbook, the
companion website for the book is highly recommended
www.crypto-textbook.com

readers will find many ideas for course projects, links to open-source software, test
vectors, and much more information on contemporary cryptography. in addition,
links to video lectures are provided.

how to use the book
the material in this book has evolved over many years and is classroom proven.
weve taught it both as a course for beginning graduate students and advanced undergraduate students and as a pure undergraduate course for students majoring in
our it security programs. we found that one can teach most of the book content
in a two-semester course, with 90 minutes of lecture time plus 45 minutes of help
session with exercises per week (total of 10 ects credits). in a typical us-style
three-credit course, or in a one-semester european course, some of the material
should be omitted. here are some reasonable choices for a one-semester course
curriculum 1 focus on the application of cryptography, e.g., in a computer science or electrical engineering program. this crypto course is a good addition
to courses in computer networks or more advanced security courses chap. 1
sects. 2.12.2 chap. 4 sect. 5.1 chap. 6 sects. 7.17.3 sects. 8.18.4 sects. 10.1
10.2 chap. 11 chap. 12 and chap. 13.
curriculum 2 focus on cryptographic algorithms and their mathematical background, e.g., as an applied cryptography course in computer science, electrical engineering or in an (undergraduate) math program. this crypto course works also nicely
as preparation for a more theoretical graduate courses in cryptography chap. 1
chap. 2 chap. 3 chap. 4 chap. 6 chap. 7 sects. 8.1  8.4 chap. 9 chap. 10
and sects. 11.1  11.2.

trained as engineers, we have worked in applied cryptography and security for
more than 15 years and hope that the readers will have as much fun with this fascinating field as weve had
bochum,
september 2009

christof paar
jan pelzl

acknowledgements

writing this book would have been impossible without the help of many people. we
hope we did not forget anyone in our list.
we are grateful for the excellent work of daehyun strobel and pascal wimann,
who provided most of the artwork in the book and never complained about our many
changes. axel poschmann provided the section about the present block cipher,
a very timely topic, and we are thankful for his excellent work. help with technical
questions was provided by frederick armknecht (stream ciphers), roberto avanzi
(finite fields and elliptic curves), alexander may (number theory), alfred menezes
and neal koblitz (history of elliptic curve cryptography), matt robshaw (aes), and
damian weber (discrete logarithms).
many thanks go the members of the embedded security group at the university of bochum  andrey bogdanov, benedikt driessen, thomas eisenbarth, tim
guneysu, stefan heyse, markus kasper, timo kasper, amir moradi and daehyun
strobel  who did much of the technical proofreading and provided numerous suggestions for improving the presentation of the material. special thanks to daehyun
for helping with examples and some advanced latex work, and to markus for his
help with problems. olga paustjans help with artwork and typesetting is also very
much appreciated.
an earlier generation of doctoral students from our group  sandeep kumar,
kerstin lemke-rust, andy rupp, kai schramm, and marko wolf  helped to create an online course that covered similar material. their work was very useful and
was a great inspiration when writing the book.
bart preneels willingness to provide the foreword is a great honor for us and
we would like to thank him at this point again. last but not least, we thank the
people from springer for their support and encouragement. in particular, thanks to
our editor ronan nugent and to alfred hofmann.

xi

table of contents

1

introduction to cryptography and data security . . . . . . . . . . . . . . . . . .
1.1 overview of cryptology (and this book) . . . . . . . . . . . . . . . . . . . . . .
1.2 symmetric cryptography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2.1 basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2.2 simple symmetric encryption the substitution cipher . . . .
1.3 cryptanalysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3.1 general thoughts on breaking cryptosystems . . . . . . . . . . . .
1.3.2 how many key bits are enough . . . . . . . . . . . . . . . . . . . . . .
1.4 modular arithmetic and more historical ciphers . . . . . . . . . . . . . . . .
1.4.1 modular arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4.2 integer rings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.4.3 shift cipher (or caesar cipher) . . . . . . . . . . . . . . . . . . . . . . . .
1.4.4 affine cipher . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.5 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.6 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1
2
4
4
6
9
9
11
13
13
16
18
19
20
22
24

2

stream ciphers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1 introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.1.1 stream ciphers vs. block ciphers . . . . . . . . . . . . . . . . . . . . . .
2.1.2 encryption and decryption with stream ciphers . . . . . . . . . .
2.2 random numbers and an unbreakable stream cipher . . . . . . . . . . . .
2.2.1 random number generators . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.2 the one-time pad . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2.3 towards practical stream ciphers . . . . . . . . . . . . . . . . . . . . . .
2.3 shift register-based stream ciphers . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3.1 linear feedback shift registers (lfsr) . . . . . . . . . . . . . . . . .
2.3.2 known-plaintext attack against single lfsrs . . . . . . . . . . .
2.3.3 trivium . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

29
30
30
31
34
34
36
38
41
41
45
46
49

xiii

xiv

table of contents

2.5 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
3

4

the data encryption standard (des) and alternatives . . . . . . . . . . . . .
3.1 introduction to des . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.1 confusion and diffusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 overview of the des algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 internal structure of des . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3.1 initial and final permutation . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3.2 the f -function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3.3 key schedule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 decryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5 security of des . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5.1 exhaustive key search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5.2 analytical attacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.6 implementation in software and hardware . . . . . . . . . . . . . . . . . . . . .
3.7 des alternatives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.7.1 the advanced encryption standard (aes) and the aes
finalist ciphers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.7.2 triple des (3des) and desx . . . . . . . . . . . . . . . . . . . . . . . . .
3.7.3 lightweight cipher present . . . . . . . . . . . . . . . . . . . . . . . . .
3.8 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.9 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

55
56
57
58
61
61
62
67
69
72
73
75
75
77
77
78
78
81
82
83

the advanced encryption standard (aes) . . . . . . . . . . . . . . . . . . . . . . . 87
4.1 introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
4.2 overview of the aes algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
4.3 some mathematics a brief introduction to galois fields . . . . . . . . . 90
4.3.1 existence of finite fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.3.2 prime fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
4.3.3 extension fields gf(2m ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
4.3.4 addition and subtraction in gf(2m ) . . . . . . . . . . . . . . . . . . . . 95
4.3.5 multiplication in gf(2m ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
4.3.6 inversion in gf(2m ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
4.4 internal structure of aes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4.4.1 byte substitution layer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.4.2 diffusion layer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.4.3 key addition layer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
4.4.4 key schedule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
4.5 decryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
4.6 implementation in software and hardware . . . . . . . . . . . . . . . . . . . . . 115
4.7 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
4.8 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118

table of contents

xv

5

more about block ciphers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
5.1 encryption with block ciphers modes of operation . . . . . . . . . . . . . 124
5.1.1 electronic codebook mode (ecb) . . . . . . . . . . . . . . . . . . . . . . 124
5.1.2 cipher block chaining mode (cbc) . . . . . . . . . . . . . . . . . . . . 128
5.1.3 output feedback mode (ofb) . . . . . . . . . . . . . . . . . . . . . . . . . 130
5.1.4 cipher feedback mode (cfb) . . . . . . . . . . . . . . . . . . . . . . . . . 131
5.1.5 counter mode (ctr) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
5.1.6 galois counter mode (gcm) . . . . . . . . . . . . . . . . . . . . . . . . . . 134
5.2 exhaustive key search revisited . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
5.3 increasing the security of block ciphers . . . . . . . . . . . . . . . . . . . . . . . 137
5.3.1 double encryption and meet-in-the-middle attack . . . . . . . . 138
5.3.2 triple encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
5.3.3 key whitening . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
5.4 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143
5.5 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145

6

introduction to public-key cryptography . . . . . . . . . . . . . . . . . . . . . . . . 149
6.1 symmetric vs. asymmetric cryptography . . . . . . . . . . . . . . . . . . . . . . 150
6.2 practical aspects of public-key cryptography . . . . . . . . . . . . . . . . . . 153
6.2.1 security mechanisms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
6.2.2 the remaining problem authenticity of public keys . . . . . 154
6.2.3 important public-key algorithms . . . . . . . . . . . . . . . . . . . . . . 155
6.2.4 key lengths and security levels . . . . . . . . . . . . . . . . . . . . . . . 156
6.3 essential number theory for public-key algorithms . . . . . . . . . . . . 157
6.3.1 euclidean algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
6.3.2 extended euclidean algorithm . . . . . . . . . . . . . . . . . . . . . . . . . 160
6.3.3 eulers phi function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164
6.3.4 fermats little theorem and eulers theorem . . . . . . . . . . . . 166
6.4 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
6.5 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170

7

the rsa cryptosystem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
7.1 introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
7.2 encryption and decryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 174
7.3 key generation and proof of correctness . . . . . . . . . . . . . . . . . . . . . . 175
7.4 encryption and decryption fast exponentiation . . . . . . . . . . . . . . . . 179
7.5 speed-up techniques for rsa . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
7.5.1 fast encryption with short public exponents . . . . . . . . . . . . . 183
7.5.2 fast decryption with the chinese remainder theorem . . . . . 184
7.6 finding large primes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
7.6.1 how common are primes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
7.6.2 primality tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
7.7 rsa in practice padding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192

xvi

table of contents

7.8 attacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
7.9 implementation in software and hardware . . . . . . . . . . . . . . . . . . . . . 197
7.10 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
7.11 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
8

public-key cryptosystems based on the discrete logarithm problem 205
8.1 diffiehellman key exchange . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
8.2 some algebra . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
8.2.1 groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
8.2.2 cyclic groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 210
8.2.3 subgroups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
8.3 the discrete logarithm problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
8.3.1 the discrete logarithm problem in prime fields . . . . . . . . . . 216
8.3.2 the generalized discrete logarithm problem . . . . . . . . . . . . 218
8.3.3 attacks against the discrete logarithm problem . . . . . . . . . . 219
8.4 security of the diffiehellman key exchange . . . . . . . . . . . . . . . . . . 225
8.5 the elgamal encryption scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226
8.5.1 from diffiehellman key exhange to elgamal encryption . 226
8.5.2 the elgamal protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
8.5.3 computational aspects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
8.5.4 security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
8.6 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
8.7 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234

9

elliptic curve cryptosystems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
9.1 how to compute with elliptic curves . . . . . . . . . . . . . . . . . . . . . . . . . 239
9.1.1 definition of elliptic curves . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
9.1.2 group operations on elliptic curves . . . . . . . . . . . . . . . . . . . . 242
9.2 building a discrete logarithm problem with elliptic curves . . . . . . 245
9.3 diffiehellman key exchange with elliptic curves . . . . . . . . . . . . . . 249
9.4 security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251
9.5 implementation in software and hardware . . . . . . . . . . . . . . . . . . . . . 252
9.6 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
9.7 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 256

10

digital signatures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259
10.1 introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
10.1.1 odd colors for cars, or why symmetric cryptography is
not sufficient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
10.1.2 principles of digital signatures . . . . . . . . . . . . . . . . . . . . . . . . 261
10.1.3 security services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263
10.2 the rsa signature scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264

table of contents

xvii

10.2.1 schoolbook rsa digital signature . . . . . . . . . . . . . . . . . . . . . 265
10.2.2 computational aspects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
10.2.3 security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
10.3 the elgamal digital signature scheme . . . . . . . . . . . . . . . . . . . . . . . . 270
10.3.1 schoolbook elgamal digital signature . . . . . . . . . . . . . . . . . . 270
10.3.2 computational aspects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
10.3.3 security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274
10.4 the digital signature algorithm (dsa) . . . . . . . . . . . . . . . . . . . . . . . . 277
10.4.1 the dsa algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
10.4.2 computational aspects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
10.4.3 security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
10.5 the elliptic curve digital signature algorithm (ecdsa) . . . . . . . . 282
10.5.1 the ecdsa algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
10.5.2 computational aspects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
10.5.3 security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286
10.6 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
10.7 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
11

hash functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
11.1 motivation signing long messages . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
11.2 security requirements of hash functions . . . . . . . . . . . . . . . . . . . . . . 296
11.2.1 preimage resistance or one-wayness . . . . . . . . . . . . . . . . . . . 297
11.2.2 second preimage resistance or weak collision resistance . 297
11.2.3 collision resistance and the birthday attack . . . . . . . . . . . . . 299
11.3 overview of hash algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
11.3.1 dedicated hash functions the md4 family . . . . . . . . . . . . . 304
11.3.2 hash functions from block ciphers . . . . . . . . . . . . . . . . . . . . 305
11.4 the secure hash algorithm sha-1 . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
11.4.1 preprocessing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
11.4.2 hash computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
11.4.3 implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
11.5 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
11.6 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315

12

message authentication codes (macs) . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
12.1 principles of message authentication codes . . . . . . . . . . . . . . . . . . . . 320
12.2 macs from hash functions hmac . . . . . . . . . . . . . . . . . . . . . . . . . . 321
12.3 macs from block ciphers cbc-mac . . . . . . . . . . . . . . . . . . . . . . . . 325
12.4 galois counter message authentication code (gmac) . . . . . . . . . . 327
12.5 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
12.6 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 328
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 329

xviii

13

table of contents

key establishment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
13.1 introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332
13.1.1 some terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332
13.1.2 key freshness and key derivation . . . . . . . . . . . . . . . . . . . . . . 332
13.1.3 the n2 key distribution problem . . . . . . . . . . . . . . . . . . . . . . . 334
13.2 key establishment using symmetric-key techniques . . . . . . . . . . . . 336
13.2.1 key establishment with a key distribution center . . . . . . . . 336
13.2.2 kerberos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
13.2.3 remaining problems with symmetric-key distribution . . . . 341
13.3 key establishment using asymmetric techniques . . . . . . . . . . . . . . . 342
13.3.1 man-in-the-middle attack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 342
13.3.2 certificates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344
13.3.3 public-key infrastructures (pki) and cas . . . . . . . . . . . . . . . 347
13.4 discussion and further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
13.5 lessons learned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352
problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353

references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367

chapter 1

introduction to cryptography and data security

this section will introduce the most important terms of modern cryptology and will
teach an important lesson about proprietary vs. openly known algorithms. we will
also introduce modular arithmetic which is also of major importance in public-key
cryptography.
in this chapter you will learn






the general rules of cryptography
key lengths for short-, medium- and long-term security
the difference between different types of attacks against ciphers
a few historical ciphers, and on the way we will learn about modular arithmetic,
which is of major importance for modern cryptography as well
why one should only use well-established encryption algorithms

c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 1, 

1

2

1 introduction to cryptography and data security

1.1 overview of cryptology (and this book)
if we hear the word cryptography our first associations might be e-mail encryption,
secure website access, smart cards for banking applications or code breaking during
world war ii, such as the famous attack against the german enigma encryption
machine (fig. 1.1).

fig. 1.1 the german enigma encryption machine (reproduced with permission from the
deutsches museum, munich)

cryptography seems closely linked to modern electronic communication. however, cryptography is a rather old business, with early examples dating back to about
2000 b.c., when non-standard secret hieroglyphics were used in ancient egypt.
since egyptian days cryptography has been used in one form or the other in many,
if not most, cultures that developed written language. for instance, there are documented cases of secret writing in ancient greece, namely the scytale of sparta
(fig. 1.2), or the famous caesar cipher in ancient rome, about which we will learn
later in this chapter. this book, however, strongly focuses on modern cryptographic

t h e
e i
s p
n c

s c y t a l
s a t r a n
o s i t i o
i p h e r

fig. 1.2 scytale of sparta

methods and also teaches many data security issues and their relationship with cryptography.
lets now have a look at the field of cryptography (fig. 1.3). the first thing

1.1 overview of cryptology (and this book)

3


  

 
  

  
  







fig. 1.3 overview of the field of cryptology

that we notice is that the most general term is cryptology and not cryptography.
cryptology splits into two main branches
cryptography is the science of secret writing with the goal of hiding the meaning of a message.
cryptanalysis is the science and sometimes art of breaking cryptosystems. you
might think that code breaking is for the intelligence community or perhaps organized crime, and should not be included in a serious classification of a scientific discipline. however, most cryptanalysis is done by respectable researchers
in academia nowadays. cryptanalysis is of central importance for modern cryptosystems without people who try to break our crypto methods, we will never
know whether they are really secure or not. see sect. 1.3 for more discussion
about this issue.
because cryptanalysis is the only way to assure that a cryptosystem is secure,
it is an integral part of cryptology. nevertheless, the focus of this book is on
cryptography we introduce most important practical crypto algorithms in detail.
these are all crypto algorithms that have withstood cryptanalysis for a long time, in
most cases for several decades. in the case of cryptanalysis we will mainly restrict
ourselves to providing state-of-the-art results with respect to breaking the crypto algorithms that are introduced, e.g., the factoring record for breaking the rsa scheme.
lets now go back to fig. 1.3. cryptography itself splits into three main branches
symmetric algorithms are what many people assume cryptography is about
two parties have an encryption and decryption method for which they share a
secret key. all cryptography from ancient times until 1976 was exclusively based
on symmetric methods. symmetric ciphers are still in widespread use, especially
for data encryption and integrity check of messages.
asymmetric (or public-key) algorithms in 1976 an entirely different type of
cipher was introduced by whitfield diffie, martin hellman and ralph merkle. in
public-key cryptography, a user possesses a secret key as in symmetric cryptography but also a public key. asymmetric algorithms can be used for applications
such as digital signatures and key establishment, and also for classical data encryption.
cryptographic protocols roughly speaking, crypto protocols deal with the application of cryptographic algorithms. symmetric and asymmetric algorithms

4

1 introduction to cryptography and data security

can be viewed as building blocks with which applications such as secure internet communication can be realized. the transport layer security (tls) scheme,
which is used in every web browser, is an example of a cryptographic protocol.
strictly speaking, hash functions, which will be introduced in chap. 11, form
a third class of algorithms but at the same time they share some properties with
symmetric ciphers.
in the majority of cryptographic applications in practical systems, symmetric and
asymmetric algorithms (and often also hash functions) are all used together. this is
sometimes referred to as hybrid schemes. the reason for using both families of
algorithms is that each has specific strengths and weaknesses.
the main focus of this book is on symmetric and asymmetric algorithms, as
well as hash functions. however, we will also introduce basic security protocols. in
particular, we will introduce several key establishment protocols and what can be
achieved with crypto protocols confidentiality of data, integrity of data, authentication of data, user identification, etc.

1.2 symmetric cryptography
this section deals with the concepts of symmetric ciphers and it introduces the
historic substitution cipher. using the substitution cipher as an example, we will
learn the difference between brute-force and analytical attacks.

1.2.1 basics
symmetric cryptographic schemes are also referred to as symmetric-key, secret-key,
and single-key schemes or algorithms. symmetric cryptography is best introduced
with an easy to understand problem there are two users, alice and bob, who want
to communicate over an insecure channel (fig. 1.4). the term channel might sound
a bit abstract but it is just a general term for the communication link this can be the
internet, a stretch of air in the case of mobile phones or wireless lan communication, or any other communication media you can think of. the actual problem starts
with the bad guy, oscar1 , who has access to the channel, for instance, by hacking
into an internet router or by listening to the radio signals of a wi-fi communication. this type of unauthorized listening is called eavesdropping. obviously, there
are many situations in which alice and bob would prefer to communicate without
oscar listening. for instance, if alice and bob represent two offices of a car manufacturer, and they are transmitting documents containing the business strategy for
the introduction of new car models in the next few years, these documents should

1

the name oscar was chosen to remind us of the word opponent.

1.2 symmetric cryptography

5

not get into the hands of their competitors, or of foreign intelligence agencies for
that matter.










  
   




fig. 1.4 communication over an insecure channel

in this situation, symmetric cryptography offers a powerful solution alice encrypts her message x using a symmetric algorithm, yielding the ciphertext y. bob
receives the ciphertext and decrypts the message. decryption is, thus, the inverse
process of encryption (fig. 1.5). what is the advantage if we have a strong encryption algorithm, the ciphertext will look like random bits to oscar and will contain
no information whatsoever that is useful to him.








 




  
   





  








  

fig. 1.5 symmetric-key cryptosystem

the variables x, y and k in fig. 1.5 are important in cryptography and have special
names





x is called plaintext or cleartext,
y is called ciphertext,
k is called the key,
the set of all possible keys is called the key space.

the system needs a secure channel for distribution of the key between alice
and bob. the secure channel shown in fig. 1.5 can, for instance, be a human who
is transporting the key in a wallet between alice and bob. this is, of course, a
somewhat cumbersome method. an example where this method works nicely is
the pre-shared keys used in wi-fi protected access (wpa) encryption in wireless

6

1 introduction to cryptography and data security

lans. later in this book we will learn methods for establishing keys over insecure
channels. in any case, the key has only to be transmitted once between alice and
bob and can then be used for securing many subsequent communications.
one important and also counterintuitive fact in this situation is that both the encryption and the decryption algorithms are publicly known. it seems that keeping
the encryption algorithm secret should make the whole system harder to break.
however, secret algorithms also mean untested algorithms the only way to find
out whether an encryption method is strong, i.e., cannot be broken by a determined
attacker, is to make it public and have it analyzed by other cryptographers. please
see sect. 1.3 for more discussion on this topic. the only thing that should be kept
secret in a sound cryptosystem is the key.
remarks
1. of course, if oscar gets hold of the key, he can easily decrypt the message since
the algorithm is publicly known. hence it is crucial to note that the problem of
transmitting a message securely is reduced to the problems of transmitting a key
secretly and of storing the key in a secure fashion.
2. in this scenario we only consider the problem of confidentiality, that is, of hiding
the contents of the message from an eavesdropper. we will see later in this book
that there are many other things we can do with cryptography, such as preventing
oscar from making unnoticed changes to the message (message integrity) or
assuring that a message really comes from alice (sender authentication).

1.2.2 simple symmetric encryption the substitution cipher
we will now learn one of the simplest methods for encrypting text, the substitution
( replacement) cipher. historically this type of cipher has been used many times,
and it is a good illustration of basic cryptography. we will use the substitution cipher
for learning some important facts about key lengths and about different ways of
attacking ciphers.
the goal of the substitution cipher is the encryption of text (as opposed to bits
in modern digital systems). the idea is very simple we substitute each letter of the
alphabet with another one.
example 1.1.
ak
bd
cw

for instance, the pop group abba would be encrypted as kddk.


1.2 symmetric cryptography

7

we assume that we choose the substitution table completely randomly, so that
an attacker is not able to guess it. note that the substitution table is the key of this
cryptosystem. as always in symmetric cryptography, the key has to be distributed
between alice and bob in a secure fashion.
example 1.2. lets look at another ciphertext
iq ifcc vqqr fb rdq vfllcq na rdq cfjwhwz hr bnnb
hcc hwwhbsqvqbre hwq vhlq

this does not seem to make too much sense and looks like decent cryptography.
however, the substitution cipher is not secure at all lets look at ways of breaking
the cipher.

first attack brute-force or exhaustive key search
brute-force attacks are based on a simple concept oscar, the attacker, has the ciphertext from eavesdropping on the channel and happens to have a short piece of
plaintext, e.g., the header of a file that was encrypted. oscar now simply decrypts
the first piece of ciphertext with all possible keys. again, the key for this cipher is
the substitution table. if the resulting plaintext matches the short piece of plaintext,
he knows that he has found the correct key.
definition 1.2.1 basic exhaustive key search or brute-force attack
let (x, y) denote the pair of plaintext and ciphertext, and let k 
{k1 , ..., k } be the key space of all possible keys ki . a brute-force
attack now checks for every ki  k if


dki (y)  x.
if the equality holds, a possible correct key is found if not, proceed
with the next key.

in practice, a brute-force attack can be more complicated because incorrect keys
can give false positive results. we will address this issue in sect. 5.2.
it is important to note that a brute-force attack against symmetric ciphers is always possible in principle. whether it is feasible in practice depends on the key
space, i.e., on the number of possible keys that exist for a given cipher. if testing all
the keys on many modern computers takes too much time, i.e., several decades, the
cipher is computationally secure against a brute-force attack.

8

1 introduction to cryptography and data security

lets determine the key space of the substitution cipher when choosing the replacement for the first letter a, we randomly choose one letter from the 26 letters of
the alphabet (in the example above we chose k). the replacement for the next alphabet letter b was randomly chosen from the remaining 25 letters, etc. thus there
exist the following number of different substitution tables
key space of the substitution cipher  26  25    3  2  1  26  288
even with hundreds of thousands of high-end pcs such a search would take
several decades thus, we are tempted to conclude that the substitution cipher is
secure. but this is incorrect because there is another, more powerful attack.

second attack letter frequency analysis
first we note that the brute-force attack from above treats the cipher as a black box,
i.e., we do not analyze the internal structure of the cipher. the substitution cipher
can easily be broken by such an analytical attack.
the major weakness of the cipher is that each plaintext symbol always maps to
the same ciphertext symbol. that means that the statistical properties of the plaintext
are preserved in the ciphertext. if we go back to the second example we observe that
the letter q occurs most frequently in the text. from this we know that q must be the
substitution for one of the frequent letters in the english language.
for practical attacks, the following properties of language can be exploited
1. determine the frequency of every ciphertext letter. the frequency distribution,
often even of relatively short pieces of encrypted text, will be close to that of
the given language in general. in particular, the most frequent letters can often
easily be spotted in ciphertexts. for instance, in english e is the most frequent
letter (about 13%), t is the second most frequent letter (about 9%), a is the third
most frequent letter (about 8%), and so on. table 1.1 lists the letter frequency
distribution of english.
2. the method above can be generalized by looking at pairs or triples, or quadruples, and so on of ciphertext symbols. for instance, in english (and some other
european languages), the letter q is almost always followed by a u. this behavior
can be exploited to detect the substitution of the letter q and the letter u.
3. if we assume that word separators (blanks) have been found (which is only sometimes the case), one can often detect frequent short words such as the, and, etc.
once we have identified one of these words, we immediately know three letters
(or whatever the length of the word is) for the entire text.
in practice, the three techniques listed above are often combined to break substitution ciphers.
example 1.3. if we analyze the encrypted text from example 1.2, we obtain
we will meet in the middle of the library at noon
all arrangements are made

1.3 cryptanalysis

9

table 1.1 relative letter frequencies of the english language
letter
a
b
c
d
e
f
g
h
i
j
k
l
m

frequency
0.0817
0.0150
0.0278
0.0425
0.1270
0.0223
0.0202
0.0609
0.0697
0.0015
0.0077
0.0403
0.0241

letter
n
o
p
q
r
s
t
u
v
w
x
y
z

frequency
0.0675
0.0751
0.0193
0.0010
0.0599
0.0633
0.0906
0.0276
0.0098
0.0236
0.0015
0.0197
0.0007


lesson learned good ciphers should hide the statistical properties of the encrypted
plaintext. the ciphertext symbols should appear to be random. also, a large key
space alone is not sufficient for a strong encryption function.

1.3 cryptanalysis
this section deals with recommended key lengths of symmetric ciphers and different ways of attacking crypto algorithms. it is stressed that a cipher should be secure
even if the attacker knows the details of the algorithm.

1.3.1 general thoughts on breaking cryptosystems
if we ask someone with some technical background what breaking ciphers is about,
he/she will most likely say that code breaking has to do with heavy mathematics,
smart people and large computers. we have images in mind of the british code
breakers during world war ii, attacking the german enigma cipher with extremely
smart mathematicians (the famous computer scientist alan turing headed the efforts) and room-sized electro-mechanical computers. however, in practice there are
also other methods of code breaking. lets look at different ways of breaking cryptosystems in the real world (fig. 1.6).

10

1 introduction to cryptography and data security


 


 


 
 


  

  
 

fig. 1.6 overview of cryptanalysis

classical cryptanalysis
classical cryptanalysis is understood as the science of recovering the plaintext x
from the ciphertext y, or, alternatively, recovering the key k from the ciphertext y.
we recall from the earlier discussion that cryptanalysis can be divided into analytical attacks, which exploit the internal structure of the encryption method, and
brute-force attacks, which treat the encryption algorithm as a black box and test all
possible keys.

implementation attacks
side-channel analysis can be used to obtain a secret key, for instance, by measuring
the electrical power consumption of a processor which operates on the secret key.
the power trace can then be used to recover the key by applying signal processing
techniques. in addition to power consumption, electromagnetic radiation or the runtime behavior of algorithms can give information about the secret key and are, thus,
useful side channels.2 note also that implementation attacks are mostly relevant
against cryptosystems to which an attacker has physical access, such as smart cards.
in most internet-based attacks against remote systems, implementation attacks are
usually not a concern.

social engineering attacks
bribing, blackmailing, tricking or classical espionage can be used to obtain a secret
key by involving humans. for instance, forcing someone to reveal his/her secret key,
e.g., by holding a gun to his/her head can be quite successful. another, less violent,
attack is to call people whom we want to attack on the phone, and say this is
2 before you switch on the digital oscilloscope in your lab in order to reload your geldkarte (the
geldkarte is the electronic wallet function integrated in most german bank cards) to the maximum
amount of e 200 modern smart cards have built-in countermeasures against side channel attacks
and are very hard to break.

1.3 cryptanalysis

11

the it department of your company. for important software updates we need your
password. it is always surprising how many people are nave enough to actually
give out their passwords in such situations.
this list of attacks against cryptographic system is certainly not exhaustive. for
instance, buffer overflow attacks or malware can also reveal secret keys in software
systems. you might think that many of these attacks, especially social engineering
and implementation attacks, are unfair, but there is little fairness in real-world
cryptography. if people want to break your it system, they are already breaking the
rules and are, thus, unfair. the major point to learn here is
an attacker always looks for the weakest link in your cryptosystem. that
means we have to choose strong algorithms and we have to make sure that
social engineering and implementation attacks are not practical.
even though both implementation attacks and social engineering attacks can be
quite powerful in practice, this book mainly assumes attacks based on mathematical
cryptanalysis.
solid cryptosystems should adhere to kerckhoffs principle, postulated by auguste kerckhoffs in 1883
definition 1.3.1 kerckhoffs principle
a cryptosystem should be secure even if the attacker (oscar) knows
all details about the system, with the exception of the secret key. in
particular, the system should be secure when the attacker knows the
encryption and decryption algorithms.
important remark kerckhoffs principle is counterintuitive it is extremely tempting to design a system which appears to be more secure because we keep the details
hidden. this is called security by obscurity. however, experience and military history has shown time and again that such systems are almost always weak, and they
are very often broken easily as soon as the secret design has been reverse-engineered
or leaked out through other means. an example is the content scrambling system
(css) for dvd content protection, which was broken easily once it was reverseengineered. this is why a cryptographic scheme must remain secure even if its description becomes available to an attacker.

1.3.2 how many key bits are enough
during the 1990s there was much public discussion about the key length of ciphers.
before we provide some guidelines, there are two crucial aspects to remember
1. the discussion of key lengths for symmetric crypto algorithms is only relevant
if a brute-force attack is the best known attack. as we saw in sect. 1.2.2 during
the security analysis of the substitution cipher, if there is an analytical attack that

12

1 introduction to cryptography and data security

works, a large key space does not help at all. of course, if there is the possibility
of social engineering or implementation attacks, a long key also does not help.
2. the key lengths for symmetric and asymmetric algorithms are dramatically different. for instance, an 80-bit symmetric key provides roughly the same security
as a 1024-bit rsa (rsa is a popular asymmetric algorithm) key.
both facts are often misunderstood, especially in the semitechnical literature.
table 1.2 gives a rough indication of the security of symmetric ciphers with respect to brute-force attacks. as described in sect. 1.2.2, a large key space is a necessary but not sufficient condition for a secure symmetric cipher. the cipher must
also be strong against analytical attacks.
table 1.2 estimated time for successful brute-force attacks on symmetric algorithms with different
key lengths
key length
5664 bits
112128 bits
256 bits

security estimation
short term a few hours or days
long term several decades in the absence of quantum computers
long term several decades, even with quantum computers
that run the currently known quantum computing algorithms

foretelling the future of course, predicting the future tends to be tricky we cant
really foresee new technical or theoretical developments with certainty. as you can
imagine, it is very hard to know what kinds of computers will be available in the
year 2030. for medium-term predictions, moores law is often assumed. roughly
speaking, moores law states that computing power doubles every 18 months while
the costs stay constant. this has the following implications in cryptography if today
we need one month and computers worth 1,000,000 to break a cipher x, then




the cost for breaking the cipher will be 500,000 in 18 months (since we only
have to buy half as many computers),
250,000 in 3 years,
125,000 in 4.5 years, and so on.

it is important to stress that moores law is an exponential function. in 15 years,
i.e., after 10 iterations of computer power doubling, we can do 210  1024 as many
computations for the same money we would need to spend today. stated differently,
we only need to spend about 1/1000th of todays money to do the same computation.
in the example above that means that we can break cipher x in 15 years within one
month at a cost of about 1, 000, 000/1024  1000. alternatively, with 1,000,000,
an attack can be accomplished within 45 minutes in 15 years from now. moores
law behaves similarly to a bank account with a 50% interest rate the compound
interest grows very, very quickly. unfortunately, there are few trustworthy banks
which offer such an interest rate.

1.4 modular arithmetic and more historical ciphers

13

1.4 modular arithmetic and more historical ciphers
in this section we use two historical ciphers to introduce modular arithmetic with
integers. even though the historical ciphers are no longer relevant, modular arithmetic is extremely important in modern cryptography, especially for asymmetric
algorithms. ancient ciphers date back to egypt, where substitution ciphers were
used. a very popular special case of the substitution cipher is the caesar cipher,
which is said to have been used by julius caesar to communicate with his army.
the caesar cipher simply shifts the letters in the alphabet by a constant number of
steps. when the end of the alphabet is reached, the letters repeat in a cyclic way,
similar to numbers in modular arithmetic.
to make computations with letters more practicable, we can assign each letter of
the alphabet a number. by doing so, an encryption with the caesar cipher simply
becomes a (modular) addition with a fixed value. instead of just adding constants,
a multiplication with a constant can be applied as well. this leads us to the affine
cipher.
both the caesar cipher and the affine cipher will now be discussed in more detail.

1.4.1 modular arithmetic
almost all crypto algorithms, both symmetric ciphers and asymmetric ciphers, are
based on arithmetic within a finite number of elements. most number sets we are
used to, such as the set of natural numbers or the set of real numbers, are infinite. in
the following we introduce modular arithmetic, which is a simple way of performing
arithmetic in a finite set of integers.
lets look at an example of a finite set of integers from everyday life
example 1.4. consider the hours on a clock. if you keep adding one hour, you obtain
1h, 2h, 3h, . . . , 11h, 12h, 1h, 2h, 3h, . . . , 11h, 12h, 1h, 2h, 3h, . . .
even though we keep adding one hour, we never leave the set.

lets look at a general way of dealing with arithmetic in such finite sets.
example 1.5. we consider the set of the nine numbers
{0, 1, 2, 3, 4, 5, 6, 7, 8}
we can do regular arithmetic as long as the results are smaller than 9. for instance
23  6
4+4  8

14

1 introduction to cryptography and data security

but what about 8 + 4 now we try the following rule perform regular integer arithmetic and divide the result by 9. we then consider only the remainder rather than
the original result. since 8 + 4  12, and 12/9 has a remainder of 3, we write
8 + 4  3 mod 9

we now introduce an exact definition of the modulo operation
definition 1.4.1 modulo operation
let a, r, m  z (where z is a set of all integers) and m  0. we write
a  r mod m
if m divides a  r.
m is called the modulus and r is called the remainder.
there are a few implications from this definition which go beyond the casual rule
divide by the modulus and consider the remainder. we discuss these implications
below.

computation of the remainder
it is always possible to write a  z, such that
a  qm+r

for

0rm

(1.1)

since a  r  q  m (m divides a  r) we can now write a  r mod m. note that
r  {0, 1, 2, . . . , m  1}.
example 1.6. let a  42 and m  9. then
42  4  9 + 6
and therefore 42  6 mod 9.


the remainder is not unique
it is somewhat surprising that for every given modulus m and number a, there are
(infinitely) many valid remainders. lets look at another example
example 1.7. we want to reduce 12 modulo 9. here are several results which are
correct according to the definition

1.4 modular arithmetic and more historical ciphers




15

12  3 mod 9, 3 is a valid remainder since 9(12  3)
12  21 mod 9, 21 is a valid remainder since 9(21  3)
12  6 mod 9, 6 is a valid remainder since 9(6  3)

where the xy means x divides y. there is a system behind this behavior. the set
of numbers
{. . . , 24, 15, 6, 3, 12, 15, 24, . . .}
form what is called an equivalence class. there are eight other equivalence classes
for the modulus 9
{. . . , 27, 18, 9, 0, 9, 18, 27, . . .}
{. . . , 26, 17, 8, 1, 10, 19, 28, . . .}
..
.
{. . . , 19, 10, 1, 8, 17, 26, 35, . . .}


all members of a given equivalence class behave equivalently
for a given modulus m, it does not matter which element from a class we choose
for a given computation. this property of equivalent classes has major practical
implications. if we have involved computations with a fixed modulus  which is
usually the case in cryptography  we are free to choose the class element that
results in the easiest computation. lets look first at an example
example 1.8. the core operation in many practical public-key schemes is an exponentiation of the form xe mod m, where x, e, m are very large integers, say, 2048 bits
each. using a toy-size example, we can demonstrate two ways of doing modular exponentiation. we want to compute 38 mod 7. the first method is the straightforward
approach, and for the second one we switch between equivalent classes.




38  6561  2 mod 7, since 6561  937  7 + 2
note that we obtain the fairly large intermediate result 6561 even though we
know that our final result cannot be larger than 6.
here is a much smarter method first we perform two partial exponentiations
38  34  34  81  81
we can now replace the intermediate results 81 by another member of the same
equivalence class. the smallest positive member modulo 7 in the class is 4 (since
81  11  7 + 4). hence
38  81  81  4  4  16 mod 7

16

1 introduction to cryptography and data security

from here we obtain the final result easily as 16  2 mod 7.
note that we could perform the second method without a pocket calculator since
the numbers never become larger than 81. for the first method, on the other hand,
dividing 6561 by 7 is mentally already a bit challenging. as a general rule we should
remember that it is almost always of computational advantage to apply the modulo
reduction as soon as we can in order to keep the numbers small.

of course, the final result of any modulo computation is always the same, no
matter how often we switch back and forth between equivalent classes.

which remainder do we choose
by agreement, we usually choose r in eq. (1.1) such that
0  r  m  1.
however, mathematically it does not matter which member of an equivalent class
we use.

1.4.2 integer rings
after studying the properties of modulo reduction we are now ready to define in
more general terms a structure that is based on modulo arithmetic. lets look at the
mathematical construction that we obtain if we consider the set of integers from
zero to m  1 together with the operations addition and multiplication
definition 1.4.2 ring
the integer ring zm consists of
1. the set zm  {0, 1, 2, . . . , m  1}
2. two operations + and  for all a, b  zm such that
1. a + b  c mod m , (c  zm )
2. a  b  d mod m , (d  zm )
lets first look at an example for a small integer ring.
example 1.9. let m  9, i.e., we are dealing with the ring z9  {0, 1, 2, 3, 4, 5, 6, 7, 8}.
lets look at a few simple arithmetic operations
6 + 8  14  5 mod 9
6  8  48  3 mod 9

1.4 modular arithmetic and more historical ciphers

17


more about rings and finite fields which are related to rings is discussed in
sect. 4.2. at this point, the following properties of rings are important







we can add and multiply any two numbers and the result is always in the ring. a
ring is said to be closed.
addition and multiplication are associative, e.g., a + (b + c)  (a + b) + c, and
a  (b  c)  (a  b)  c for all a, b, c  zm .
there is the neutral element 0 with respect to addition, i.e., for every element
a  zm it holds that a + 0  a mod m.
for any element a in the ring, there is always the negative element a such that
a + (a)  0 mod m, i.e., the additive inverse always exists.
there is the neutral element 1 with respect to multiplication, i.e., for every element a  zm it holds that a  1  a mod m.
the multiplicative inverse exists only for some, but not for all, elements. let
a  z, the inverse a1 is defined such that
a  a1  1 mod m



if an inverse exists for a, we can divide by this element since b/a  b  a1 mod
m.
it takes some effort to find the inverse (usually employing the euclidean algorithm, which is taught in sect. 6.3). however, there is an easy way of telling
whether an inverse for a given element a exists or not
an element a  z has a multiplicative inverse a1 if and only if gcd(a, m)  1,
where gcd is the greatest common divisor , i.e., the largest integer that divides
both numbers a and m. the fact that two numbers have a gcd of 1 is of great
importance in number theory, and there is a special name for it if gcd(a, m)  1,
then a and m are said to be relatively prime or coprime.
example 1.10. lets see whether the multiplicative inverse of 15 exists in z26 .
because
gcd(15, 26)  1
the inverse must exist. on the other hand, since
gcd(14, 26)  2  1
the multiplicative inverse of 14 does not exist in z26 .


another ring property is that a  (b + c)  (a  b) + (a  c) for all a, b, c  zm ,
i.e., the distributive law holds. in summary, roughly speaking, we can say that the
ring zm is the set of integers {0, 1, 2, . . . , m  1} in which we can add, subtract,
multiply, and sometimes divide.
as mentioned earlier, the ring zm , and thus integer arithmetic with the modulo
operation, is of central importance to modern public-key cryptography. in practice,

18

1 introduction to cryptography and data security

the integers involved have a length of 1504096 bits so that efficient modular computations are a crucial aspect.

1.4.3 shift cipher (or caesar cipher)
we now introduce another historical cipher, the shift cipher. it is actually a special
case of the substitution cipher and has a very elegant mathematical description.
the shift cipher itself is extremely simple we simply shift every plaintext letter
by a fixed number of positions in the alphabet. for instance, if we shift by 3 positions, a would be substituted by d, b by e, etc. the only problem arises towards
the end of the alphabet what should we do with x, y, z as you might have
guessed, they should wrap around. that means x should become a, y should become b, and z is replaced by c. allegedly, julius caesar used this cipher with a
three-position shift.
the shift cipher also has an elegant description using modular arithmetic. for
the mathematical statement of the cipher, the letters of the alphabet are encoded as
numbers, as depicted in table 1.3.
table 1.3 encoding of letters for the shift cipher
a
0
n
13

b
1
o
14

c
2
p
15

d
3
q
16

e
4
r
17

f
5
s
18

g
6
t
19

h
7
u
20

i
8
v
21

j
9
w
22

k
10
x
23

l
11
y
24

m
12
z
25

both the plaintext letters and the ciphertext letters are now elements of the ring
z26 . also, the key, i.e., the number of shift positions, is also in z26 since more than
26 shifts would not make sense (27 shifts would be the same as 1 shift, etc.). the
encryption and decryption of the shift cipher follows now as
definition 1.4.3 shift cipher
let x, y, k  z26 .
encryption ek (x)  x + k mod 26.
decryption dk (y)  y  k mod 26.
example 1.11. let the key be k  17, and the plaintext is
attack  x1 , x2 , . . . , x6  0, 19, 19, 0, 2, 10.
the ciphertext is then computed as
y1 , y2 , . . . , y6  17, 10, 10, 17, 19, 1  rkkrtb

1.4 modular arithmetic and more historical ciphers

19


as you can guess from the discussion of the substitution cipher earlier in this
book, the shift cipher is not secure at all. there are two ways of attacking it
1. since there are only 26 different keys (shift positions), one can easily launch a
brute-force attack by trying to decrypt a given ciphertext with all possible 26
keys. if the resulting plaintext is readable text, you have found the key.
2. as for the substitution cipher, one can also use letter frequency analysis.

1.4.4 affine cipher
now, we try to improve the shift cipher by generalizing the encryption function.
recall that the actual encryption of the shift cipher was the addition of the key
yi  xi + k mod 26. the affine cipher encrypts by multiplying the plaintext by one
part of the key followed by addition of another part of the key.
definition 1.4.4 affine cipher
let x, y, a, b  z26
encryption ek (x)  y  a  x + b mod 26.
decryption dk (y)  x  a1  (y  b) mod 26.
with the key k  (a, b), which has the restriction gcd(a, 26)  1.
the decryption is easily derived from the encryption function
a  x + b  y mod 26
a  x  (y  b) mod 26
x  a1  (y  b) mod 26
the restriction gcd(a, 26)  1 stems from the fact that the key parameter a needs
to be inverted for decryption. we recall from sect. 1.4.2 that an element a and the
modulus must be relatively prime for the inverse of a to exist. thus, a must be in
the set
a  {1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25}
(1.2)
but how do we find a1  for now, we can simply compute it by trial and error
for a given a we simply try all possible values a1 until we obtain
a  a1  1 mod 26
for instance, if a  3, then a1  9 since 3  9  27  1 mod 26. note that a1 also
always fulfills the condition gcd(a1 , 26)  1 since the inverse of a1 always exists.
in fact, the inverse of a1 is a itself. hence, for the trial-and-error determination of
a1 one only has to check the values given in eq. (1.2).

20

1 introduction to cryptography and data security

example 1.12. let the key be k  (a, b)  (9, 13), and the plaintext be
attack  x1 , x2 , . . . , x6  0, 19, 19, 0, 2, 10.
the inverse a1 of a exists and is given by a1  3. the ciphertext is computed as
y1 , y2 , . . . , y6  13, 2, 2, 13, 5, 25  nccnfz

is the affine cipher secure no the key space is only a bit larger than in the case
of the shift cipher
key space  (values for a)  (values for b)
 12  26  312
a key space with 312 elements can, of course, still be searched exhaustively, i.e.,
brute-force attacked, in a fraction of a second with current desktop pcs. in addition,
the affine cipher has the same weakness as the shift and substitution cipher the
mapping between plaintext letters and ciphertext letters is fixed. hence, it can easily
be broken with letter frequency analysis.
the remainder of this book deals with strong cryptographic algorithms which are
of practical relevance.

1.5 discussion and further reading
this book addresses practical aspects of cryptography and data security and is intended to be used as an introduction it is suited for classroom use, distance learning
and self-study. at the end of each chapter, we provide a discussion section in which
we briefly describe topics for readers interested in further study of the material.
about this chapter historical ciphers and modular arithmetic this chapter
introduced a few historical ciphers. however, there are many, many more, ranging
from ciphers in ancient times to ww ii encryption methods. to readers who wish to
learn more about historical ciphers and the role they played over the centuries, the
books by bauer [13], kahn [97] and singh [157] are highly recommended. besides
making fascinating bedtime reading, these books help one to understand the role
that military and diplomatic intelligence played in shaping world history. they also
help to show modern cryptography in a larger context.
the mathematics introduced in this chapter, modular arithmetic, belongs to the
field of number theory. this is a fascinating subject area which is, unfortunately,
historically viewed as a branch of mathematics without applications. thus, it is
rarely taught outside mathematics curricula. there is a wealth of books on number
theory. among the classic introductory books are references [129, 148]. a particularly accessible book written for non-mathematications is [156].

1.5 discussion and further reading

21

research community and general references even though cryptography has
matured considerably over the last 30 years, it is still a relatively young field compared to other disciplines, and every year brings many new developments and discoveries. many research results are published at events organized by the international association for cryptologic research (iacr). the proceedings of the three
iacr conferences crypto, eurocrypt, and asiacrypt as well as the iacr
workshops cryptographic hardware and embedded systems (ches), fast software encryption (fse), public key cryptography (pkc) and theory of cryptograpy (tcc), are excellent sources for tracking the recent developments in the
field of cryptology at large. two important conferences which deal with the larger
issue of security (of which cryptography is one aspect) are the ieee symposium on
security and privacy and the usenix security forum. all of the events listed take
place annually.
there are several good books on cryptography. as reference sources, the handbook of applied cryptography [120] and the more recent encyclopedia of cryptography and security [168] are highly recommended both make excellent additions
to this textbook.
provable security due to our focus on practical cryptography, this book omits
most aspects related to the theoretical foundations of crypto algorithms and protocols. especially in modern cryptographic research, there is a strong desire to provide
statements about cryptographic schemes which are provable in a strict mathematical
sense. for this, the goals of both a security system and the adversary are described
in a formal model. often, proofs are achieved by reducing the security of a system to
certain assumptions, e.g., that factorization of integers is hard or that a hash function
is collision free.
the field of provable security is quite large. we list now some important subareas.
a recent survey on the specific area of provable public-key encryption is given in
[55]. provable security is closely related to cryptographic foundations, which studies the general assumptions and approaches needed. for instance, the interrelationship between certain presumably hard problems (e.g., integer factorization and discrete logarithm) are studied. the standard references are [81, 83]. zero-knowledge
proofs are concerned with proving a certain knowledge towards another party without revealing the secret. they were originally motivated by proving an entitys identity without revealing a password or key. however, they are typically not used that
way any more. an early reference is [139], and a more recent tutorial is given in
[82]. multiparty computation can be used to compute answers such as the outcome
of an election or determining the highest bid in an auction based on encrypted data.
the interesting part is that when the protocol is completed the participants know
only their own input and the answer but nothing about the encrypted data of the
other participants. good reference sources are [112] and [83, chap. 7].
a few times this book also touches upon provable security, for instance the relationship between diffiehellman key exchange and the diffiehellman problem
(cf. sect. 8.4), the block cipher based hash functions in sect. 11.3.2 or the security
of the hmac message authentication scheme in sect. 12.2.

22

1 introduction to cryptography and data security

as a word of caution, it should be mentioned that even though very practical
results have been derived from research in the provable security of crypto schemes,
many findings are only of limited practical value. also, the whole field is not without
controversy [84, 102].
secure system design cryptography is often an important tool for building a secure system, but on the other hand secure system design encompasses many other
aspects. security systems are intended to protect something valuable, e.g., information, monetary values, personal property, etc. the main objective of secure system
design is to make breaking the system more costly than the value of the protected
assets, where the cost should be measured in monetary value but also in more
abstract terms such as effort or reputation. generally speaking, adding security to a
system often narrows its usability.
in order to approach the problem systematically, several general frameworks exist. they typically require that assets and corresponding security needs have to be
defined, and that the attack potential and possible attack paths must be evaluated.
finally, adequate countermeasures have to be specified in order to realize an appropriate level of security for a particular application or environment.
there are standards which can be used for evaluation and help to define a secure system. among the more prominent ones are iso/iec [94] (15408, 15443-1,
15446, 19790, 19791, 19792, 21827), the common criteria for information technology security evaluation [46], the german it-grundschutzhandbuch [37], fips
pubs [77] and many more.

1.6 lessons learned






never ever develop your own crypto algorithm unless you have a team of experienced cryptanalysts checking your design.
do not use unproven crypto algorithms (i.e., symmetric ciphers, asymmetric ciphers, hash functions) or unproven protocols.
attackers always look for the weakest point of a cryptosystem. for instance, a
large key space by itself is no guarantee for a cipher being secure the cipher
might still be vulnerable against analytical attacks.
key lengths for symmetric algorithms in order to thwart exhaustive key-search
attacks are





64 bits insecure except for data with extremely short-term value.
112128 bits long-term security of several decades, including attacks by intelligence agencies unless they possess quantum computers. based on our current knowledge, attacks are only feasible with quantum computers (which do
not exist and perhaps never will).
256 bit as above, but possibly against attacks by quantum computers.

1.6 lessons learned


23

modular arithmetic is a tool for expressing historical encryption schemes, such
as the affine cipher, in a mathematically elegant way.

24

1 introduction to cryptography and data security

problems
1.1. the ciphertext below was encrypted using a substitution cipher. decrypt the ciphertext without knowledge of the key.
lrvmnir bpr sumvbwvr jx bpr lmiwv yjeryrkbi jx qmbm wi
bpr xjvni mkd ymibrut jx irhx wi bpr riirkvr jx
ymbinlmtmipw utn qmumbr dj w ipmhh but bj rhnvwdmbr bpr
yjeryrkbi jx bpr qmbm mvvjudwko bj yt wkbrusurbmbwjk
lmird jk xjubt trmui jx ibndt
wb wi kjb mk rmit bmiq bj rashmwk rmvp yjeryrkb mkd wbi
iwokwxwvmkvr mkd ijyr ynib urymwk nkrashmwkrd bj ower m
vjyshrbr rashmkmbwjk jkr cjnhd pmer bj lr fnmhwxwrd mkd
wkiswurd bj invp mk rabrkb bpmb pr vjnhd urmvp bpr ibmbr
jx rkhwopbrkrd ywkd vmsmlhr jx urvjokwgwko ijnkdhrii
ijnkd mkd ipmsrhrii ipmsr w dj kjb drry ytirhx bpr xwkmh
mnbpjuwbt lnb yt rasruwrkvr cwbp qmbm pmi hrxb kj djnlb
bpmb bpr xjhhjcwko wi bpr sujsru msshwvmbwjk mkd
wkbrusurbmbwjk w jxxru yt bprjuwri wk bpr pjsr bpmb bpr
riirkvr jx jqwkmcmk qmumbr cwhh urymwk wkbmvb
1. compute the relative frequency of all letters a...z in the ciphertext. you may
want to use a tool such as the open-source program cryptool [50] for this task.
however, a paper and pencil approach is also still doable.
2. decrypt the ciphertext with the help of the relative letter frequency of the english
language (see table 1.1 in sect. 1.2.2). note that the text is relatively short and
that the letter frequencies in it might not perfectly align with that of general
english language from the table.
3. who wrote the text
1.2. we received the following ciphertext which was encoded with a shift cipher
xultpaajcxitltlxaarpjhtiwtgxktghidhipxciwtvgtpilpit
ghlxiwiwtxgqadds.
1. perform an attack against the cipher based on a letter frequency count how
many letters do you have to identify through a frequency count to recover the
key what is the cleartext
2. who wrote this message
1.3. we consider the long-term security of the advanced encryption standard
(aes) with a key length of 128-bit with respect to exhaustive key-search attacks.
aes is perhaps the most widely used symmetric cipher at this time.
1. assume that an attacker has a special purpose application specific integrated circuit (asic) which checks 5  108 keys per second, and she has a budget of 1
million. one asic costs 50, and we assume 100% overhead for integrating

problems

25

the asic (manufacturing the printed circuit boards, power supply, cooling, etc.).
how many asics can we run in parallel with the given budget how long does
an average key search take relate this time to the age of the universe, which is
about 1010 years.
2. we try now to take advances in computer technology into account. predicting
the future tends to be tricky but the estimate usually applied is moores law,
which states that the computer power doubles every 18 months while the costs
of integrated circuits stay constant. how many years do we have to wait until a
key-search machine can be built for breaking aes with 128 bit with an average
search time of 24 hours again, assume a budget of 1 million (do not take
inflation into account).
1.4. we now consider the relation between passwords and key size. for this purpose
we consider a cryptosystem where the user enters a key in the form of a password.
1. assume a password consisting of 8 letters, where each letter is encoded by the
ascii scheme (7 bits per character, i.e., 128 possible characters). what is the
size of the key space which can be constructed by such passwords
2. what is the corresponding key length in bits
3. assume that most users use only the 26 lowercase letters from the alphabet instead of the full 7 bits of the ascii-encoding. what is the corresponding key
length in bits in this case
4. at least how many characters are required for a password in order to generate a
key length of 128 bits in case of letters consisting of
a. 7-bit characters
b. 26 lowercase letters from the alphabet
1.5. as we learned in this chapter, modular arithmetic is the basis of many cryptosystems. as a consequence, we will address this topic with several problems in
this and upcoming chapters.
lets start with an easy one compute the result without a calculator.
1.
2.
3.
4.

15  29 mod 13
2  29 mod 13
2  3 mod 13
11  3 mod 13

the results should be given in the range from 0, 1, . . . , modulus-1. briefly describe
the relation between the different parts of the problem.
1.6. compute without a calculator
1. 1/5 mod 13
2. 1/5 mod 7
3. 3  2/5 mod 7
1.7. we consider the ring z4 . construct a table which describes the addition of all
elements in the ring with each other

26

1 introduction to cryptography and data security

+
0
1
2
3
1.
2.
3.
4.

0 1 2 3
0 1 2 3
1 2 


construct the multiplication table for z4 .
construct the addition and multiplication tables for z5 .
construct the addition and multiplication tables for z6 .
there are elements in z4 and z6 without a multiplicative inverse. which elements are these why does a multiplicative inverse exist for all nonzero elements
in z5 

1.8. what is the multiplicative inverse of 5 in z11 , z12 , and z13  you can do a
trial-and-error search using a calculator or a pc.
with this simple problem we want now to stress the fact that the inverse of an
integer in a given ring depends completely on the ring considered. that is, if the
modulus changes, the inverse changes. hence, it doesnt make sense to talk about
an inverse of an element unless it is clear what the modulus is. this fact is crucial
for the rsa cryptosystem, which is introduced in chap. 7. the extended euclidean
algorithm, which can be used for computing inverses efficiently, is introduced in
sect. 6.3.
1.9. compute x as far as possible without a calculator. where appropriate, make use
of a smart decomposition of the exponent as shown in the example in sect. 1.4.1
1.
2.
3.
4.
5.

x  32 mod 13
x  72 mod 13
x  310 mod 13
x  7100 mod 13
7x  11 mod 13

the last problem is called a discrete logarithm and points to a hard problem which
we discuss in chap. 8. the security of many public-key schemes is based on the
hardness of solving the discrete logarithm for large numbers, e.g., with more than
1000 bits.
1.10. find all integers n between 0  n  m that are relatively prime to m for m 
4, 5, 9, 26. we denote the number of integers n which fulfill the condition by  (m),
e.g.  (3)  2. this function is called eulers phi function. what is  (m) for m 
4, 5, 9, 26
1.11. this problem deals with the affine cipher with the key parameters a  7, b 
22.
1. decrypt the text below
falszztysyjzyjkywjrztyjztyynaryjkyswarztyegyyj
2. who wrote the line

problems

27

1.12. now, we want to extend the affine cipher from sect. 1.4.4 such that we can
encrypt and decrypt messages written with the full german alphabet. the german
alphabet consists of the english one together with the three umlauts, a, o, u, and the
(even stranger) double s character . we use the following mapping from letters
to integers
a0
g6
m  12
s  18
y  24

b1
h7
n  13
t  19
z  25

c2
i8
o  14
u  20
a  26

d3
j9
p  15
v  21
o  27

e4
k  10
q  16
w  22
u  28

f5
l  11
r  17
x  23
  29

1. what are the encryption and decryption equations for the cipher
2. how large is the key space of the affine cipher for this alphabet
3. the following ciphertext was encrypted using the key (a  17, b  1). what is
the corresponding plaintext
a u  w 

4. from which village does the plaintext come
1.13. in an attack scenario, we assume that the attacker oscar manages somehow
to provide alice with a few pieces of plaintext that she encrypts. show how oscar
can break the affine cipher by using two pairs of plaintextciphertext, (x1 , y1 ) and
(x2 , y2 ). what is the condition for choosing x1 and x2 
remark in practice, such an assumption turns out to be valid for certain settings,
e.g., encryption by web servers, etc. this attack scenario is, thus, very important and
is denoted as a chosen plaintext attack.
1.14. an obvious approach to increase the security of a symmetric algorithm is to
apply the same cipher twice, i.e.
y  ek2 (ek1 (x))
as is often the case in cryptography, things are very tricky and results are often different from the expected and/ or desired ones. in this problem we show that a double
encryption with the affine cipher is only as secure as single encryption assume two
affine ciphers ek1  a1 x + b1 and ek2  a2 x + b2 .
1. show that there is a single affine cipher ek3  a3 x + b3 which performs exactly
the same encryption (and decryption) as the combination ek2 (ek1 (x)).
2. find the values for a3 , b3 when a1  3, b1  5 and a2  11, b2  7.
3. for verification (1) encrypt the letter k first with ek1 and the result with ek2 , and
(2) encrypt the letter k with ek3 .
4. briefly describe what happens if an exhaustive key-search attack is applied to a
double-encrypted affine ciphertext. is the effective key space increased
remark the issue of multiple encryption is of great practical importance in the
case of the data encryption standard (des), for which multiple encryption (in particular, triple encryption) does increase security considerably.

chapter 2

stream ciphers

if we look at the types of cryptographic algorithms that exist in a little bit more
detail, we see that the symmetric ciphers can be divided into stream ciphers and
block ciphers, as shown in fig. 2.1.
 


 
  

  


 
  



    

fig. 2.1 main areas within cryptography

this chapter gives an introduction to stream ciphers





the pros and cons of stream ciphers
random and pseudorandom number generators
a truly unbreakable cipher the one-time pad (otp)
linear feedback shift registers and trivium, a modern stream cipher

c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 2, 

29

30

2 stream ciphers

2.1 introduction
2.1.1 stream ciphers vs. block ciphers
symmetric cryptography is split into block ciphers and stream ciphers, which are
easy to distinguish. figure 2.2 depicts the operational differences between stream
(fig. 2.2a) and block (fig. 2.2b) ciphers when we want to encrypt b bits at a time,
where b is the width of the block cipher.









 

















(a)




(b)

fig. 2.2 principles of encrypting b bits with a stream (a) and a block (b) cipher

a description of the principles of the two types of symmetric ciphers follows.
stream ciphers encrypt bits individually. this is achieved by adding a bit from
a key stream to a plaintext bit. there are synchronous stream ciphers where
the key stream depends only on the key, and asynchronous ones where the key
stream also depends on the ciphertext. if the dotted line in fig. 2.3 is present,
the stream cipher is an asynchronous one. most practical stream ciphers are synchronous ones and sect. 2.3 of this chapter will deal with them. an example of
an asynchronous stream cipher is the cipher feedback (cfb) mode introduced in
sect. 5.1.4.



  





fig. 2.3 synchronous and asynchronous stream ciphers

block ciphers encrypt an entire block of plaintext bits at a time with the same
key. this means that the encryption of any plaintext bit in a given block depends
on every other plaintext bit in the same block. in practice, the vast majority of
block ciphers either have a block length of 128 bits (16 bytes) such as the advanced encryption standard (aes), or a block length of 64 bits (8 bytes) such as

2.1 introduction

31

the data encryption standard (des) or triple des (3des) algorithm. all of these
ciphers are introduced in later chapters.
this chapter gives an introduction to stream ciphers. before we go into more
detail, it will be helpful to learn some useful facts about stream ciphers vs. block
ciphers
1. in practice, in particular for encrypting computer communication on the internet,
block ciphers are used more often than stream ciphers.
2. because stream ciphers tend to be small and fast, they are particularly relevant
for applications with little computational resources, e.g., for cell phones or other
small embedded devices. a prominent example for a stream cipher is the a5/1
cipher, which is part of the gsm mobile phone standard and is used for voice
encryption. however, stream ciphers are sometimes also used for encrypting internet traffic, especially the stream cipher rc4.
3. traditionally, it was assumed that stream ciphers tended to encrypt more efficiently than block ciphers. efficient for software-optimized stream ciphers means
that they need fewer processor instructions (or processor cycles) to encrypt one
bit of plaintext. for hardware-optimized stream ciphers, efficient means they need
fewer gates (or smaller chip area) than a block cipher for encrypting at the same
data rate. however, modern block ciphers such as aes are also very efficient in
software. moreover, for hardware, there are also highly efficient block ciphers,
such as present, which are as efficient as very compact stream ciphers.

2.1.2 encryption and decryption with stream ciphers
as mentioned above, stream ciphers encrypt plaintext bits individually. the question
now is how does encryption of an individual bit work the answer is surprisingly
simple each bit xi is encrypted by adding a secret key stream bit si modulo 2.
definition 2.1.1 stream cipher encryption and decryption
the plaintext, the ciphertext and the key stream consist of individual bits,
i.e., xi , yi , si  {0, 1}.
encryption yi  esi (xi )  xi + si mod 2.
decryption xi  dsi (yi )  yi + si mod 2.
since encryption and decryption functions are both simple additions modulo 2,
we can depict the basic operation of a stream cipher as shown in fig. 2.4. note that
we use a circle with an addition sign as the symbol for modulo 2 addition.
just looking at the formulae, there are three points about the stream cipher encryption and decryption function which we should clarify
1. encryption and decryption are the same functions

32

2 stream ciphers








 
  





fig. 2.4 encryption and decryption with stream ciphers

2. why can we use a simple modulo 2 addition as encryption
3. what is the nature of the key stream bits si 
the following discussion of these three items will give us already an understanding
of some important stream cipher properties.

why are encryption and decryption the same function
the reason for the similarity of the encryption and decryption function can easily
be shown. we must prove that the decryption function actually produces the plaintext bit xi again. we know that ciphertext bit yi was computed using the encryption
function yi  xi + si mod 2. we insert this encryption expression in the decryption
function
dsi (yi )  yi + si mod 2
 (xi + si ) + si mod 2
 xi + si + si mod 2
 xi + 2 si mod 2
 xi + 0 mod 2
 xi mod 2 q.e.d.
the trick here is that the expression (2 si mod 2) has always the value zero since
2  0 mod 2. another way of understanding this is as follows if si has either the
value 0, in which case 2 si  2  0  0 mod 2. if si  1, we have 2 si  2  1  2 
0 mod 2.

why is modulo 2 addition a good encryption function
a mathematical explanation for this is given in the context of the one-time pad in
sect. 2.2.2. however, it is worth having a closer look at addition modulo 2. if we do
arithmetic modulo 2, the only possible values are 0 and 1 (because if you divide by
2, the only possible remainders are 0 and 1). thus, we can treat arithmetic modulo
2 as boolean functions such as and gates, or gates, nand gates, etc. lets look
at the truth table for modulo 2 addition
this should look familiar to most readers it is the truth table of the exclusive-or,
also called xor, gate. this is in important fact modulo 2 addition is equivalent to

2.1 introduction

33
xi
0
0
1
1

si yi  xi + si mod 2
0
0
1
1
0
1
1
0

the xor operation. the xor operation plays a major role in modern cryptography
and will be used many times in the remainder of this book.
the question now is, why is the xor operation so useful, as opposed to, for
instance, the and operation lets assume we want to encrypt the plaintext bit
xi  0. if we look at the truth table we find that we are on either the 1st or 2nd line
of the truth table
table 2.1 truth table of the xor operation
xi
0
0
1
1

si
0
1
0
1

yi
0
1
1
0

depending on the key bit, the ciphertext yi is either a zero (si  0) or one (si  1).
if the key bit si behaves perfectly randomly, i.e., it is unpredictable and has exactly a
50% chance to have the value 0 or 1, then both possible ciphertexts also occur with
a 50% likelihood. likewise, if we encrypt the plaintext bit xi  1, we are on line 3
or 4 of the truth table. again, depending on the value of the key stream bit si , there
is a 50% chance that the ciphertext is either a 1 or a 0.
we just observed that the xor function is perfectly balanced, i.e., by observing
an output value, there is exactly a 50% chance for any value of the input bits. this
distinguishes the xor gate from other boolean functions such as the or, and or
nand gate. moreover, and and nand gates are not invertible. lets look at a
very simple example for stream cipher encryption.
example 2.1. alice wants to encrypt the letter a, where the letter is given in ascii
code. the ascii value for a is 6510  10000012 . lets furthermore assume that the
first key stream bits are (s0 , . . . , s6 )  0101100.
alice
x0 , . . . , x6  1000001  a

s0 , . . . , s6  0101100
y0 , . . . , y6  1101101  m

oscar

bob

.
m1101101

y0 , . . . , y6  1101101

s0 , . . . , s6  0101100
x0 , . . . , x6  1000001  a

34

2 stream ciphers

note that the encryption by alice turns the uppercase a into the lower case letter
m. oscar, the attacker who eavesdrops on the channel, only sees the ciphertext letter
m. decryption by bob with the same key stream reproduces the plaintext a again.

so far, stream ciphers look unbelievably easy one simply takes the plaintext,
performs an xor operation with the key and obtains the ciphertext. on the receiving
side, bob does the same. the only thing left to discuss is the last question from
above.

what exactly is the nature of the key stream
it turns out that the generation of the values si , which are called the key stream, is
the central issue for the security of stream ciphers. in fact, the security of a stream
cipher completely depends on the key stream. the key stream bits si are not the key
bits themselves. so, how do we get the key stream generating the key stream is
pretty much what stream ciphers are about. this is a major topic and is discussed
later in this chapter. however, we can already guess that a central requirement for
the key stream bits should be that they appear like a random sequence to an attacker.
otherwise, an attacker oscar could guess the bits and do the decryption by himself.
hence, we first need to learn more about random numbers.
historical remark stream ciphers were invented in 1917 by gilbert vernam, even
though they were not called stream ciphers back at that time. he built an electromechanical machine which automatically encrypted teletypewriter communication. the plaintext was fed into the machine as one paper tape, and the key stream
as a second tape. this was the first time that encryption and transmission was automated in one machine. vernam studied electrical engineering at worcester polytechnic institute (wpi) in massachusetts where, by coincidence, one of the authors
of this book was a professor in the 1990s. stream ciphers are sometimes referred to
as vernam ciphers. occasionally, one-time pads are also called vernam ciphers. for
further reading on vernams machine, the book by kahn [97] is recommended.

2.2 random numbers and an unbreakable stream cipher
2.2.1 random number generators
as we saw in the previous section, the actual encryption and decryption of stream
ciphers is extremely simple. the security of stream ciphers hinges entirely on a
suitable key stream s0 , s1 , s2 , . . .. since randomness plays a major role, we will first
learn about the three types of random number generators (rng) that are important
for us.

2.2 random numbers and an unbreakable stream cipher

35

true random number generators (trng)
true random number generators (trngs) are characterized by the fact that their
output cannot be reproduced. for instance, if we flip a coin 100 times and record the
resulting sequence of 100 bits, it will be virtually impossible for anyone on earth
to generate the same 100 bit sequence. the chance of success is 1/2100 , which is
an extremely small probability. trngs are based on physical processes. examples
include coin flipping, rolling of dice, semiconductor noise, clock jitter in digital
circuits and radioactive decay. in cryptography, trngs are often needed for generating session keys, which are then distributed between alice and bob, and for other
purposes.

(general) pseudorandom number generators (prng)
pseudorandom number generators (prngs) generate sequences which are computed from an initial seed value. often they are computed recursively in the following way
s0  seed
si+1  f (si ), i  0, 1, . . .
a generalization of this are generators of the form si+1  f (si , si1 , . . . , sit ), where
t is a fixed integer. a popular example is the linear congruential generator
s0  seed
si+1  a si + b mod m, i  0, 1, . . .
where a, b, m are integer constants. note that prngs are not random in a true sense
because they can be computed and are thus completely deterministic. a widely used
example is the rand() function used in ansi c. it has the parameters
s0  12345
si+1  1103515245 si + 12345 mod 231 , i  0, 1, . . .
a common requirement of prngs is that they possess good statistical properties, meaning their output approximates a sequence of true random numbers. there
are many mathematical tests, e.g., the chi-square test, which can verify the statistical
behavior of prng sequences. note that there are many, many applications for pseudorandom numbers outside cryptography. for instance, many types of simulations
or testing, e.g., of software or of vlsi chips, need random data as input. that is the
reason why a prng is included in the ansi c specification.

36

2 stream ciphers

cryptographically secure pseudorandom number generators (csprng)
cryptographically secure pseudorandom number generators (csprngs) are a special type of prng which possess the following additional property a csprng is
prng which is unpredictable. informally, this means that given n output bits of the
key stream si , si+1 , . . . , si+n1 , where n is some integer, it is computationally infeasible to compute the subsequent bits si+n , si+n+1 , . . .. a more exact definition is that
given n consecutive bits of the key stream, there is no polynomial time algorithm
that can predict the next bit sn+1 with better than 50% chance of success. another
property of csprng is that given the above sequence, it should be computationally
infeasible to compute any preceding bits si1 , si2 , . . ..
note that the need for unpredictability of csprngs is unique to cryptography.
in virtually all other situations where pseudorandom numbers are needed in computer science or engineering, unpredictability is not needed. as a consequence, the
distinction between prng and csprn and their relevance for stream ciphers is often not clear to non-cryptographers. almost all prng that were designed without
the clear purpose of being stream ciphers are not csprngs.

2.2.2 the one-time pad
in the following we discuss what happens if we use the three types of random numbers as generators for the key stream sequence s0 , s1 , s2 , . . . of a stream cipher. lets
first define what a perfect cipher should be
definition 2.2.1 unconditional security
a cryptosystem is unconditionally or information-theoretically secure if it cannot be broken even with infinite computational resources.
unconditional security is based on information theory and assumes no limit on
the attackers computational power. this looks like a pretty straightforward definition. it is in fact straightforward, but the requirements for a cipher to be unconditionally secure are tremendous. lets look at it using a gedankenexperiment assume we have a symmetric encryption algorithm (it doesnt matter whether its a
block cipher or stream cipher) with a key length of 10,000 bits, and the only attack
that works is an exhaustive key search, i.e, a brute-force attack. from the discussion
in sect. 1.3.2, we recall that 128 bits are more than enough for long-term security.
so, is a cipher with 10,000 bits unconditionally secure the answer is simple no
since an attacker can have infinite computational resources, we can simply assume
that the attacker has 210000 computers available and every computer checks exactly
one key. this will give us a correct key in one time step. of course, there is no way
that 210000 computer can ever be built, the number is too large. (it is estimated that

2.2 random numbers and an unbreakable stream cipher

37

there are only about 2266 atoms in the known universe.) the cipher would merely
be computationally secure but not unconditionally.
all this said, we now show a way to build an unconditionally secure cipher that
is quite simple. this cipher is called the one-time pad.
definition 2.2.2 one-time pad (otp)
a stream cipher for which
1. the key stream s0 , s1 , s2 , . . . is generated by a true random number generator, and
2. the key stream is only known to the legitimate communicating
parties, and
3. every key stream bit si is only used once
is called a one-time pad. the one-time pad is unconditionally secure.
it is easy to show why the otp is unconditionally secure. here is a sketch of a
proof. for every ciphertext bit we get an equation of this form
y0  x0 + s0 mod 2
y1  x1 + s1 mod 2
..
.
each individual relation is a linear equation modulo 2 with two unknowns. they
are impossible to solve. if the attacker knows the value for y0 (0 or 1), he cannot
determine the value of x0 . in fact, the solutions x0  0 and x0  1 are exactly equally
likely if s0 stems from a truly random source and there is 50% chance that it has the
value 0 and 1. the situation is identical for the second equation and all subsequent
ones. note that the situation is different if the values si are not truly random. in this
case, there is some functional relationship between them, and the equations shown
above are not independent. even though it might still be hard to solve the system of
equations, it is not provably secure
so, now we have a simple cipher which is perfectly secure. there are rumors
that the red telephone between the white house and the kremlin was encrypted
using an otp during the cold war. obviously there must be a catch since otps are
not used for web browsers, e-mail encryption, smart cards, mobile phones, or other
important applications. lets look at the implications of the three requirements in
defintion 2.2.2. the first requirement means that we need a trng. that means we
need a device, e.g., based on white noise of a semiconductor, that generates truly
random bits. since standard pcs do not have trng, this requirement might not be
that convenient but can certainly be met. the second requirement means that alice
has to get the random bits securely to bob. in practice that could mean that alice
burns the true random bits on a cd rom and sends them securely, e.g., with a
trusted courier, to bob. still doable, but not great. the third requirement is probably

38

2 stream ciphers

the most impractical one key stream bits cannot be re-used. this implies that we
need one key bit for every bit of plaintext. hence, our key is as long as the plaintext
this is probably the major drawback of the otp. even if alice and bob share a cd
with 1 mbyte of true random numbers, we run quickly into limits. if they send a
single email with an attachment of 1 mbyte, they could encrypt and decrypt it, but
after that they would need to exchange a true random key stream again.
for these reasons otps are rarely used in practice. however, they give us a great
design idea for secure ciphers if we xor truly random bits and plaintext, we get
ciphertext that can certainly not be broken by an attacker. we will see in the next
section how we can use this fact to build practical stream ciphers.

2.2.3 towards practical stream ciphers
in the previous section we saw that otps are unconditionally secure, but that they
have drawbacks which make them impractical. what we try to do with practical
stream ciphers is to replace the truly random key stream bits by a pseudorandom
number generator where the key k serves as a seed. the principle of practical stream
ciphers is shown in fig. 2.5.
 









 

  
 

  
 




 




  






fig. 2.5 practical stream ciphers

before we turn to stream ciphers used in the real world, it should be stressed that
practical stream ciphers are not unconditionally secure. in fact, all known practical
crypto algorithms (stream ciphers, block ciphers, public-key algorithms) are not
unconditionally secure. the best we can hope for is computational security, which
we define as follows
definition 2.2.3 computational security
a cryptosystem is computationally secure if the best known algorithm for breaking it requires at least t operations.

2.2 random numbers and an unbreakable stream cipher

39

this seems like a reasonable definition, but there are still several problems with
it. first, often we do not know what the best algorithm for a given attack is. a
prime example is the rsa public-key scheme, which can be broken by factoring
large integers. even though many factoring algorithms are known, we do not know
whether there exist any better ones. second, even if a lower bound on the complexity
of one attack is known, we do not know whether any other, more powerful attacks
are possible. we saw this in sect. 1.2.2 during the discussion about the substitution
cipher even though we know the exact computational complexity for an exhaustive
key search, there exist other more powerful attacks. the best we can do in practice
is to design crypto schemes for which it is assumed that they are computationally
secure. for symmetric ciphers this usually means one hopes that there is no attack
method with a complexity better than an exhaustive key search.
lets go back to fig. 2.5. this design emulates (behaves like) a one-time pad.
it has the major advantage over the otp that alice and bob only need to exchange a
secret key that is at most a few 100 bits long, and that does not have to be as long as
the message we want to encrypt. we now have to think carefully about the properties
of the key stream s0 , s1 , s2 , . . . that is generated by alice and bob. obviously, we
need some type of random number generator to derive the key stream. first, we note
that we cannot use a trng since, by definition, alice and bob will not be able to
generate the same key stream. instead we need deterministic, i.e., pseudorandom,
number generators. we now look at the other two generators that were introduced
in the previous section.

building key streams from prngs
here is an idea that seems promising (but in fact is pretty bad) many prngs possess good statistical properties, which are necessary for a strong stream cipher. if
we apply statistical tests to the key stream sequence, the output should pretty much
behave like the bit sequence generated by tossing a coin. so it is tempting to assume
that a prng can be used to generate the key stream. but all of this is not sufficient
for a stream cipher since our opponent, oscar, is smart. consider the following attack
example 2.2. lets assume a prng based on the linear congruential generator
s0  seed
si+1  a si + b mod m, i  0, 1, . . .
where we choose m to be 100 bits long and si , a, b  {0, 1, . . . , m  1}. note that this
prng can have excellent statistical properties if we choose the parameters carefully.
the modulus m is part of the encryption scheme and is publicly known. the secret
key comprises the values (a, b) and possibly the seed s0 , each with a length of 100.
that gives us a key length of 200 bit, which is more than sufficient to protect against
a brute-force attack. since this is a stream cipher, alice can encrypt

40

2 stream ciphers

yi  xi + si mod 2
where si are the bits of the binary representation of the prng output symbols s j .
but oscar can easily launch an attack. assume he knows the first 300 bits of
plaintext (this is only 300/837.5 byte), e.g., file header information, or he guesses
part of the plaintext. since he certainly knows the ciphertext, he can now compute
the first 300 bits of key stream as
si  yi + xi mod m , i  1, 2, . . . , 300
these 300 bits immediately give the first three output symbols of the prng s1 
(s1 , . . . , s100 ), s2  (s101 , . . . , s200 ) and s3  (s201 , . . . , s300 ). oscar can now generate
two equations
s2  a s1 + b mod m
s3  a s2 + b mod m
this is a system of linear equations over zm with two unknowns a and b. but those
two values are the key, and we can immediately solve the system, yielding
a  (s2  s3 )/(s1  s2 ) mod m
b  s2  s1 (s2  s3 )/(s1  s2 ) mod m
in case gcd((s1 s2 ), m))  1 we get multiple solutions since this is an equation system over zm . however, with a fourth piece of known plaintext the key can uniquely
be detected in almost all cases. alternatively, oscar simply tries to encrypt the message with each of the multiple solutions found. hence, in summary if we know a
few pieces of plaintext, we can compute the key and decrypt the entire ciphertext

this type of attack is why the notation of csprng was invented.

building key streams from csprngs
what we need to do to prevent the attack above is to use a csprng, which assures
that the key stream is unpredictable. we recall that this means that given the first n
output bits of the key stream s1 , s2 , . . . , sn , it is computationally infeasible to compute the bits sn+1 , sn+2 , . . .. unfortunately, pretty much all pseudorandom number
generators that are used for applications outside cryptography are not cryptographically secure. hence, in practice, we need to use specially designed pseudorandom
number generators for stream ciphers.
the question now is how practical stream ciphers actually look. there are many
proposals for stream ciphers out in the literature. they can roughly be classified as
ciphers either optimized for software implementation or optimized for hardware implementation. in the former case, the ciphers typically require few cpu instructions

2.3 shift register-based stream ciphers

41

to compute one key stream bit. in the latter case, they tend to be based on operations
which can easily be realized in hardware. a popular example is shift registers with
feedback, which are discussed in the next section. a third class of stream ciphers
is realized by using block ciphers as building blocks. the cipher feedback mode,
output feedback mode and counter mode to be introduced in chap. 5 are examples
of stream ciphers derived from block ciphers.
it could be argued that the state-of-the-art in block cipher design is more advanced than stream ciphers. currently it seems to be easier for scientists to design
secure block ciphers than stream ciphers. subsequent chapters deal in great detail
with the two most popular and standardized block ciphers, des and aes.

2.3 shift register-based stream ciphers
as we have learned so far, practical stream ciphers use a stream of key bits s1 , s2 , . . .
that are generated by the key stream generator, which should have certain properties.
an elegant way of realizing long pseudorandom sequences is to use linear feedback
shift registers (lfsrs). lfsrs are easily implemented in hardware and many, but
certainly not all, stream ciphers make use of lfsrs. a prominent example is the
a5/1 cipher, which is standardized for voice encryption in gsm. as we will see,
even though a plain lfsr produces a sequence with good statistical properties, it
is cryptographically weak. however, combinations of lfsrs, such as a5/1 or the
cipher trivium, can make secure stream ciphers. it should be stressed that there
are many ways for constructing stream ciphers. this section only introduces one of
several popular approaches.

2.3.1 linear feedback shift registers (lfsr)
an lfsr consists of clocked storage elements (flip-flops) and a feedback path. the
number of storage elements gives us the degree of the lfsr. in other words, an
lfsr with m flip-flops is said to be of degree m. the feedback network computes
the input for the last flip-flop as xor-sum of certain flip-flops in the shift register.
example 2.3. simple lfsr we consider an lfsr of degree m  3 with flip-flops
ff2 , ff1 , ff0 , and a feedback path as shown in fig. 2.6. the internal state bits are
denoted by si and are shifted by one to the right with each clock tick. the rightmost
state bit is also the current output bit. the leftmost state bit is computed in the
feedback path, which is the xor sum of some of the flip-flop values in the previous
clock period. since the xor is a linear operation, such circuits are called linear
feedback shift registers. if we assume an initial state of (s2  1, s1  0, s0  0),
table 2.2 gives the complete sequence of states of the lfsr. note that the rightmost
column is the output of the lfsr. one can see from this example that the lfsr

42

2 stream ciphers

















fig. 2.6 linear feedback shift register of degree 3 with initial values s2 , s1 , s0
table 2.2 sequence of states of the lfsr
clk
0
1
2
3
4
5
6
7
8

ff2 ff1 ff0  si
1
0
0
0
1
0
1
0
1
1
1
0
1
1
1
0
1
1
0
0
1
1
0
0
0
1
0

starts to repeat after clock cycle 6. this means the lfsr output has period of length
7 and has the form
0010111 0010111 0010111 . . .
there is a simple formula which determines the functioning of this lfsr. lets
look at how the output bits si are computed, assuming the initial state bits s0 , s1 , s2 
s3  s1 + s0 mod 2
s4  s2 + s1 mod 2
s5  s3 + s2 mod 2
..
.
in general, the output bit is computed as
si+3  si+1 + si mod 2
where i  0, 1, 2, . . .

this was, of course, a simple example. however, we could already observe many
important properties. we will now look at general lfsrs.

2.3 shift register-based stream ciphers

43

a mathematical description of lfsrs
the general form of an lfsr of degree m is shown in fig. 2.7. it shows m flip-flops
and m possible feedback locations, all combined by the xor operation. whether a
feedback path is active or not, is defined by the feedback coefficient p0 , p1 , . . . , pm1 



if pi  1 (closed switch), the feedback is active.
if pi  0 (open switch), the corresponding flip-flop output is not used for the
feedback.

with this notation, we obtain an elegant mathematical description for the feedback
path. if we multiply the output of flip-flop i by its coefficient pi , the result is either
the output value if pi  1, which corresponds to a closed switch, or the value zero if
pi  0, which corresponds to an open switch. the values of the feedback coefficients
are crucial for the output sequence produced by the lfsr.
















fig. 2.7 general lfsr with feedback coefficients pi and initial values sm1 , . . . , s0

lets assume the lfsr is initially loaded with the values s0 , . . . , sm1 . the next
output bit of the lfsr sm , which is also the input to the leftmost flip-flop, can be
computed by the xor-sum of the products of flip-flop outputs and corresponding
feedback coefficient
sm  sm1 pm1 +    + s1 p1 + s0 p0 mod 2
the next lfsr output can be computed as
sm+1  sm pm1 +    + s2 p1 + s1 p0 mod 2
in general, the output sequence can be described as
si+m 

m1

 p j  si+ j mod

2

si , p j  {0, 1} i  0, 1, 2, . . .

(2.1)

j0

clearly, the output values are given through a combination of some previous output
values. lfsrs are sometimes referred to as linear recurrences.

44

2 stream ciphers

due to the finite number of recurring states, the output sequence of an lfsr repeats periodically. this was also illustrated in example 2.3. moreover, an lfsr can
produce output sequences of different lengths, depending on the feedback coefficients. the following theorem gives us the maximum length of an lfsr as function
of its degree.
theorem 2.3.1 the maximum sequence length generated by an
lfsr of degree m is 2m  1.
it is easy to show that this theorem holds. the state of an lfsr is uniquely determined by the m internal register bits. given a certain state, the lfsr deterministically assumes its next state. because of this, as soon as an lfsr assumes a previous
state, it starts to repeat. since an m-bit state vector can only assume 2m  1 nonzero
states, the maximum sequence length before repetition is 2m  1. note that the allzero state must be excluded. if an lfsr assumes this state, it will get stuck in
it, i.e., it will never be able to leave it again. note that only certain configurations
(p0 , . . . , pm1 ) yield maximum length lfsrs. we give a small example for this below.
example 2.4. lfsr with maximum-length output sequence
given an lfsr of degree m  4 and the feedback path (p3  0, p2  0, p1 
1, p0  1), the output sequence of the lfsr has a period of 2m  1  15, i.e., it
is a maximum-length lfsr.

example 2.5. lfsr with non-maximum output sequence
given an lfsr of degree m  4 and (p3  1, p2  1, p1  1, p0  1), then the output
sequence has period of 5 therefore, it is not a maximum-length lfsr. 
the mathematical background of the properties of lfsr sequences is beyond
the scope of this book. however, we conclude this introduction to lfsrs with some
additional facts. lfsrs are often specified by polynomials using the following notation an lfsr with a feedback coefficient vector (pm1 , . . . , p1 , p0 ) is represented
by the polynomial
p(x)  xm + pm1 xm1 + . . . + p1 x + p0
for instance, the lfsr from the example above with coefficients (p3  0, p2 
0, p1  1, p0  1) can alternatively be specified by the polynomial x4 + x + 1.
this seemingly odd notation as a polynomial has several advantages. for instance,
maximum-length lfsrs have what is called primitive polynomials. primitive polynomials are a special type of irreducible polynomial. irreducible polynomials are
roughly comparable with prime numbers, i.e., their only factors are 1 and the
polynomial itself. primitive polynomials can relatively easily be computed. hence,
maximum-length lfsrs can easily be found. table 2.3 shows one primitive polynomial for every value of m in the range from m  2, 3, . . . , 128. as an example,

2.3 shift register-based stream ciphers

45

the notation (0, 2, 5) refers to the polynomial 1 + x2 + x5 . note that there are many
primitive polynomials for every given degree m. for instance, there exist 69,273,666
different primitive polynomials of degree m  31.
table 2.3 primitive polynomials for maximum-length lfsrs
(0,1,2)
(0,1,3)
(0,1,4)
(0,2,5)
(0,1,6)
(0,1,7)
(0,1,3,4,8)
(0,1,9)
(0,3,10)
(0,2,11)
(0,3,12)
(0,1,3,4,13)
(0,5,14)
(0,1,15)
(0,1,3,5,16)
(0,3,17)
(0,3,18)
(0,1,2,5,19)
(0,3,20)
(0,2,21)
(0,1,22)
(0,5,23)

(0,1,3,4,24)
(0,3,25)
(0,1,3,4,26)
(0,1,2,5,27)
(0,1,28)
(0,2,29)
(0,1,30)
(0,3,31)
(0,2,3,7,32)
(0,1,3,6,33)
(0,1,3,4,34)
(0,2,35)
(0,2,4,5,36)
(0,1,4,6,37)
(0,1,5,6,38)
(0,4,39)
(0,3,4,5,40)
(0,3,41)
(0,1,2,5,42)
(0,3,4,6,43)
(0,5,44)
(0,1,3,4,45)

(0,1,46)
(0,5,47)
(0,2,3,5,48)
(0,4,5,6,49)
(0,2,3,4,50)
(0,1,3,6,51)
(0,3,52)
(0,1,2,6,53)
(0,3,6,8,54)
(0,1,2,6,55)
(0,2,4,7,56)
(0,4,57)
(0,1,5,6,58)
(0,2,4,7,59)
(0,1,60)
(0,1,2,5,61)
(0,3,5,6,62)
(0,1,63)
(0,1,3,4,64)
(0,1,3,4,65)
(0,3,66)
(0,1,2,5,67)

(0,1,5,7,68)
(0,2,5,6,69)
(0,1,3,5,70)
(0,1,3,5,71)
(0,3,9,10,72)
(0,2,3,4,73)
(0,1,2,6,74)
(0,1,3,6,75)
(0,2,4,5,76)
(0,2,5,6,77)
(0,1,2,7,78)
(0,2,3,4,79)
(0,2,4,9,80)
(0,4,81)
(0,4,6,9,82)
(0,2,4,7,83)
(0,5,84)
(0,1,2,8,85)
(0,2,5,6,86)
(0,1,5,7,87)
(0,8,9,11,88)
(0,3,5,6,89)

(0,2,3,5,90)
(0,1,5,8,91)
(0,2,5,6,92)
(0,2,93)
(0,1,5,6,94)
(0,11,95)
(0,6,9,10,96)
(0,6,97)
(0,3,4,7,98)
(0,1,3,6,99)
(0,2,5,6,100)
(0,1,6,7,101)
(0,3,5,6,102)
(0,9,103)
(0,1,3,4,104)
(0,4,105)
(0,1,5,6,106)
(0,4,7,9,107)
(0,1,4,6,108)
(0,2,4,5,109)
(0,1,4,6,110)
(0,2,4,7,111)

(0,3,4,5,112)
(0,2,3,5,113)
(0,2,3,5,114)
(0,5,7,8,115)
(0,1,2,4,116)
(0,1,2,5,117)
(0,2,5,6,118)
(0,8,119)
(0,1,3,4,120)
(0,1,5,8,121)
(0,1,2,6,122)
(0,2,123)
(0,37,124)
(0,5,6,7,125)
(0,2,4,7,126)
(0,1,127)
(0,1,2,7,128)

2.3.2 known-plaintext attack against single lfsrs
as indicated by its name, lfsrs are linear. linear systems are governed by linear
relationships between their inputs and outputs. since linear dependencies can relatively easily be analyzed, this can be a major advantage, e.g., in communication systems. however, a cryptosystem where the key bits only occur in linear relationships
makes a highly insecure cipher. we will now investigate how the linear behavior of
a lfsr leads to a powerful attack.
if we use an lfsr as a stream cipher, the secret key k is the feedback coefficient
vector (pm1 , . . . , p1 , p0 ). an attack is possible if the attacker oscar knows some
plaintext and the corresponding ciphertext. we further assume that oscar knows the
degree m of the lfsr. the attack is so efficient that he can easily try a large number of possible m values, so that this assumption is not a major restriction. let the
known plaintext be given by x0 , x1 , . . . , x2m1 and the corresponding ciphertext by
y0 , y1 , . . . , y2m1 . with these 2m pairs of plaintext and ciphertext bits, oscar reconstructs the first 2m key stream bits
si  xi + yi mod 2

i  0, 1, . . . , 2m  1.

the goal is now to find the key which is given by the feedback coefficients pi .

46

2 stream ciphers

eq. (2.1) is a description of the relationship of the unknown key bits pi and the
key stream output. we repeat the equation here for convenience
si+m 

m1

 p j  si+ j mod

2

si , p j  {0, 1}

i  0, 1, 2, . . .

j0

note that we get a different equation for every value of i. moreover, the equations
are linearly independent. with this knowledge, oscar can generate m equations for
the first m values of i
i  0,
i  1,
..
.

sm
sm+1
..
.

 pm1 sm1 + . . . + p1 s1 + p0 s0
 pm1 sm + . . . + p1 s2 + p0 s1
.. ..
. .

mod 2
mod 2
..
.

(2.2)

i  m  1, s2m1  pm1 s2m2 + . . . + p1 sm + p0 sm1 mod 2
he has now m linear equations in m unknowns p0 , p1 , . . . , pm1 . this system can
easily be solved by oscar using gaussian elimination, matrix inversion or any other
algorithm for solving systems of linear equations. even for large values of m, this
can be done easily with a standard pc.
this situation has major consequences as soon as oscar knows 2m output bits
of an lfsr of degree m, the pi coefficients can exactly be constructed by merely
solving a system of linear equations. once he has computed these feedback coefficients, he can build the lfsr and load it with any m consecutive output bits
that he already knows. oscar can now clock the lfsr and produce the entire output
sequence. because of this powerful attack, lfsrs by themselves are extremely insecure they are a good example of a prng with good statistical properties but with
terrible cryptographical ones. nevertheless, all is not lost. there are many stream
ciphers which use combinations of several lfsrs to build strong cryptosystems.
the cipher trivium in the next section is an example.

2.3.3 trivium
trivium is a relatively new stream cipher which uses an 80-bit key. it is based on a
combination of three shift registers. even though these are feedback shift registers,
there are nonlinear components used to derive the output of each register, unlike the
lfsrs that we studied in the previous section.

description of trivium
as shown in fig. 2.8, at the heart of trivium are three shift registers, a, b and c.
the lengths of the registers are 93, 84 and 111, respectively. the xor-sum of all
three register outputs forms the key stream si . a specific feature of the cipher is that

2.3 shift register-based stream ciphers



47





  






  





fig. 2.8 internal structure of the stream cipher trivium

the output of each register is connected to the input of another register. thus, the
registers are arranged in circle-like fashion. the cipher can be viewed as consisting
of one circular register with a total length of 93 + 84 + 111  288. each of the three
registers has similar structure as described below.
the input of each register is computed as the xor-sum of two bits



the output bit of another register according to fig. 2.8. for instance, the output
of register a is part of the input of register b.
one register bit at a specific location is fed back to the input. the positions are
given in table 2.4. for instance, bit 68 of register a is fed back to its input.
the output of each register is computed as the xor-sum of three bits





the rightmost register bit.
one register bit at a specific location is fed forward to the output. the positions
are given in table 2.4. for instance, bit 66 of register a is fed to its output.
the output of a logical and function whose input is two specific register bits.
again, the positions of the and gate inputs are given in table 2.4.

table 2.4 specification of trivium
a
b
c

register length feedback bit feedforward bit and inputs
93
69
66
91, 92
84
78
69
82, 83
111
87
66
109, 110

note that the and operation is equal to multiplication in modulo 2 arithmetic.
if we multiply two unknowns, and the register contents are the unknowns that an attacker wants to recover, the resulting equations are no longer linear as they contain
products of two unknowns. thus, the feedforward paths involving the and operation are crucial for the security of trivium as they prevent attacks that exploit the

48

2 stream ciphers

linearity of the cipher, as the one applicable to plain lfsrs shown in the previous
section.

encryption with trivium
almost all modern stream ciphers have two input parameters a key k and an initialization vector iv . the former is the regular key that is used in every symmetric
crypto system. the iv serves as a randomizer and should take a new value for every
encryption session. it is important to note that the iv does not have to be kept secret,
it merely must change for every session. such values are often referred to as nonces,
which stands for number used once. its main purpose is that two key streams produced by the cipher should be different, even though the key has not changed. if this
were not the case, the following attack becomes possible. if an attacker has known
plaintext from a first encryption, he can compute the corresponding key stream. the
second encryption using the same key stream can now immediately be deciphered.
without a changing iv, stream cipher encryption is highly deterministic. methods
for generating ivs are discussed in sect. 5.1.2. lets look at the details of running
trivium
initialization initially, an 80-bit iv is loaded into the 80 leftmost locations of register a, and an 80-bit key is loaded in the 80 leftmost locations of register b. all
other register bits are set to zero with the exception of the three rightmost bits of
register c, i.e., bits c109 , c110 and c111 , which are set to 1.
warm-up phase in the first phase, the cipher is clocked 4  288  1152 times. no
cipher output is generated.
encryption phase the bits produced hereafter, i.e., starting with the output bit of
cycle 1153, form the key stream.
the warm-up phase is needed for randomizing the cipher sufficiently. it makes
sure that the key stream depends on both the key k and the iv .
an attractive feature of trivium is its compactness, especially if implemented
in hardware. it mainly consists of a 288-bit shift register and a few boolean operations. it is estimated that a hardware implementation of the cipher occupies and
area of between about 3500 and 5500 gate equivalences, depending on the degree
of parallelization. (a gate equivalence is the chip area occupied by a 2-input nand
gate.) for instance, an implementation with 4000 gates computes the key stream at
a rate of 16 bits/clock cycle. this is considerably smaller than most block ciphers
such as aes and is very fast. if we assume that this hardware design is clocked at a
moderate 125 mhz, the encryption rate would be 16bit  125mhz  2 gbit/sec. in
software, it is estimated that computing 8 output bits takes 12 cycles on a 1.5 ghz
intel cpu, resulting in a theoretical encryption rate of 1 gbit/sec.
even though there are no known attacks at the time of writing, one should keep
in mind that trivium is a relatively new cipher and attacks in the future are certainly

2.4 discussion and further reading

49

a possibility. in the past, many other stream ciphers were found to be not secure.
more information on trivium can be found in [164].

2.4 discussion and further reading
established stream ciphers even though many stream ciphers have been proposed over the years, there are considerably fewer well-investigated ones. the security of many proposed stream ciphers is unknown, and many stream ciphers have
been broken. in the case of software-oriented stream ciphers, arguably the bestinvestigated ones are rc4 [144] and seal [120, sect. 6.4.1]. note that there are
some known weaknesses in rc4, even though it is still secure in practice if it is used
correctly [142]. the seal cipher, on the other hand, is patented.
in the case of hardware-oriented ciphers, there is a wealth of lfsr-based algorithms. many proposed ciphers have been broken see references [8, 85] for an
introduction. among the best-studied ones are the a5/1 and a5/2 algorithms which
are used in gsm mobile networks for voice encryption between cell phones and
base stations. a5/1, which is the cipher used in most industrialized nations, had
originally been kept secret but was reverse-engineered and published on the internet
in 1998. the cipher is borderline secure today [22], whereas the weaker a5/2 has
much more serious flaws [11]. neither of the two ciphers is recommended based on
todays understanding of cryptanalysis. for 3gpp mobile communication, a different cipher a5/3 (also named kasumi) is used, but it is a block cipher.
this somewhat pessimistic outlook on the state-of-the-art in stream ciphers
changed with the estream project, described below.
estream project the estream project had the explicit goal to advance the
state-of-the-art knowledge about stream cipher design. as part of this objective,
new stream ciphers that might become suitable for widespread adoption were investigated. estream was organized by the european network of excellence in
cryptography (ecrypt). the call for stream ciphers was first issued in november
2004 and ended in 2008. the ciphers were divided into two profiles, depending
on the intended application



profile 1 stream ciphers for software applications with high throughput requirements.
profile 2 stream ciphers for hardware applications with restricted resources such
as limited storage, gate count, or power consumption.

some cryptographers had emphasized the importance of including an authentication
method, and hence two further profiles were also included to deal with ciphers that
also provide authentication.
a total of 34 candidates were submitted to estream. at the end of the project
four software-oriented (profile 1) ciphers were found to have desirable properties
hc-128, rabbit, salsa20/12 and sosemanuk. with respect to hardware-oriented
ciphers (profile 2), the following three ciphers were selected grain v1, mickey

50

2 stream ciphers

v2 and trivium. note that all of these are relatively new ciphers and only time
will tell whether they are really cryptographically strong. the algorithm description, source code and the results of the four-year evaluation process are available
online [69], and the official book provides more detailed information [146].
it is important to keep in mind that ecrypt is not a standardization body, so the
status of the estream finalist ciphers cannot be compared to that of aes at the
end of its selection process (cf. sect. 4.1).
true random number generation we introduced in this chapter different classes
of rngs, and found that cryptographically secure pseudorandom number generators are of central importance for stream ciphers. for other cryptographic applications, true random number generators are important. for instance, true random
numbers are needed for the generation of cryptographic keys which are then to be
distributed. many ciphers and modes of operation rely on initial values that are often generated from trngs. also, many protocols require nonces (numbers used
only once), which may stem from a trng. all trngs need to exploit some entropy source, i.e., some process which behaves truly randomly. many trng designs
have been proposed over the years. they can coarsely be classified as approaches
that use specially designed hardware as an entropy source or as trngs that exploit
external sources of randomness. examples of the former are circuits with random
behavior, e.g., that are based on semiconductor noise or on several uncorrelated oscillators. reference [104, chap. 5] contains a good survey. examples of the latter
ones are computer systems which measure the times between key strokes or the
arrival times of packets at a network interface. in all these cases, one has to be extremely careful to make sure that the noise source in fact has enough entropy. there
are many examples of trng designs which turned out to have poor random behavior and which constitute a serious security weakness, depending on how they are
used. there are tools available that test the statistical properties of trng output
sequences [56, 125]. there are also standards with which trngs can be formally
evaluated [80].

2.5 lessons learned





stream ciphers are less popular than block ciphers in most domains such as internet security. there are exceptions, for instance, the popular stream cipher rc4.
stream ciphers sometimes require fewer resources, e.g., code size or chip area,
for implementation than block ciphers, and they are attractive for use in constrained environments such as cell phones.
the requirements for a cryptographically secure pseudorandom number generator are far more demanding than the requirements for pseudorandom number
generators used in other applications such as testing or simulation.

2.5 lessons learned




51

the one-time pad is a provable secure symmetric cipher. however, it is highly
impractical for most applications because the key length has to equal the message
length.
single lfsrs make poor stream ciphers despite their good statistical properties.
however, careful combinations of several lfsr can yield strong ciphers.

52

2 stream ciphers

problems
2.1. the stream cipher described in definition 2.1.1 can easily be generalized to
work in alphabets other than the binary one. for manual encryption, an especially
useful one is a stream cipher that operates on letters.
1. develop a scheme which operates with the letters a, b,. . ., z, represented by the
numbers 0,1,. . .,25. what does the key (stream) look like what are the encryption and decryption functions
2. decrypt the following cipher text
bsaspp kkuosp
which was encrypted using the key
rsidpy dkawoa
3. how was the young man murdered
2.2. assume we store a one-time key on a cd-rom with a capacity of 1 gbyte.
discuss the real-life implications of a one-time-pad (otp) system. address issues
such as life cycle of the key, storage of the key during the life cycle/after the life
cycle, key distribution, generation of the key, etc.
2.3. assume an otp-like encryption with a short key of 128 bit. this key is then
being used periodically to encrypt large volumes of data. describe how an attack
works that breaks this scheme.
2.4. at first glance it seems as though an exhaustive key search is possible against
an otp system. given is a short message, lets say 5 ascii characters represented
by 40 bit, which was encrypted using a 40-bit otp. explain exactly why an exhaustive key search will not succeed even though sufficient computational resources are
available. this is a paradox since we know that the otp is unconditionally secure.
that is, explain why a brute-force attack does not work.
note you have to resolve the paradox that means answers such as the otp
is unconditionally secure and therefore a brute-force attack does not work are not
valid.
2.5. we will now analyze a pseudorandom number sequence generated by a lfsr
characterized by (c2  1, c1  0, c0  1).
1. what is the sequence generated from the initialization vector (s2  1, s1  0, s0 
0)
2. what is the sequence generated from the initialization vector (s2  0, s1  1, s0 
1)
3. how are the two sequences related
2.6. assume we have a stream cipher whose period is quite short. we happen to
know that the period is 150200 bit in length. we assume that we do not know
anything else about the internals of the stream cipher. in particular, we should not
assume that it is a simple lfsr. for simplicity, assume that english text in ascii
format is being encrypted.

problems

53

describe in detail how such a cipher can be attacked. specify exactly what oscar
has to know in terms of plaintext/ciphertext, and how he can decrypt all ciphertext.
2.7. compute the first two output bytes of the lfsr of degree 8 and the feedback
polynomial from table 2.3 where the initialization vector has the value ff in hexadecimal notation.
2.8. in this problem we will study lfsrs in somewhat more detail. lfsrs come in
three flavors





lfsrs which generate a maximum-length sequence. these lfsrs are based on
primitive polynomials.
lfsrs which do not generate a maximum-length sequence but whose sequence
length is independent of the initial value of the register. these lfsrs are based
on irreducible polynomials that are not primitive. note that all primitive polynomials are also irreducible.
lfsrs which do not generate a maximum-length sequence and whose sequence
length depends on the initial values of the register. these lfsrs are based on
reducible polynomials.

we will study examples in the following. determine all sequences generated by
1. x4 + x + 1
2. x4 + x2 + 1
3. x4 + x3 + x2 + x + 1
draw the corresponding lfsr for each of the three polynomials. which of the
polynomials is primitive, which is only irreducible, and which one is reducible
note that the lengths of all sequences generated by each of the lfsrs should add
up to 2m  1.
2.9. given is a stream cipher which uses a single lfsr as key stream generator. the
lfsr has a degree of 256.
1. how many plaintext/ciphertext bit pairs are needed to launch a successful attack
2. describe all steps of the attack in detail and develop the formulae that need to be
solved.
3. what is the key in this system why doesnt it make sense to use the initial
contents of the lfsr as the key or as part of the key
2.10. we conduct a known-plaintext attack on an lfsr-based stream cipher. we
know that the plaintext sent was
1001 0010 0110 1101 1001 0010 0110
by tapping the channel we observe the following stream
1011 1100 0011 0001 0010 1011 0001
1. what is the degree m of the key stream generator
2. what is the initialization vector
3. determine the feedback coefficients of the lfsr.

54

2 stream ciphers

4. draw a circuit diagram and verify the output sequence of the lfsr.
2.11. we want to perform an attack on another lfsr-based stream cipher. in order
to process letters, each of the 26 uppercase letters and the numbers 0, 1, 2, 3, 4, 5
are represented by a 5-bit vector according to the following mapping
a  0  000002
..
.
z  25  110012
0  26  110102
..
.
5  31  111112

we happen to know the following facts about the system



the degree of the lfsr is m  6.
every message starts with the header wpi.

we observe now on the channel the following message (the fourth letter is a
zero)
j5a0edj2b
1. what is the initialization vector
2. what are the feedback coefficients of the lfsr
3. write a program in your favorite programming language which generates the
whole sequence, and find the whole plaintext.
4. where does the thing after wpi live
5. what type of attack did we perform
2.12. assume the iv and the key of trivium each consist of 80 all-zero bits. compute the first 70 bits s1 , . . . , s70 during the warm-up phase of trivium. note that
these are only internal bits which are not used for encryption since the warm-up
phase lasts for 1152 clock cycles.

chapter 3

the data encryption standard (des) and
alternatives

the data encryption standard (des) has been by far the most popular block cipher for most of the last 30 years. even though it is nowadays not considered secure
against a determined attacker because the des key space is too small, it is still
used in legacy applications. furthermore, encrypting data three times in a row with
des  a process referred to as 3des or triple des  yields a very secure cipher
which is still widely used today (section 3.5 deals with 3des.) perhaps what is
more important, since des is by far the best-studied symmetric algorithm, its design principles have inspired many current ciphers. hence, studying des helps us
to understand many other symmetric algorithms.
in this chapter you will learn






the design process of des, which is very helpful for understanding the technical
and political evolution of modern cryptography
basic design ideas of block ciphers, including confusion and diffusion, which are
important properties of all modern block ciphers
the internal structure of des, including feistel networks, s-boxes and the key
schedule
security analysis of des
alternatives to des, including 3des

c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 3, 

55

56

3 the data encryption standard (des) and alternatives

3.1 introduction to des
in 1972 a mildly revolutionary act was performed by the us national bureau of
standards (nbs), which is now called national institute of standards and technology (nist) the nbs initiated a request for proposals for a standardized cipher
in the usa. the idea was to find a single secure cryptographic algorithm which
could be used for a variety of applications. up to this point in time governments had
always considered cryptography, and in particular cryptanalysis, so crucial for national security that it had to be kept secret. however, by the early 1970s the demand
for encryption for commercial applications such as banking had become so pressing
that it could not be ignored without economic consequences.
the nbs received the most promising candidate in 1974 from a team of cryptographers working at ibm. the algorithm ibm submitted was based on the cipher
lucifer. lucifer was a family of ciphers developed by horst feistel in the late 1960s,
and was one of the first instances of block ciphers operating on digital data. lucifer
is a feistel cipher which encrypts blocks of 64 bits using a key size of 128 bits.
in order to investigate the security of the submitted ciphers, the nbs requested the
help of the national security agency (nsa), which did not even admit its existence
at that point in time. it seems certain that the nsa influenced changes to the cipher,
which was rechristened des. one of the changes that occurred was that des is
specifically designed to withstand differential cryptanalysis, an attack not known to
the public until 1990. it is not clear whether the ibm team developed the knowledge about differential cryptanalysis by themselves or whether they were guided by
the nsa. allegedly, the nsa also convinced ibm to reduce the lucifer key length
of 128 bit to 56 bit, which made the cipher much more vulnerable to brute-force
attacks.
the nsa involvement worried some people because it was feared that a secret
trapdoor, i.e., a mathematical property with which des could be broken but which is
only known to nsa, might have been the real reason for the modifications. another
major complaint was the reduction of the key size. some people conjectured that
the nsa would be able to search through a key space of 256 , thus breaking it by
brute-force. in later decades, most of these concerns turned out to be unfounded.
section 3.5 provides more information about real and perceived security weaknesses
of des.
despite of all the criticism and concerns, in 1977 the nbs finally released all
specifications of the modified ibm cipher as the data encryption standard (fips
pub 46) to the public. even though the cipher is described down to the bit level in
the standard, the motivation for parts of the des design (the so-called design criteria), especially the choice of the substitution boxes, were never officially released.
with the rapid increase in personal computers in the early 1980s and all specifications of des being publicly available, it become easier to analyze the inner structure
of the cipher. during this period, the civilian cryptography research community also
grew and des underwent major scrutiny. however, no serious weaknesses were
found until 1990. originally, des was only standardized for 10 years, until 1987.
due to the wide use of des and the lack of security weaknesses, the nist reaf-

3.1 introduction to des

57

firmed the federal use of the cipher until 1999, when it was finally replaced by the
advanced encryption standard (aes).

3.1.1 confusion and diffusion
before we start with the details of des, it is instructive to look at primitive operations which can be applied in order to achieve strong encryption. according to
the famous information theorist claude shannon, there are two primitive operations
with which strong encryption algorithms can be built
1. confusion is an encryption operation where the relationship between key and
ciphertext is obscured. today, a common element for achieving confusion is substitution, which is found in both des and aes.
2. diffusion is an encryption operation where the influence of one plaintext symbol
is spread over many ciphertext symbols with the goal of hiding statistical properties of the plaintext. a simple diffusion element is the bit permutation, which is
used frequently within des. aes uses the more advanced mixcolumn operation.
ciphers which only perform confusion, such as the shift cipher (cf. sect. 1.4.3)
or the world war ii encryption machine enigma, are not secure. neither are ciphers which only perform diffusion. however, through the concatenation of such
operations, a strong cipher can be built. the idea of concatenating several encryption operation was also proposed by shannon. such ciphers are known as product
ciphers. all of todays block ciphers are product ciphers as they consist of rounds
which are applied repeatedly to the data (fig. 3.1).

 
  

 
  


 
  


fig. 3.1 principle of an n round product cipher, where each round performs a confusion and
diffusion operation

modern block ciphers possess excellent diffusion properties. on a cipher level
this means that changing of one bit of plaintext results on average in the change of

58

3 the data encryption standard (des) and alternatives

half the output bits, i.e., the second ciphertext looks statistically independent of the
first one. this is an important property to keep in mind when dealing with block
ciphers. we demonstrate this behavior with the following simple example.
example 3.1. lets assume a small block cipher with a block length of 8 bits. encryption of two plaintexts x1 and x2 , which differ only by one bit, should roughly
result in something as shown in fig. 3.2.
x1  0010 1011
x2  0000 1011

y1  1011 1001

block cipher

y2  0110 1100

fig. 3.2 principle of diffusion of a block cipher

note that modern block ciphers have block lengths of 64 or 128 bit but they show
exactly the same behavior if one input bit is flipped.


3.2 overview of the des algorithm
des is a cipher which encrypts blocks of length of 64 bits with a key of size of 56
bits (fig. 3.3).
x
64

des

56

k

64

y

fig. 3.3 des block cipher

des is a symmetric cipher, i.e., the same same key is used for encryption and
decryption. des is, like virtually all modern block ciphers, an iterative algorithm.
for each block of plaintext, encryption is handled in 16 rounds which all perform
the identical operation. figure 3.4 shows the round structure of des. in every round
a different subkey is used and all subkeys ki are derived from the main key k.
lets now have a more detailed view on the internals of des, as shown in
fig. 3.5.the structure in the figure is called a feistel network. it can lead to very
strong ciphers if carefully designed. feistel networks are used in many, but certainly not in all, modern block ciphers. (in fact, aes is not a feistel cipher.) in
addition to its potential cryptographic strength, one advantage of feistel networks is
that encryption and decryption are almost the same operation. decryption requires

3.2 overview of the des algorithm

59
x

initial
permutation
encryption
round 1

k

1

k

encryption
round 16

k 16

final
permutation

y

fig. 3.4 iterative structure of des

only a reversed key schedule, which is an advantage in software and hardware implementations. we discuss the feistel network in the following.
after the initial bitwise permutation ip of a 64-bit plaintext x, the plaintext is
split into two halves l0 and r0 . these two 32-bit halves are the input to the feistel
network, which consists of 16 rounds. the right half ri is fed into the function
f . the output of the f function is xored (as usually denoted by the symbol )
with the left 32-bit half li . finally, the right and left half are swapped. this process
repeats in the next round and can be expressed as
li  ri1 ,
ri  li1  f (ri1 , ki )
where i 1,. . . ,16. after round 16, the 32-bit halves l16 and r16 are swapped again,
and the final permutation ip1 is the last operation of des. as the notation suggests,
the final permutation ip1 is the inverse of the initial permutation ip. in each round,
a round key ki is derived from the main 56-bit key using what is called the key
schedule.
it is crucial to note that the feistel structure really only encrypts (decrypts) half
of the input bits per each round, namely the left half of the input. the right half
is copied to the next round unchanged. in particular, the right half is not encrypted
with the f function. in order to get a better understanding of the working of feistel
cipher, the following interpretation is helpful think of the f function as a pseudorandom generator with the two input parameters ri1 and ki . the output of the
pseudorandom generator is then used to encrypt the left half li1 with an xor operation. as we saw in chap. 2, if the output of the f function is not predictable for
an attacker, this results in a strong encryption method.

60

3 the data encryption standard (des) and alternatives
key k

plaintext x
64

64

pc1

initial permutation
ip(x)

56

l0

r0

32

32

48

transform 1
32

k1

f

32

56

l 15

r 15

32

32
32

round 16

...

r1

...

...

l1

...

round 1

48

transform 16

k 16

f

32

l 16

r 16

final permutation
ip 1( )

ciphertext
y  desk (x )

fig. 3.5 the feistel structure of des

the two aforementioned basic properties of ciphers, i.e., confusion and diffusion,
are realized within the f -function. in order to thwart advanced analytical attacks,
the f -function must be designed extremely carefully. once the f -function has been
designed securely, the security of a feistel cipher increases with the number of key
bits used and the number of rounds.
before we discuss all components of des in detail, here is an algebraic description of the feistel network for the mathematically inclined reader. the feistel structure of each round bijectively maps a block of 64 input bits to 64 output bits (i.e.,
every possible input is mapped uniquely to exactly one output, and vice versa). this
mapping remains bijective for some arbitrary function f , i.e., even if the embedded
function f is not bijective itself. in the case of des, the function f is in fact a sur-

3.3 internal structure of des

61

jective (many-to-one) mapping. it uses nonlinear building blocks and maps 32 input
bits to 32 output bits using a 48-bit round key ki , with 1  i  16.

3.3 internal structure of des
the structure of des as depicted in fig. 3.5 shows the internal functions which we
will discuss in this section. the building blocks are the initial and final permutation,
the actual des rounds with its core, the f -function, and the key schedule.

3.3.1 initial and final permutation
as shown in figs. 3.6 and 3.7, the initial permutation ip and the final permutation ip1 are bitwise permutations. a bitwise permutation can be viewed as simple
crosswiring. interestingly, permutations can be very easily implemented in hardware
but are not particularly fast in software. note that both permutations do not increase
the security of des at all. the exact rationale for the existence of these two permutations is not known, but it seems likely that their original purpose was to arrange
the plaintext, ciphertext and bits in a bytewise manner to make data fetches easier
for 8-bit data busses, which were the state-of-the-art register size in the early 1970s.
1

50

58

64

...

...

...

...

x

...

1 2

ip(x)

40

fig. 3.6 examples for the bit swaps of the initial permutation

1

2

40

...

...

...

...
1

50

z

...
58

ip1 (z)
64

fig. 3.7 examples for the bit swaps of the final permutation

the details of the transformation ip are given in fig. 3.8. this table, like all other
tables in this chapter, should be read from left to right, top to bottom. the table
indicates that input bit 58 is mapped to output position 1, input bit 50 is mapped to

62

3 the data encryption standard (des) and alternatives

the second output position, and so forth. the final permutation ip1 performs the
inverse operation of ip as shown in fig. 3.9.

58
60
62
64
57
59
61
63

50
52
54
56
49
51
53
55

42
44
46
48
41
43
45
47

ip
34 26
36 28
38 30
40 32
33 25
35 27
37 29
39 31

18
20
22
24
17
19
21
23

10
12
14
16
9
11
13
15

2
4
6
8
1
3
5
7

40
39
38
37
36
35
34
33

8
7
6
5
4
3
2
1

48
47
46
45
44
43
42
41

ip1
16 56
15 55
14 54
13 53
12 52
11 51
10 50
9 49

24
23
22
21
20
19
18
17

64
63
62
61
60
59
58
57

32
31
30
29
28
27
26
25

fig. 3.9 final permutation ip1

fig. 3.8 initial permutation ip

3.3.2 the f -function
as mentioned earlier, the f -function plays a crucial role for the security of des.
in round i it takes the right half ri1 of the output of the previous round and the
current round key ki as input. the output of the f -function is used as an xor-mask
for encrypting the left half input bits li1 .
r i1
32

expansion
e(r i1 )
48
48

ki
48

6

s1
4

6

s2
4

6

s3
4

6

s4

6

s5

4

4

32

permutation
p
32

fig. 3.10 block diagram of the f -function

6

s6
4

6

s7
4

6

s8
4

3.3 internal structure of des

63

the structure of the f -function is shown in fig. 3.10. first, the 32-bit input is expanded to 48 bits by partitioning the input into eight 4-bit blocks and by expanding
each block to 6 bits. this happens in the e-box, which is a special type of permutation. the first block consists of the bits (1, 2, 3, 4), the second one of (5, 6, 7, 8), etc.
the expansion to six bits can be seen in fig. 3.11.

1

2

1

2

3

4

5

6

7

8

9

3

4

5

6

7

8

9 10 11 12 13 14

32

...

...

47 48

fig. 3.11 examples for the bit swaps of the expansion function e

as can be seen from the table 3.1, exactly 16 of the 32 input bits appear twice in
the output. however, an input bit never appears twice in the same 6-bit output block.
the expansion box increases the diffusion behavior of des since certain input bits
influence two different output locations.
table 3.1 expansion permutation e
32
4
8
12
16
20
24
28

1
5
9
13
17
21
25
29

e
2 3
6 7
10 11
14 15
18 19
22 23
26 27
30 31

4
8
12
16
20
24
28
32

5
9
13
17
21
25
29
1

next, the 48-bit result of the expansion is xored with the round key ki , and
the eight 6-bit blocks are fed into eight different substition boxes, which are often
referred to as s-boxes. each s-box is a lookup table that maps a 6-bit input to a
4-bit output. larger tables would have been cryptographically better, but they also
become much larger eight 4-by-6 tables were probably close the maximum size
which could be fit on a single integrated circuit in 1974. each s-box contains 26  64
entries, which are typically represented by a table with 16 columns and 4 rows. each
entry is a 4-bit value. all s-boxes are listed in tables 3.2 to 3.9. note that all s-boxes
are different. the tables are to be read as indicated in fig. 3.12 the most significant
bit (msb) and the least significant bit (lsb) of each 6-bit input select the row of
the table, while the four inner bits select the column. the integers 0,1,. . . ,15 of each
entry in the table represent the decimal notation of a 4-bit value.

64

3 the data encryption standard (des) and alternatives

example 3.2. the s-box input b  (100101)2 indicates the row 112  3 (i.e., fourth
row, numbering starts with 002 ) and the column 00102  2 (i.e., the third column).
if the input b is fed into s-box 1, the output is s1 (37  1001012 )  8  10002 .
fourth row

1 1
1

0

0

1

0

1

third column

0010

fig. 3.12 example of the decoding of the input 1001012 by s-box 1



table 3.2 s-box s1
s1
0
1
2
3

0
14
00
04
15

1
04
15
01
12

2
13
07
14
08

3
01
04
08
02

4
02
14
13
04

5
15
02
06
09

6
11
13
02
01

7
08
01
11
07

8
03
10
15
05

9
10
06
12
11

10
06
12
09
03

11
12
11
07
14

12
05
09
03
10

13
09
05
10
00

14
00
03
05
06

15
07
08
00
13

s2
0
1
2
3

0
15
03
00
13

1
01
13
14
08

2
08
04
07
10

3
14
07
11
01

4
06
15
10
03

5
11
02
04
15

6
03
08
13
04

7
04
14
01
02

8
09
12
05
11

9
07
00
08
06

10
02
01
12
07

11
13
10
06
12

12
12
06
09
00

13
00
09
03
05

14
05
11
02
14

15
10
05
15
09

s3
0
1
2
3

0
10
13
13
01

1
00
07
06
10

2
09
00
04
13

3
14
09
09
00

4
06
03
08
06

5
03
04
15
09

6
15
06
03
08

7
05
10
00
07

8
01
02
11
04

9
13
08
01
15

10
12
05
02
14

11
07
14
12
03

12
11
12
05
11

13
04
11
10
05

14
02
15
14
02

15
08
01
07
12

table 3.3 s-box s2

table 3.4 s-box s3

the s-boxes are the core of des in terms of cryptographic strength. they are
the only nonlinear element in the algorithm and provide confusion. even though the
entire specification of des was released by nbs/nist in 1977, the motivation for
the choice of the s-box tables was never completely revealed. this often gave rise

3.3 internal structure of des

65

table 3.5 s-box s4
s4
0
1
2
3

0
07
13
10
03

1
13
08
06
15

2
14
11
09
00

3
03
05
00
06

4
00
06
12
10

5
06
15
11
01

6
09
00
07
13

7
10
03
13
08

8
01
04
15
09

9
02
07
01
04

10
08
02
03
05

11
05
12
14
11

12
11
01
05
12

13
12
10
02
07

14
04
14
08
02

15
15
09
04
14

s5
0
1
2
3

0
02
14
04
11

1
12
11
02
08

2
04
02
01
12

3
01
12
11
07

4
07
04
10
01

5
10
07
13
14

6
11
13
07
02

7
06
01
08
13

8
08
05
15
06

9
05
00
09
15

10
03
15
12
00

11
15
10
05
09

12
13
03
06
10

13
00
09
03
04

14
14
08
00
05

15
09
06
14
03

s6
0
1
2
3

0
12
10
09
04

1
01
15
14
03

2
10
04
15
02

3
15
02
05
12

4
09
07
02
09

5
02
12
08
05

6
06
09
12
15

7
08
05
03
10

8
00
06
07
11

9
13
01
00
14

10
03
13
04
01

11
04
14
10
07

12
14
00
01
06

13
07
11
13
00

14
05
03
11
08

15
11
08
06
13

s7
0
1
2
3

0
04
13
01
06

1
11
00
04
11

2
02
11
11
13

3
14
07
13
08

4
15
04
12
01

5
00
09
03
04

6
08
01
07
10

7
13
10
14
07

8
03
14
10
09

9
12
03
15
05

10
09
05
06
00

11
07
12
08
15

12
05
02
00
14

13
10
15
05
02

14
06
08
09
03

15
01
06
02
12

s8
0
1
2
3

0
13
01
07
02

1
02
15
11
01

2
08
13
04
14

3
04
08
01
07

4
06
10
09
04

5
15
03
12
10

6
11
07
14
08

7
01
04
02
13

8
10
12
00
15

9
09
05
06
12

10
03
06
10
09

11
14
11
13
00

12
05
00
15
03

13
00
14
03
05

14
12
09
05
06

15
07
02
08
11

table 3.6 s-box s5

table 3.7 s-box s6

table 3.8 s-box s7

table 3.9 s-box s8

to speculation, in particular with respect to the possible existence of a secret back
door or some other intentionally constructed weakness, which could be exploited by
the nsa. however, now we know that the s-boxes were designed according to the
criteria listed below.
1. each s-box has six input bits and four output bits.
2. no single output bit should be too close to a linear combination of the input bits.
3. if the lowest and the highest bits of the input are fixed and the four middle bits
are varied, each of the possible 4-bit output values must occur exactly once.
4. if two inputs to an s-box differ in exactly one bit, their outputs must differ in at
least two bits.

66

3 the data encryption standard (des) and alternatives

5. if two inputs to an s-box differ in the two middle bits, their outputs must differ
in at least two bits.
6. if two inputs to an s-box differ in their first two bits and are identical in their last
two bits, the two outputs must be different.
7. for any nonzero 6-bit difference between inputs, no more than 8 of the 32 pairs
of inputs exhibiting that difference may result in the same output difference.
8. a collision (zero output difference) at the 32-bit output of the eight s-boxes is
only possible for three adjacent s-boxes.
note that some of these design criteria were not revealed until the 1990s. more
information about the issue of the secrecy of the design criteria is found in sect. 3.5.
the s-boxes are the most crucial elements of des because they introduce a nonlinearity to the cipher, i.e.,
s(a)  s(b) 6 s(a  b).
without a nonlinear building block, an attacker could express the des input and
output with a system of linear equations where the key bits are the unknowns. such
systems can easily be solved, a fact that was used in the lfsr attack in sect. 2.3.2.
however, the s-boxes were carefully designed to also thwart advanced mathematical
attacks, in particular differential cryptanalysis. interestingly, differential cryptanalysis was first discovered in the research community in 1990. at this point, the ibm
team declared that the attack was known to the designers at least 16 years earlier,
and that des was especially designed to withstand differential cryptanalysis.
finally, the 32-bit output is permuted bitwise according to the p permutation,
which is given in table 3.10. unlike the initial permutation ip and its inverse ip1 ,
the permutation p introduces diffusion because the four output bits of each s-box
are permuted in such a way that they affect several different s-boxes in the following round. the diffusion caused by the expansion, s-boxes and the permutation p
guarantees that every bit at the end of the fifth round is a function of every plaintext
bit and every key bit. this behavior is known as the avalanche effect.
table 3.10 the permutation p within the f -function
16
1
2
19

7
15
8
13

20
23
24
30

p
21 29
26 5
14 32
6 22

12
18
27
11

28
31
3
4

17
10
9
25

3.3 internal structure of des

67

3.3.3 key schedule
the key schedule derives 16 round keys ki , each consisting of 48 bits, from the
original 56-bit key. another term for round key is subkey. first, note that the des
input key is often stated as 64-bit, where every eighth bit is used as an odd parity
bit over the preceding seven bits. it is not quite clear why des was specified that
way. in any case, the eight parity bits are not actual key bits and do not increase the
security. des is a 56-bit cipher, not a 64-bit one.
as shown in fig. 3.13, the 64-bit key is first reduced to 56 bits by ignoring every
eighth bit, i.e., the parity bits are stripped in the initial pc  1 permutation. again,
the parity bits certainly do not increase the key space the name pc  1 stands for
permuted choice one. the exact bit connections that are realized by pc  1 are
given in table 3.11.
lsb

msb

64
7

1

7

p

...

1

p

p  parity bit

fig. 3.13 location of the eight parity bits for a 64-bit input key

table 3.11 initial key permutation pc  1
57
58
59
60
31
30
29

49
50
51
52
23
22
21

41
42
43
44
15
14
13

pc  1
33 25 17
34 26 18
35 27 19
36 63 55
7 62 54
6 61 53
5 28 20

9
10
11
47
46
45
12

1
2
3
39
38
37
4

the resulting 56-bit key is split into two halves c0 and d0 , and the actual key
schedule starts as shown in fig. 3.14. the two 28-bit halves are cyclically shifted,
i.e., rotated, left by one or two bit positions depending on the round i according to
the following rules



in rounds i  1, 2, 9, 16, the two halves are rotated left by one bit.
in the other rounds where i  1, 2, 9, 16, the two halves are rotated left by two
bits.

note that the rotations only take place within either the left or the right half. the
total number of rotation positions is 4  1 + 12  2  28. this leads to the interesting
property that c0  c16 and d0  d16 . this is very useful for the decryption key

68

3 the data encryption standard (des) and alternatives

schedule where the subkeys have to be generated in reversed order, as we will see
in sect. 3.4.
k
64

pc  1
56

c0

d0
28

transform 1
ls 1

28

ls 1
28

k1

c1

pc  2
56

48

d1
28

28

...

ls 2

...

...

ls 2

ls 16

k 16

28

c 16

pc  2
48

ls 16

d 16

56

fig. 3.14 key schedule for des encryption

to derive the 48-bit round keys ki , the two halves are permuted bitwise again
with pc  2, which stands for permuted choice 2. pc  2 permutes the 56 input
bits coming from ci and di and ignores 8 of them. the exact bit-connections of
pc  2 are given in table 3.12.
table 3.12 round key permutation pc  2
14
15
26
41
51
34

17
6
8
52
45
53

11
21
16
31
33
46

pc  2
24 1 5
10 23 19
7 27 20
37 47 55
48 44 49
42 50 36

3
12
13
30
39
29

28
4
2
40
56
32

3.4 decryption

69

note that every round key is a selection of 48 permuted bits of the input key k.
the key schedule is merely a method of realizing the 16 permutations systematically. especially in hardware, the key schedule is very easy to implement. the key
schedule is also designed so that each of the 56 key bits is used in different round
keys each bit is used in approximately 14 of the 16 round keys.

3.4 decryption
one advantage of des is that decryption is essentially the same function as encryption. this is because des is based on a feistel network. figure 3.15 shows a
block diagram for des decryption. compared to encryption, only the key schedule
is reversed, i.e., in decryption round 1, subkey 16 is needed in round 2, subkey 15
etc. thus, when in decryption mode, the key schedule algorithm has to generate the
round keys as the sequence k16 , k15 , . . . , k1 .

reversed key schedule
the first question that we have to clarify is how, given the initial des key k, can we
easily generate k16  note that we saw above that c0  c16 and d0  d16 . hence k16
can be directly derived after pc  1.
k16  pc  2(c16 , d16 )
 pc  2(c0 , d0 )
 pc  2(pc  1(k))
to compute k15 we need the intermediate variables c15 and d15 , which can be derived from c16 , d16 through cyclic right shifts (rs)
k15  pc  2(c15 , d15 )
 pc  2(rs2 (c16 ), rs2 (d16 ))
 pc  2(rs2 (c0 ), rs2 (d0 ))
the subsequent round keys k14 , k13 , . . . , k1 are derived via right shifts in a similar
fashion. the number of bits shifted right for each round key in decryption mode




in decryption round 1, the key is not rotated.
in decryption rounds 2, 9, and 16 the two halves are rotated right by one bit.
in the other rounds 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14 and 15 the two halves are
rotated right by two bits.
figure 3.16 shows the reversed key schedule for decryption.

70

3 the data encryption standard (des) and alternatives
ciphertext
y  desk (x )

key k

pc1

initial permutation
ip(x)

56

l d0

r d0

32

32

48

transform 16
32

round 1

k 16

f

32

56

l d1

r d1

d

d

r 15

l 15
32

32

48

transform 1
32

round 16

k1

f

32

d

l 16

d

r 16

final permutation
ip 1( )

message
x  des1
k (y )

fig. 3.15 des decryption

decryption in feistel networks
we have not addressed the core question why is the decryption function essentially
the same as the encryption function the basic idea is that the decryption function
reverses the des encryption in a round-by-round manner. that means that decryption round 1 reverses encryption round 16, decryption round 2 reverses encryption
round 15, and so on. lets first look at the initial stage of decryption by looking at
fig. 3.15. note that the right and left halves are swapped in the last round of des
(l0d , rd0 )  ip(y )  ip(ip1 (r16 , l16 ))  (r16 , l16 )
and thus
l0d  r16
rd0  l16  r15

3.4 decryption

71
k
64

pc  1
56

k 16

c 16

pc  2
48

d 16

56
28

transform 1
rs 1

28

rs 1
28

c 15

pc  2
48

56

d 15
28

rs 2

...

...

rs 2

rs 15

k1

rs 15

c1

pc  2
48

28

...

k 15

28

d1

56

fig. 3.16 reversed key schedule for decryption of des

note that all variables in the decryption routine are marked with the superscript
d, whereas the encryption variables do not have superscripts. the derived equation
simply says that the input of the first round of decryption is the output of the last
round of encryption because final and initial permutations cancel each other out. we
will now show that the first decryption round reverses the last encryption round. for
this, we have to express the output values (l1d , rd1 ) of the first decryption round 1
in terms of the input values of the last encryption round (l15 , r15 ) . the first one is
easy
l1d  rd0  l16  r15
we now look at how rd1 is computed
rd1  l0d  f (rd0 , k16 )  r16  f (l16 , k16 )
rd1  [l15  f (r15 , k16 )]  f (r15 , k16 )
rd1  l15  [ f (r15 , k16 )  f (r15 , k16 )]  l15
the crucial step is shown in the last equation above an identical output of the
f -function is xored twice to l15 . these operations cancel each other out, so that

72

3 the data encryption standard (des) and alternatives

rd1  l15 . hence, after the first decryption round, we in fact have computed the same
values we had before the last encryption round. thus, the first decryption round
reverses the last encryption round. this is an iterative process which continues in
the next 15 decryption rounds and that can be expressed as
lid  r16i ,
rdi  l16i
where i  0, 1, . . . , 16. in particular, after the last decryption round
d
l16
 r1616  r0
d
r16  l0

finally, at the end of the decryption process, we have to reverse the initial permutation
d
)  ip1 (l0 , r0 )  ip1 (ip(x))  x
ip1 (rd16 , l16
where x is the plaintext that was the input to the des encryption.

3.5 security of des
as we discussed in sect. 1.2.2, ciphers can be attacked in several ways. with respect
to cryptographic attacks, we distinguish between exhaustive key search or bruteforce attacks, and analytical attacks. the latter was demonstrated with the lfsr
attack in sect. 2.3.2, where we could easily break a stream cipher by solving a
system of linear equations. shortly after des was proposed, two major criticisms
against the cryptographic strength of des centered around two arguments
1. the key space is too small, i.e., the algorithm is vulnerable against brute-force
attacks.
2. the design criteria of the s-boxes was kept secret and there might have existed an
analytical attack that exploits mathematical properties of the s-boxes, but which
is only known to the des designers.
we discuss both types of attacks below. however, we also state the main conclusion about des security already here despite very intensive cryptanalysis over
the lifetime of des, current analytical attacks are not very efficient. however, des
can relatively easily be broken with an exhaustive key-search attack and, thus, plain
des is not suited for most applications any more.

3.5 security of des

73

3.5.1 exhaustive key search
the first criticism is nowadays certainly justified. the original cipher proposed by
ibm had a key length of 128 bits and it is suspicious that it was reduced to 56 bits.
the official statement that a cipher with a shorter key length made it easier to implement the des algorithm on a single chip in 1974 does not sound too convincing.
for clarification, lets recall the principle of an exhaustive key search (or brute-force
attack)

definition 3.5.1 des exhaustive key search
input at least one pair of plaintextciphertext (x, y)
output k, such that y  desk (x)
attack test all 256 possible keys until the following condition is
fulfilled
desk1
(y)  x , i  0, 1, . . . , 256  1.
i


note that there is a small chance of 1/216 that an incorrect key is found, i.e., a key
k which decrypts only the one ciphertext y correctly but not subsequent ciphertexts.
if one wants to rule out this possibility, an attacker must check such a key candidate
with a second plaintextciphertext pair. more about this is found in sect. 5.2.
regular computers are not particularly well suited to perform the 256 key tests
necessary, but special-purpose key-search machines are an option. it seems highly
likely that large (government) institutions have long been able to build such bruteforce crackers, which can break des in a matter of days. in 1977, whitfield diffie
and martin hellman [59] estimated that it was possible to build an exhaustive keysearch machine for approximately 20,000,000. even though they later stated that
their cost estimate had been too optimistic, it was clear from the beginning that a
cracker could be built with sufficient funding.
at the rump session of the crypto 1993 conference, michael wiener proposed
the design of a very efficient key-search machine which used pipelining techniques.
an update of his proposal can be found in [174]. he estimated the cost of his design at approximately 1,000,000, and the time required to find the key at 1.5 days.
this was a proposal only, and the machine was not built. in 1998, however, the eff
(electronic frontier foundation) built the hardware machine deep crack, which
performed a brute-force attack against des in 56 hours. figure 3.17 shows a photo
of deep crack. the machine consisted of 1800 integrated circuits, where each had
24 key-test units. the average search time of deep crack was 15 days, and the machine was built for less than 250,000. the successful break with deep crack was
considered the official demonstration that des is no longer secure against determined attacks by many people. please note that this break does not imply that a
weak algorithm had been in use for more than 20 years. it was only possible to build
deep crack at such a relatively low price because digital hardware had become

74

3 the data encryption standard (des) and alternatives

cheap. in the 1980s it would have been impossible to build a des cracker without spending many millions of dollars. it can be speculated that only government
agencies were willing to spend such an amount of money for code breaking.

fig. 3.17 deep crack  the hardware exhaustive key-search machine that broke des in 1998
(reproduced with permission from paul kocher)

des brute-force attacks also provide an excellent case study for the continuing
decrease in hardware costs. in 2006, the copacobana (cost-optimized parallel
code-breaker) machine was built based on commercial integrated circuits by a team
of researchers from the universities of bochum and kiel in germany (the authors of
this book were heavily involved in this effort). copacobana allows one to break
des with an average search time of less than 7 days. the interesting part of this
undertaking is that the machine could be built with hardware costs in the 10,000
range. figure 3.18 shows a picture of copacobana.

fig. 3.18 copacobana  a cost-optimized parallel code breaker

in summary, a key size of 56 bits is too short to encrypt confidential data nowadays. hence, single des should only be used for applications where only short-term
security is needed  say, a few hours  or where the value of the encrypted data is
very low. however, variants of des, in particular 3des, are still secure.

3.6 implementation in software and hardware

75

3.5.2 analytical attacks
as was shown in the first chapter, analytical attacks can be very powerful. since
the introduction of des in the mid-1970s, many excellent researchers in academia
(and without doubt many excellent researchers in intelligence agencies) tried to find
weaknesses in the structure of des which allowed them to break the cipher. it is
a major triumph for the designers of des that no weakness was found until 1990.
in this year, eli biham and adi shamir discovered what is called differential cryptanalysis (dc). this is a powerful attack which is in principle applicable to any block
cipher. however, it turned out that the des s-boxes are particularly resistant against
this attack. in fact, one member of the original ibm design team declared after the
discovery of dc that they had been aware of the attack at the time of design. allegedly, the reason why the s-box design criteria were not made public was that the
design team did not want to make such a powerful attack public. if this claim is true
 and all circumstances support it  it means that the ibm and nsa team was
15 years ahead of the research community. it should be noted, however, that in the
1970s and 1980s relatively few people did active research in cryptography.
in 1993 a related but distinct analytical attack was published by mitsuru matsui,
which was named linear cryptanalysis (lc). similar to differential cryptanalysis,
the effectiveness of this attack also heavily depends on the structure of the s-boxes.
what is the practical relevance of these two analytical attacks against des it
turns out that an attacker needs 247 plaintextciphertext pairs for a successful dc
attack. this assumes particularly chosen plaintext blocks for random plaintext 255
pairs are needed in the case of lc, an attacker needs 243 plaintextciphertext pairs.
all these numbers seem highly impractical for several reasons. first, an attacker
needs to know an extremely large number of plaintexts, i.e., pieces of data which
are supposedly encrypted and thus hidden from the attacker. second, collecting and
storing such an amount of data takes a long time and requires considerable memory
resources. third, the attack only recovers one key. (this is actually one of many
arguments for introducing key freshness in cryptographic applications.) as a result
of all these arguments, it does not seem likely that des can be broken with either
dc or lc in real-world systems. however, both dc and lc are very powerful
attacks which are applicable to many other block ciphers. table 3.13 provides an
overview of proposed and realized attacks against des over the last three decades.
some entries refer to what is known as the des challenges. starting in 1997, several
des-breaking challenges were organized by the company rsa security.

3.6 implementation in software and hardware
in the following, we provide a brief assessment of des implementation properties in
software and hardware. when we talk about software, we refer to des implementations running on desktop cpus or embedded microprocessors like smart cards

76

3 the data encryption standard (des) and alternatives

table 3.13 history of full-round des attacks
date
1977
1990
1993
1993
jun. 1997
feb. 1998
jul. 1998

jan. 1999
apr. 2006

proposed or implemented attacks
w. diffie and m. hellman propose cost estimate for key-search machine
e. biham and a. shamir propose differential cryptanalysis, which requires 247
chosen plaintexts
m. wiener proposes detailed hardware design for key-search machine with an
average search time of 36 h and estimated cost of 1,000,000
m. matsui proposes linear cryptanalysis, which requires 243 chosen ciphertexts
des challenge i broken through brute-force distributed effort on the internet
took 4.5 months
des challenge ii1 broken through brute-force distributed effort on the internet took 39 days
des challenge ii2 broken through brute-force electronic frontier foundation built the deep crack key-search machine for about 250,000. the attack
took 56 h (15 days average)
des challenge iii broken through brute-force by distributed internet effort
combined with deep crack and a total search time of 22 hours
universities of bochum and kiel built copacobana key-search machine
based on low-cost fpgas for approximately 10,000. average search time is
7 days

or cell phones. hardware refers to des implementations running on ics such as
application-specific integrated circuits (asics) or field programmable gate arrays
(fpgas).

software
a straightforward software implementation which follows the data flow of most
des descriptions, such as the one presented in this chapter, results in a very poor
performance. this is due to the fact that many of the atomic des operations involve
bit permutation, in particular the e and p permutation, which are slow in software.
similarly, small s-boxes such as used in des are efficient in hardware but only moderately efficient on modern cpus. there have been numerous methods proposed for
accelerating des software implementations. the general idea is to use tables with
precomputed values of several des operations, e.g., of several s-boxes and the permutation. optimized implementations require about 240 cycles for encrypting one
block on a 32-bit cpu. on a 2-ghz cpu this translates into a theoretical throughput
of about 533 mbits/s. 3des, which is considerably more secure than single des,
runs at almost exactly 1/3 of the des speed. note that nonoptimized implementations are considerably slower, often below 100 mbit/s.
a notable method for accelerating software implementations of des is bitslicing, developed by eli biham [20]. on a 300-mhz dec alpha workstation an
encryption rate of 137 mbit/sec has been reported, which was much faster than a
standard des implementation at that time. the limitation of bit-slicing, however, is
that several blocks are encrypted in parallel, which can be a drawback for certain

3.7 des alternatives

77

modes of operation such as cipher block chaining (cbc) and output feedback
(ofb) mode (cf. chap. 5).

hardware
one design criterion for des was its efficiency in hardware. permutations such as
the e, p, ip and ip1 permutations are very easy to implement in hardware, as
they only require wiring but no logic. the small 6-by-4 s-boxes are also relatively
easily realizable in hardware. typically, they are implemented with boolean logic,
i.e., logic gates. on average, one s-box requires about 100 gates.
an area-efficient implementation of a single des round can be done with less
than 3000 gates. if a high throughput is desired, des can be implemented extremely
fast by fitting multiple rounds in one circuit, e.g., by using pipelining. on modern
asics and fpgas throughput rates of several 100 gbit/sec are possible. on the
other end of the performance spectrum, very small implementations with fewer than
3000 gates even fit onto lowcost radio frequency identification (rfid) chips.

3.7 des alternatives
there exist a wealth of other block ciphers. even though there are many ciphers
which have security weaknesses or which are not well investigated, there are also
many block ciphers which appear very strong. in the following a brief list of ciphers
is given which can be of interest depending on the application needs.

3.7.1 the advanced encryption standard (aes) and the aes
finalist ciphers
by now, the algorithm of choice for many, many applications has become the advanced encryption standard (aes), which will be introduced in detail in the following chapter. aes is with its three key lengths of 128, 192 and 256 bit secure against
brute-force attacks for several decades, and there are no analytical attacks with any
reasonable chance of success known.
aes was the result of an open competition, and in the last stage of the selection
process there were four other finalist algorithms. these are the block ciphers mars,
rc6, serpent and twofish. all of them are cryptographically strong and quite fast,
especially in software. based on todays knowledge, they can all be recommended.
mars, serpent and twofish can be used royalty-free.

78

3 the data encryption standard (des) and alternatives

3.7.2 triple des (3des) and desx
an alternative to aes or the aes finalist algorithms is triple des, often denoted as
3des. 3des consists of three subsequent des encryptions
y  desk3 (desk2 (desk1 (x)))
with different keys, as shown in fig. 3.19.

x

des

des

des

k1

k2

k3

y

fig. 3.19 triple des (3des)

3des seems resistant to both brute-force attacks and any analytical attack imaginable at the moment. see chap. 5 for more information on double and triple encryption. another version of 3des is
y  desk3 (desk1
(desk1 (x))).
2
the advantage here is that 3des performs single des encryption if k3  k2  k1 ,
which is sometimes desired in implementations that should also support single des
for legacy reasons. 3des is very efficient in hardware but not particularly in software. it is popular in financial applications as well as for protecting biometric information in electronic passports.
a different approach for strengthening des is to use key whitening. for this, two
additional 64-bit keys k1 and k2 are xored to the plaintext and ciphertext, respectively, prior to and after the des algorithm. this yields the following encryption
scheme
y  desk,k1 ,k2 (x)  desk (x  k1 )  k2
this surprisingly simple modification makes des much more resistant against exhaustive key searches. more about key whitening is said in sect. 5.3.3.

3.7.3 lightweight cipher present
over the last few years, several new block algorithms which are classified as
lightweight ciphers have been proposed. lightweight commonly refers to algorithms with a very low implementation complexity, especially in hardware. trivium
(sect. 2.3.3) is an example of a lightweight stream cipher. a promising block cipher
candidate is present, which was designed specifically for applications such as

3.7 des alternatives

79

rfid tags or other pervasive computing applications that are extremely power or
cost constrained. (one of the book authors participated in the design of present.)
  



 
 

 

"""

"""

   

    
  
 

    

 
 

 


 

fig. 3.20 internal structure and pseudocode of the block cipher present

unlike des, present is not based on a feistel network. instead it is a
substitution-permutation network (sp-network) and consists of 31 rounds. the
block length is 64 bits, and two key lengths of 80 and 128 bits are supported.
each of the 31 rounds consists of an xor operation to introduce a round key ki
for 1  i  32, where k32 is used after round 31, a nonlinear substitution layer
(sboxlayer) and a linear bitwise permutation (player). the nonlinear layer uses a
single 4-bit s-box s, which is applied 16 times in parallel in each round. the key
schedule generates 32 round keys from the user supplied key. the encryption routine of the cipher is described in pseudocode in fig. 3.20, and each stage is now
specified in turn.
addroundkey at the beginning of each round, the round key ki is xored to the
current state.
sboxlayer present uses a single 4-bit to 4-bit s-box. this is a direct consequence of the pursuit of hardware efficiency, since such an s-box allows a much
more compact implementation than, e.g., an 8-bit s-box. the s-box entries in hexadecimal notation are given in table 3.14.
table 3.14 the present s-box in hexadecimal notation
x
0 1 2 3 4 5 6 7 8 9 a b c d e f
s[x] c 5 6 b 9 0 a d 3 e f 8 4 7 1 2

the 64 bit data path b63 . . . b0 is referred to as state. for the sboxlayer the current state is considered as sixteen 4-bit words w15 . . . w0 , where wi  b4i+3 b4i+2 
b4i+1 b4i for 0  i  15, and the output are the 16 words s[wi ].

80

3 the data encryption standard (des) and alternatives

player just like des, the mixing layer was chosen as a bit permutation, which
can be implemented extremely compactly in hardware. the bit permutation used in
present is given by table 3.15. bit i of state is moved to bit position p(i).
table 3.15 the permutation layer of present
i
p(i)

0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
0 16 32 48 1 17 33 49 2 18 34 50 3 19 35 51

i
16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
p(i) 4 20 36 52 5 21 37 53 6 22 38 54 7 23 39 55
i
32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
p(i) 8 24 40 56 9 25 41 57 10 26 42 58 11 27 43 59
i
48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63
p(i) 12 28 44 60 13 29 45 61 14 30 46 62 15 31 47 63

the bit permutation is quite regular and can in fact be expressed in the following
way

i  16 mod 63, i  {0, . . . , 62}
p(i) 
63,
i  63.
key schedule we describe in the following the key schedule for present with
an 80-bit key. since the main applications of present are low-cost systems, this
key length is in most cases appropriate. (details of the key schedule for present128 can be found in [29].) the user-supplied key is stored in a key register k and
is represented as k79 k78 . . . k0 . at round i the 64-bit round key ki  63 62 . . . 0
consists of the 64 leftmost bits of the current contents of register k. thus at round i
we have
ki  63 62 . . . 0  k79 k78 . . . k16
the first subkey k1 is a direct copy of 64 bit of the user supplied key. for the following subkeys k2 , . . . , k32 the key register k  k79 k78 . . . k0 is updated as follows
1. [k79 k78 . . . k1 k0 ]  [k18 k17 . . . k20 k19 ]
2. [k79 k78 k77 k76 ]  s[k79 k78 k77 k76 ]
3. [k19 k18 k17 k16 k15 ]  [k19 k18 k17 k16 k15 ]  roundcounter
thus, the key schedule consists of three operations (1) the key register is rotated by 61 bit positions to the left, (2) the leftmost four bits are passed through
the present s-box, and (3) the roundcounter value i is xored with bits
k19 k18 k17 k16 k15 of k, where the least significant bit of roundcounter is on
the right. this counter is a simple integer which takes the values (00001, 00010, . . .
, 11111). note that for the derivation of k2 the counter value 00001 is used for k3 ,
the counter value 00010 and so on.
implementation as a result of the aggressively hardware-optimized design of
present, its software performance is not very competitive relative to modern ciphers like aes. an optimized software implementation on a pentium iii cpu in

3.8 discussion and further reading

81

c achieves a throughput of about 60 mbit/s at a frequency of 1 ghz. however, it
performs quite well on small microprocessors, which are common in inexpensive
consumer products.
present-80 can be implemented in hardware with area requirements of approximately 1600 gate equivalences [147], where the encryption of one 64-bit plaintext block requires 32 clock cycles. as an example, at a clock rate of 1 mhz, which
is quite typical on low-cost devices, a throughput of 2 mbit/s is achieved, which is
sufficient for most such applications. it is possible to realize the cipher with as few
as approximately 1000 gate equivalences, where the encryption of one 64-bit plaintext requires 547 clock cycles. a fully pipelined implementation of present with
31 encryption stages achieves a throughput of 64 bit per clock cycle, which can be
tranlsated into encryption throughputs of more than 50 gbit/s.
even though no attacks against present are known at the time of writing, it
should be noted that it is a relatively new block cipher.

3.8 discussion and further reading
des history and attacks even though plain des (i.e., non-3des) is today
mainly used in legacy applications, its history helps us understand the evolution
of cryptography since the mid-1970s from an obscure discipline almost solely studied in government organizations towards an open discipline with many players in
industry and academia. a summary of the des history can be found in [165]. the
two main analytical attacks developed against des, differential and linear cryptanalysis, are today among the most powerful general methods for breaking block
ciphers. readers interested in the theory of block ciphers are encouraged to study
these attacks. good descriptions are given in [21, 114].
as we have seen in this chapter, des should no longer be used since a brute-force
attack can be accomplished at low cost in little time with cryptanalytical hardware.
the two machines built outside governments, deep crack and copacobana, are
instructive examples of how to build low-cost supercomputers for very narrowly
defined computational tasks. more information about deep crack can be found on
the internet [78] and about copacobana in the articles [105, 88] and online
at [47]. readers interested in the fascinating area of cryptanalytical computers in
general should take a look at the sharcs (special-purpose hardware for attacking
cryptographic systems) workshop series, which started in 2005 and has information
online [170].
des alternatives it should be noted that hundreds of block ciphers have been
proposed over the last three decades, especially in the late 1980s and in the 1990s.
des has influenced the design of many other encryption algorithms. it is probably
fair to say that the majority of todays successful block ciphers have borrowed ideas
from des. some of the popular block ciphers are also based on feistel networks
as is des. examples of feistel ciphers include blowfish, cast, kasumi, mars,

82

3 the data encryption standard (des) and alternatives

misty1, twofish and rc6. one cipher which is well known and markedly different
from des is idea it uses arithmetic in three different algebraic structures as atomic
operations.
des is a good example of a block cipher which is very efficient in hardware. the
recent advent of pervasive computing has created a need for extremely small ciphers
for applications such as rfid tags or low-cost smart cards, e.g., for high-volume
public transportation payment tickets. good references for present are [29, 147].
in addition to present, other recently proposed very small block ciphers include
clefia [48], hight [93] and mcrypton [111]. a good overview of the new field of
lightweight cryptography is given in the surveys [71, 98]. a more in-depth treatment
of lightweight algorithms can be found in the ph.d. dissertation [135].
implementation with respect to software implementation of des, an early reference is [20]. more advanced techniques are described in [106]. the powerful method
of bit-slicing is applicable not only to des but to most other ciphers.
regarding des hardware implementation, an early but still very interesting reference is [169]. there are many descriptions of high-performance implementations
of des on a variety of hardware platforms, including fpgas [163], standard asics
as well as more exotic semiconductor technology [67].

3.9 lessons learned









des was the dominant symmetric encryption algorithm from the mid-1970s to
the mid-1990s. since 56-bit keys are no longer secure, the advanced encryption
standard (aes) was created.
standard des with 56-bit key length can be broken relatively easily nowadays
through an exhaustive key search.
des is quite robust against known analytical attacks in practice it is very difficult to break the cipher with differential or linear cryptanalysis.
des is reasonably efficient in software and very fast and small in hardware.
by encrypting with des three times in a row, triple des (3des) is created,
against which no practical attack is currently known.
the default symmetric cipher is nowadays often aes. in addition, the other
four aes finalist ciphers all seem very secure and efficient.
since about 2005 several proposals for lightweight ciphers have been made. they
are suited for resource-constrained applications.

problems

83

problems
3.1. as stated in sect. 3.5.2, one important property which makes des secure is that
the s-boxes are nonlinear. in this problem we verify this property by computing the
output of s1 for several pairs of inputs.
show that s1 (x1 )  s1 (x2 )  s1 (x1  x2 ), where  denotes bitwise xor, for
1. x1  000000, x2  000001
2. x1  111111, x2  100000
3. x1  101010, x2  010101
3.2. we want to verify that ip() and ip1 () are truly inverse operations. we consider a vector x  (x1 , x2 , . . . , x64 ) of 64 bit. show that ip1 (ip(x))  x for the first
five bits of x, i.e. for xi , i  1, 2, 3, 4, 5.
3.3. what is the output of the first round of the des algorithm when the plaintext
and the key are both all zeros
3.4. what is the output of the first round of the des algorithm when the plaintext
and the key are both all ones
3.5. remember that it is desirable for good block ciphers that a change in one input
bit affects many output bits, a property that is called diffusion or the avalanche
effect. we try now to get a feeling for the avalanche property of des. we apply an
input word that has a 1 at bit position 57 and all other bits as well as the key are
zero. (note that the input word has to run through the initial permutation.)
1. how many s-boxes get different inputs compared to the case when an all-zero
plaintext is provided
2. what is the minimum number of output bits of the s-boxes that will change
according to the s-box design criteria
3. what is the output after the first round
4. how many output bit after the first round have actually changed compared to
the case when the plaintext is all zero (observe that we only consider a single
round here. there will be more and more output differences after every new
round. hence the term avalanche effect.)
3.6. an avalanche effect is also desirable for the key a one-bit change in a key
should result in a dramatically different ciphertext if the plaintext is unchanged.
1. assume an encryption with a given key. now assume the key bit at position 1
(prior to pc  1) is being flipped. which s-boxes in which rounds are affected
by the bit flip during des encryption
2. which s-boxes in which des rounds are affected by this bit flip during des
decryption
3.7. a des key kw is called a weak key if encryption and decryption are identical
operations
(3.1)
deskw (x)  des1
kw (x), for all x

84

3 the data encryption standard (des) and alternatives

1. describe the relationship of the subkeys in the encryption and decryption algorithm that is required so that eq. (3.1) is fulfilled.
2. there are four weak des keys. what are they
3. what is the likelihood that a randomly selected key is weak
3.8. des has a somewhat surprising property related to bitwise complements of its
inputs and outputs. we investigate the property in this problem.
we denote the bitwise complement of a number a (that is, all bits are flipped) by
a . let  denote bitwise xor. we want to show that if
y  desk (x)
then
y  desk (x ).

(3.2)

this states that if we complement the plaintext and the key, then the ciphertext
output will also be the complement of the original ciphertext. your task is to prove
this property.
try to prove this property using the following steps
1. show that for any bit strings a, b of equal length,
a b  ab
and
a  b  (a  b) .
(these two operations are needed for some of the following steps.)
2. show that pc  1(k )  (pc  1(k)) .
3. show that lsi (ci1 )  (lsi (ci1 )) .
4. using the two results from above, show that if ki are the keys generated from k,
then ki are the keys generated from k , where i  1, 2, . . . , 16.
5. show that ip(x )  (ip(x)) .
6. show that e(ri )  (e(ri )) .
7. using all previous results, show that if ri1 , li1 , ki generate ri , then ri1 , li1 , ki
generate ri .
8. show that eq. (3.2) is true.
3.9. assume we perform a known-plaintext attack against des with one pair of
plaintext and ciphertext. how many keys do we have to test in a worst-case scenario if we apply an exhaustive key search in a straightforward way how many on
average
3.10. in this problem we want to study the clock frequency requirements for a hardware implementation of des in real-world applications. the speed of a des implementation is mainly determined by the time required to do one core iteration.
this hardware kernel is then used 16 consecutive times in order to generate the encrypted output. (an alternative approach would be to build a hardware pipeline with
16 stages, resulting in 16-fold increased hardware costs.)

problems

85

1. lets assume that one core iteration can be performed in one clock cycle. develop an expression for the required clock frequency for encrypting a stream of
data with a data rate r [bit/sec]. ignore the time needed for the initial and final
permutation.
2. what clock frequency is required for encrypting a fast network link running at a
speed of 1 gb/sec what is the clock frequency if we want to support a speed of
8 gb/sec
3.11. as the example of copacobana [105] shows, key-search machines need
not be prohibitive from a monetary point of view. we now consider a simple bruteforce attack on des which runs on copacobana.
1. compute the runtime of an average exhaustive key-search on des assuming the
following implementational details






copacobana platform with 20 fpga modules
6 fpgas per fpga module
4 des engines per fpga
each des engine is fully pipelined and is capable of performing one encryption per clock cycle
100 mhz clock frequency

2. how many copacobana machines do we need in the case of an average
search time of one hour
3. why does any design of a key-search machine constitute only an upper security
threshold by upper security threshold we mean a (complexity) measure which
describes the maximum security that is provided by a given cryptographic algorithm.
3.12. we study a real-world case in this problem. a commercial file encryption
program from the early 1990s used standard des with 56 key bits. in those days,
performing an exhaustive key search was considerably harder than nowadays, and
thus the key length was sufficient for some applications. unfortunately, the implementation of the key generation was flawed, which we are going to analyze. assume
that we can test 106 keys per second on a conventional pc.
the key is generated from a password consisting of 8 characters. the key is a
simple concatenation of the 8 ascii characters, yielding 64  8  8 key bits. with
the permutation pc  1 in the key schedule, the least significant bit (lsb) of each
8-bit character is ignored, yielding 56 key bits.
1. what is the size of the key space if all 8 characters are randomly chosen 8-bit
ascii characters how long does an average key search take with a single pc
2. how many key bits are used, if the 8 characters are randomly chosen 7-bit ascii
characters (i.e., the most significant bit is always zero) how long does an average key search take with a single pc
3. how large is the key space if, in addition to the restriction in part 2, only letters are used as characters. furthermore, unfortunately, all letters are converted

86

3 the data encryption standard (des) and alternatives

to capital letters before generating the key in the software. how long does an
average key search take with a single pc
3.13. this problem deals with the lightweight cipher present.
1. calculate the state of present-80 after the execution of one round. you can use
the following table to solve this problem with paper and pencil. use the following
values (in hexadecimal notation)
plaintext  0000 0000 0000 0000,
key  bbbb 5555 5555 eeee ffff.
plaintext

0000 0000 0000 0000

round key
state after keyadd
state after s-layer
state after p-layer
2. now calculate the round key for the second round using the following table.
key
key state after rotation
key state after s-box
key state after counteradd
round key for round 2

bbbb 5555 5555 eeee ffff

chapter 4

the advanced encryption standard (aes)

the advanced encryption standard (aes) is the most widely used symmetric cipher
today. even though the term standard in its name only refers to us government
applications, the aes block cipher is also mandatory in several industry standards
and is used in many commercial systems. among the commercial standards that
include aes are the internet security standard ipsec, tls, the wi-fi encryption
standard ieee 802.11i, the secure shell network protocol ssh (secure shell), the
internet phone skype and numerous security products around the world. to date,
there are no attacks better than brute-force known against aes.
in this chapter you will learn







the design process of the us symmetric encryption standard, aes
the encryption and decryption function of aes
the internal structure of aes, namely
 byte substitution layer
 diffusion layer
 key addition layer
 key schedule
basic facts about galois fields
efficiency of aes implementations

c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 4, 

87

88

4 the advanced encryption standard (aes)

4.1 introduction
in 1999 the us national institute of standards and technology (nist) indicated
that des should only be used for legacy systems and instead triple des (3des)
should be used. even though 3des resists brute-force attacks with todays technology, there are several problems with it. first, it is not very efficient with regard to
software implementations. des is already not particularly well suited for software
and 3des is three times slower than des. another disadvantage is the relatively
short block size of 64 bits, which is a drawback in certain applications, e.g., if one
wants to built a hash function from a block cipher (cf. sect. 11.3.2). finally, if one
is worried about attacks with quantum computers, which might become reality in a
few decades, key lengths on the order of 256 bits are desirable. all these consideration led nist to the conclusion that an entirely new block cipher was needed as a
replacement for des.
in 1997 nist called for proposals for a new advanced encryption standard
(aes). unlike the des development, the selection of the algorithm for aes was
an open process administered by nist. in three subsequent aes evaluation rounds,
nist and the international scientific community discussed the advantages and disadvantages of the submitted ciphers and narrowed down the number of potential
candidates. in 2001, nist declared the block cipher rijndael as the new aes and
published it as a final standard (fips pub 197). rijndael was designed by two
young belgian cryptographers.
within the call for proposals, the following requirements for all aes candidate
submissions were mandatory





block cipher with 128 bit block size
three key lengths must be supported 128, 192 and 256 bit
security relative to other submitted algorithms
efficiency in software and hardware

the invitation for submitting suitable algorithms and the subsequent evaluation
of the successor of des was a public process. a compact chronology of the aes
selection process is given here





the need for a new block cipher was announced on january 2, 1997, by nist.
a formal call for aes was announced on september 12, 1997.
fifteen candidate algorithms were submitted by researchers from several countries by august 20, 1998.
on august 9, 1999, five finalist algorithms were announced






mars by ibm corporation
rc6 by rsa laboratories
rijndael, by joan daemen and vincent rijmen
serpent, by ross anderson, eli biham and lars knudsen
twofish, by bruce schneier, john kelsey, doug whiting, david wagner, chris
hall and niels ferguson

4.2 overview of the aes algorithm



89

on october 2, 2000, nist announced that it had chosen rijndael as the aes.
on november 26, 2001, aes was formally approved as a us federal standard.

it is expected that aes will be the dominant symmetric-key algorithm for many
commercial applications for the next few decades. it is also remarkable that in 2003
the us national security agency (nsa) announced that it allows aes to encrypt
classified documents up to the level secret for all key lengths, and up to the top
secret level for key lengths of either 192 or 256 bits. prior to that date, only
non-public algorithms had been used for the encryption of classified documents.

4.2 overview of the aes algorithm
the aes cipher is almost identical to the block cipher rijndael. the rijndael block
and key size vary between 128, 192 and 256 bits. however, the aes standard only
calls for a block size of 128 bits. hence, only rijndael with a block length of 128
bits is known as the aes algorithm. in the remainder of this chapter, we only discuss
the standard version of rijndael with a block length of 128 bits.

x
128

aes

128/192/256

k

128

y
fig. 4.1 aes input/output parameters

as mentioned previously, three key lengths must be supported by rijndael as this
was an nist design requirement. the number of internal rounds of the cipher is a
function of the key length according to table 4.1.
table 4.1 key lengths and number of rounds for aes
key lengths  rounds  nr
128 bit
10
192 bit
12
256 bit
14

in contrast to des, aes does not have a feistel structure. feistel networks do
not encrypt an entire block per iteration, e.g., in des, 64/2  32 bits are encrypted

90

4 the advanced encryption standard (aes)

in one round. aes, on the other hand, encrypts all 128 bits in one iteration. this is
one reason why it has a comparably small number of rounds.
aes consists of so-called layers. each layer manipulates all 128 bits of the data
path. the data path is also referred to as the state of the algorithm. there are only
three different types of layers. each round, with the exception of the first, consists
of all three layers as shown in fig. 4.2 the plaintext is denoted as x, the ciphertext
as y and the number of rounds as nr . moreover, the last round nr does not make
use of the mixcolumn transformation, which makes the encryption and decryption
scheme symmetric.
we continue with a brief description of the layers
key addition layer a 128-bit round key, or subkey, which has been derived from
the main key in the key schedule, is xored to the state.
byte substitution layer (s-box) each element of the state is nonlinearly transformed using lookup tables with special mathematical properties. this introduces
confusion to the data, i.e., it assures that changes in individual state bits propagate
quickly across the data path.
diffusion layer it provides diffusion over all state bits. it consists of two sublayers,
both of which perform linear operations



the shiftrows layer permutes the data on a byte level.
the mixcolumn layer is a matrix operation which combines (mixes) blocks of
four bytes.

similar to des, the key schedule computes round keys, or subkeys, (k0 , k1 , . . . , knr )
from the original aes key.
before we describe the internal functions of the layers in sect. 4.4, we have to
introduce a new mathematical concept, namely galois fields. galois field computations are needed for all operations within the aes layers.

4.3 some mathematics a brief introduction to galois fields
in aes, galois field arithmetic is used in most layers, especially in the s-box and
the mixcolumn layer. hence, for a deeper understanding of the internals of aes, we
provide an introduction to galois fields as needed for this purpose before we continue with the algorithm in sect. 4.4. a background on galois fields is not required
for a basic understanding of aes, and the reader can skip this section.

4.3.1 existence of finite fields
a finite field, sometimes also called galois field, is a set with a finite number of
elements. roughly speaking, a galois field is a finite set of elements in which we

4.3 some mathematics a brief introduction to galois fields
plaintext

key k

x

key addition layer

91

k0

transform 0

byte substitution layer

shiftrows layer

round 1

diffusion layer
mixcolumn layer

key addition layer

k1

transform 1

byte substitution layer

shiftrows layer

round nr 1
mixcolumn layer

key addition layer

k n r 1
transform n r 1

byte substitution layer
last round n r

shiftrows layer
key addition layer

k nr
transform n r

ciphertext

yaes(x)

fig. 4.2 aes encryption block diagram

can add, subtract, multiply and invert. before we introduce the definition of a field,
we first need the concept of a a simpler algebraic structure, a group.

92

4 the advanced encryption standard (aes)

definition 4.3.1 group
a group is a set of elements g together with an operation  which
combines two elements of g. a group has the following properties
1. the group operation  is closed. that is, for all a, b,  g, it holds
that a  b  c  g.
2. the group operation is associative. that is, a(bc)  (ab)c
for all a, b, c  g.
3. there is an element 1  g, called the neutral element (or identity
element), such that a  1  1  a  a for all a  g.
4. for each a  g there exists an element a1  g, called the inverse of a, such that a  a1  a1  a  1.
5. a group g is abelian (or commutative) if, furthermore, a  b 
b  a for all a, b  g.
roughly speaking, a group is set with one operation and the corresponding inverse operation. if the operation is called addition, the inverse operation is subtraction if the operation is multiplication, the inverse operation is division (or multiplication with the inverse element).
example 4.1. the set of integers zm  {0, 1, . . . , m  1} and the operation addition
modulo m form a group with the neutral element 0. every element a has an inverse
a such that a + (a)  0 mod m. note that this set does not form a group with the
operation multiplication because most elements a do not have an inverse such that
a a1  1 mod m.

in order to have all four basic arithmetic operations (i.e., addition, subtraction,
multiplication, division) in one structure, we need a set which contains an additive
and a multiplicative group. this is what we call a field.
definition 4.3.2 field
a field f is a set of elements with the following properties




all elements of f form an additive group with the group operation + and the neutral element 0.
all elements of f except 0 form a multiplicative group with the
group operation  and the neutral element 1.
when the two group operations are mixed, the distributivity law
holds, i.e., for all a, b, c  f a(b + c)  (ab) + (ac).

example 4.2. the set r of real numbers is a field with the neutral element 0 for the
additive group and the neutral element 1 for the multiplicative group. every real
number a has an additive inverse, namely a, and every nonzero element a has a
multiplicative inverse 1/a.

4.3 some mathematics a brief introduction to galois fields

93


in cryptography, we are almost always interested in fields with a finite number of
elements, which we call finite fields or galois fields. the number of elements in the
field is called the order or cardinality of the field. of fundamental importance is the
following theorem
theorem 4.3.1 a field with order m only exists if m is a prime
power, i.e., m  pn , for some positive integer n and prime integer
p. p is called the characteristic of the finite field.
this theorem implies that there are, for instance, finite fields with 11 elements,
or with 81 elements (since 81  34 ) or with 256 elements (since 256  28 , and 2 is
a prime). however, there is no finite field with 12 elements since 12  22  3, and
12 is thus not a prime power. in the remainder of this section we look at how finite
fields can be built, and more importantly for our purpose, how we can do arithmetic
in them.

4.3.2 prime fields
the most intuitive examples of finite fields are fields of prime order, i.e., fields with
n  1. elements of the field gf(p) can be represented by integers 0, 1, . . . , p1. the
two operations of the field are modular integer addition and integer multiplication
modulo p.
theorem 4.3.2 let p be a prime. the integer ring z p is denoted
as gf(p) and is referred to as a prime field, or as a galois field
with a prime number of elements. all nonzero elements of gf(p)
have an inverse. arithmetic in gf(p) is done modulo p.
this means that if we consider the integer ring zm which was introduced in
sect. 1.4.2, i.e., integers with modular addition and multiplication, and m happens
to be a prime, zm is not only a ring but also a finite field.
in order to do arithmetic in a prime field, we have to follow the rules for integer
rings addition and multiplication are done modulo p, the additive inverse of any
element a is given by a + (a)  0 mod p, and the multiplicative inverse of any
nonzero element a is defined as a  a1  1. lets have a look at an example of a
prime field.
example 4.3. we consider the finite field gf(5)  {0, 1, 2, 3, 4}. the tables below
describe how to add and multiply any two elements, as well as the additive and

94

4 the advanced encryption standard (aes)
addition
+
0
1
2
3
4

0
0
1
2
3
4

1
1
2
3
4
0

2
2
3
4
0
1

additive inverse
3
3
4
0
1
2

4
4
0
1
2
3

0  0
1  4
2  3
3  2
4  1

multiplication

multiplicative inverse


0
1
2
3
4

01 does not exist
11  1
21  3
31  2
41  4

0
0
0
0
0
0

1
0
1
2
3
4

2
0
2
4
1
3

3
0
3
1
4
2

4
0
4
3
2
1

multiplicative inverse of the field elements. using these tables, we can perform all
calculations in this field without using modular reduction explicitly.

a very important prime field is gf(2), which is the smallest finite field that
exists. lets have a look at the multiplication and addition tables for the field.
example 4.4. lets consider the small finite field gf(2)  {0, 1}. arithmetic is simply done modulo 2, yielding the following arithmetic tables
addition
+ 01
0 01
1 10

multiplication
 01
0 00
1 01


as we saw in chap. 2 on stream ciphers, gf(2) addition, i.e., modulo 2 addition,
is equivalent to an xor gate. what we learn from the example above is that gf(2)
multiplication is equivalent to the logical and gate. the field gf(2) is important
for aes.

4.3.3 extension fields gf(2m )
in aes the finite field contains 256 elements and is denoted as gf(28 ). this field
was chosen because each of the field elements can be represented by one byte. for
the s-box and mixcolumn transforms, aes treats every byte of the internal data

4.3 some mathematics a brief introduction to galois fields

95

path as an element of the field gf(28 ) and manipulates the data by performing
arithmetic in this finite field.
however, if the order of a finite field is not prime, and 28 is clearly not a prime,
the addition and multiplication operation cannot be represented by addition and multiplication of integers modulo 28 . such fields with m  1 are called extension fields.
in order to deal with extension fields we need (1) a different notation for field elements and (2) different rules for performing arithmetic with the elements. we will
see in the following that elements of extension fields can be represented as polynomials, and that computation in the extension field is achieved by performing a
certain type of polynomial arithmetic.
in extension fields gf(2m ) elements are not represented as integers but as polynomials with coefficients in gf(2). the polynomials have a maximum degree of
m  1, so that there are m coefficients in total for every element. in the field gf(28 ),
which is used in aes, each element a  gf(28 ) is thus represented as
a(x)  a7 x7 +    + a1 x + a0 , ai  gf(2)  {0, 1}.
note that there are exactly 256  28 such polynomials. the set of these 256 polynomials is the finite field gf(28 ). it is also important to observe that every polynomial
can simply be stored in digital form as an 8-bit vector
a  (a7 , a6 , a5 , a4 , a3 , a2 , a1 , a0 ).
in particular, we do not have to store the factors x7 , x6 , etc. it is clear from the bit
positions to which power xi each coefficient belongs.

4.3.4 addition and subtraction in gf(2m )
lets now look at addition and subtraction in extension fields. the key addition layer
of aes uses addition. it turns out that these operations are straightforward. they are
simply achieved by performing standard polynomial addition and subtraction we
merely add or subtract coefficients with equal powers of x. the coefficient additions
or subtractions are done in the underlying field gf(2).

96

4 the advanced encryption standard (aes)

definition 4.3.3 extension field addition and subtraction
let a(x), b(x)  gf(2m ). the sum of the two elements is then computed according to
m1

c(x)  a(x) + b(x) 

 ci xi ,

ci  ai + bi mod 2

i0

and the difference is computed according to
c(x)  a(x)  b(x) 

m1

 ci xi ,

ci  ai  bi  ai + bi mod 2.

i0

note that we perform modulo 2 addition (or subtraction) with the coefficients. as
we saw in chap. 2, addition and subtraction modulo 2 are the same operation. moreover, addition modulo 2 is equal to bitwise xor. lets have a look at an example in
the field gf(28 ) which is used in aes
example 4.5. here is how the sum c(x)  a(x)+b(x) of two elements from gf(28 )
is computed
a(x)  x7 + x6 + x4 +
1
b(x) 
x4 + x2 + 1
c(x)  x7 + x6 +
x2

note that if we computed the difference of the two polynomials a(x)  b(x) from
the example above, we would get the same result as for the sum.

4.3.5 multiplication in gf(2m )
multiplication in gf(28 ) is the core operation of the mixcolumn transformation of
aes. in a first step, two elements (represented by their polynomials) of a finite field
gf(2m ) are multiplied using the standard polynomial multiplication rule
a(x)  b(x)  (am1 xm1 +    + a0 )  (bm1 xm1 +    + b0 )
c (x)  c2m2 x2m2 +    + c0 ,
where
c0  a0 b0 mod 2
c1  a0 b1 + a1 b0 mod 2
..
.
c2m2  am1 bm1 mod 2.

4.3 some mathematics a brief introduction to galois fields

97

note that all coefficients ai , bi and ci are elements of gf(2), and that coefficient arithmetic is performed in gf(2). in general, the product polynomial c(x)
will have a degree higher than m  1 and has to be reduced. the basic idea is an approach similar to the case of multiplication in prime fields in gf(p), we multiply
the two integers, divide the result by a prime, and consider only the remainder. here
is what we are doing in extension fields the product of the multiplication is divided
by a certain polynomial, and we consider only the remainder after the polynomial
division. we need irreducible polynomials for the module reduction. we recall from
sect. 2.3.1 that irreducible polynomials are roughly comparable to prime numbers,
i.e., their only factors are 1 and the polynomial itself.
definition 4.3.4 extension field multiplication
let a(x), b(x)  gf(2m ) and let
m

p(x)   pi xi , pi  gf(2)
i0

be an irreducible polynomial. multiplication of the two elements
a(x), b(x) is performed as
c(x)  a(x)  b(x) mod p(x).
thus, every field gf(2m ) requires an irreducible polynomial p(x) of degree m
with coefficients from gf(2). note that not all polynomials are irreducible. for
example, the polynomial x4 + x3 + x + 1 is reducible since
x4 + x3 + x + 1  (x2 + x + 1)(x2 + 1)
and hence cannot be used to construct the extension field gf(24 ). since primitive
polynomials are a special type of irreducible polynomial, the polynomials in table 2.3 can be used for constructing fields gf(2m ). for aes, the irreducible polynomial
p(x)  x8 + x4 + x3 + x + 1
is used. it is part of the aes specification.
example 4.6. we want to multiply the two polynomials a(x)  x3 + x2 + 1 and
b(x)  x2 + x in the field gf(24 ). the irreducible polynomial of this galois field is
given as
p(x)  x4 + x + 1.
the plain polynomial product is computed as
c (x)  a(x)  b(x)  x5 + x3 + x2 + x.
we can now reduce c (x) using the polynomial division method we learned in
school. however, sometimes it is easier to reduce each of the leading terms x4 and

98

4 the advanced encryption standard (aes)

x5 individually
x4  1  p(x) + (x + 1)
x4  x + 1 mod p(x)
x5  x2 + x mod p(x).
now, we only have to insert the reduced expression for x5 into the intermediate
result c (x)
c(x)  x5 + x3 + x2 + x mod p(x)
c(x)  (x2 + x) + (x3 + x2 + x)  x3
a(x)  b(x)  x3 .

it is important not to confuse multiplication in gf(2m ) with integer multiplication, especially if we are concerned with software implementations of galois fields.
recall that the polynomials, i.e., the field elements, are normally stored as bit vectors in the computers. if we look at the multiplication from the previous example,
the following very atypical operation is being performed on the bit level
a

b

c
x3
(x3 + x2 + 1)  (x2 + x) 
(1 1 0 1)  (0 1 1 0)  (1 0 0 0).
this computation is not identical to integer arithmetic. if the polynomials are interpreted as integers, i.e., (1101)2  1310 and (0110)2  610 , the result would have
been (1001110)2  7810 , which is clearly not the same as the galois field multiplication product. hence, even though we can represent field elements as integers data
types, we cannot make use of the integer arithmetic provided

4.3.6 inversion in gf(2m )
inversion in gf(28 ) is the core operation of the byte substitution transformation,
which contains the aes s-boxes. for a given finite field gf(2m ) and the corresponding irreducible reduction polynomial p(x), the inverse a1 of a nonzero element a  gf(2m ) is defined as
a1 (x)  a(x)  1 mod p(x).
for small fields  in practice this often means fields with 216 or fewer elements
 lookup tables which contain the precomputed inverses of all field elements are
often used. table 4.2 shows the values which are used within the s-box of aes.
the table contains all inverses in gf(28 ) modulo p(x)  x8 + x4 + x3 + x + 1 in
hexadecimal notation. a special case is the entry for the field element 0, for which

4.4 internal structure of aes

99

an inverse does not exist. however, for the aes s-box, a substitution table is needed
that is defined for every possible input value. hence, the designers defined the s-box
such that the input value 0 is mapped to the output value 0.
table 4.2 multiplicative inverse table in gf(28 ) for bytes xy used within the aes s-box

y

x

0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f

0
00
74
3a
2c
1d
ed
16
79
83
de
fb
0c
0b
7a
b1
5b

1
01
b4
6e
45
fe
5c
5e
b7
7e
6a
7c
e0
28
07
0d
23

2
8d
aa
5a
92
37
05
af
97
7f
32
2e
1f
2f
ae
d6
38

3
f6
4b
f1
6c
67
ca
d3
85
80
6d
c3
ef
a3
63
eb
34

4
cb
99
55
f3
2d
4c
49
10
96
d8
8f
11
da
c5
c6
68

5
52
2b
4d
39
31
24
a6
b5
73
8a
b8
75
d4
db
0e
46

6
7b
60
a8
66
f5
87
36
ba
be
84
65
78
e4
e2
cf
03

7
d1
5f
c9
42
69
bf
43
3c
56
72
48
71
0f
ea
ad
8c

8
e8
58
c1
f2
a7
18
f4
b6
9b
2a
26
a5
a9
94
08
dd

9
4f
3f
0a
35
64
3e
47
70
9e
14
c8
8e
27
8b
4e
9c

a
29
fd
98
20
ab
22
91
d0
95
9f
12
76
53
c4
d7
7d

b
c0
cc
15
6f
13
f0
df
06
d9
88
4a
3d
04
d5
e3
a0

c
b0
ff
30
77
54
51
33
a1
f7
f9
ce
bd
1b
9d
5d
cd

d
e1
40
44
bb
25
ec
93
fa
02
dc
e7
bc
fc
f8
50
1a

e
e5
ee
a2
59
e9
61
21
81
b9
89
d2
86
ac
90
1e
41

f
c7
b2
c2
19
09
17
3b
82
a4
9a
62
57
e6
6b
b3
1c

example 4.7. from table 4.2 the inverse of
x7 + x6 + x  (1100 0010)2  (c2)hex  (xy)
is given by the element in row c, column 2
(2f)hex  (0010 1111)2  x5 + x3 + x2 + x + 1.
this can be verified by multiplication
(x7 + x6 + x)  (x5 + x3 + x2 + x + 1)  1 mod p(x).

note that the table above does not contain the s-box itself, which is a bit more
complex and will be described in sect. 4.4.1.
as an alternative to using lookup tables, one can also explicitly compute inverses.
the main algorithm for computing multiplicative inverses is the extended euclidean
algorithm, which is introduced in sect. 6.3.1.

4.4 internal structure of aes
in the following, we examine the internal structure of aes. figure 4.3 shows the
graph of a single aes round. the 16-byte input a0 , . . . , a15 is fed byte-wise into the

100

4 the advanced encryption standard (aes)

s-box. the 16-byte output b0 , . . . , b15 is permuted byte-wise in the shiftrows layer
and mixed by the mixcolumn transformation c(x). finally, the 128-bit subkey ki is
xored with the intermediate result. we note that aes is a byte-oriented cipher.

byte substitution

a0 a1 a2 a3

a4 a5 a6 a7

a8 a9 a10 a11

a12 a13 a14 a15

s s s s

s s s s

s s s s

s s s s

b0 b1 b2 b3

b4 b5 b6 b7

b8 b9 b10 b11

b12 b13 b14 b15

c0 c1 c2 c3

c4 c5 c6 c7

c8 c9 c10 c11

c12 c13 c14 c15

shiftrows

mixcolumn

ki

key addition

fig. 4.3 aes round function for rounds 1, 2, . . . , nr  1

this is in contrast to des, which makes heavy use of bit permutation and can thus
be considered to have a bit-oriented structure.
in order to understand how the data moves through aes, we first imagine that the
state a (i.e., the 128-bit data path) consisting of 16 bytes a0 , a1 , . . . , a15 is arranged
in a four-by-four byte matrix
a0
a1
a2
a3

a4
a5
a6
a7

a8
a9
a10
a11

a12
a13
a14
a15

as we will see in the following, aes operates on elements, columns or rows of
the current state matrix. similarly, the key bytes are arranged into a matrix with four
rows and four (128-bit key), six (192-bit key) or eight (256-bit key) columns. here
is, as an example, the state matrix of a 192-bit key

4.4 internal structure of aes

101

k0
k1
k2
k3

k4
k5
k6
k7

k8
k9
k10
k11

k12
k13
k14
k15

k16
k17
k18
k19

k20
k21
k22
k23

we discuss now what happens in each of the layers.

4.4.1 byte substitution layer
as shown in fig. 4.3, the first layer in each round is the byte substitution layer. the
byte substitution layer can be viewed as a row of 16 parallel s-boxes, each with
8 input and output bits. note that all 16 s-boxes are identical, unlike des where
eight different s-boxes are used. in the layer, each state byte ai is replaced, i.e.,
substituted, by another byte bi 
s(ai )  bi .
the s-box is the only nonlinear element of aes, i.e., it holds that bytesub(a) +
bytesub(b) 6 bytesub(a + b) for two states a and b. the s-box substitution is a
bijective mapping, i.e., each of the 28  256 possible input elements is one-to-one
mapped to one output element. this allows us to uniquely reverse the s-box, which
is needed for decryption. in software implementations the s-box is usually realized
as a 256-by-8 bit lookup table with fixed entries, as given in table 4.3.
table 4.3 aes s-box substitution values in hexadecimal notation for input byte (xy)

x

0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f

0
63
ca
b7
04
09
53
d0
51
cd
60
e0
e7
ba
70
e1
8c

1
7c
82
fd
c7
83
d1
ef
a3
0c
81
32
c8
78
3e
f8
a1

2
77
c9
93
23
2c
00
aa
40
13
4f
3a
37
25
b5
98
89

3
7b
7d
26
c3
1a
ed
fb
8f
ec
dc
0a
6d
2e
66
11
0d

4
f2
fa
36
18
1b
20
43
92
5f
22
49
8d
1c
48
69
bf

5
6b
59
3f
96
6e
fc
4d
9d
97
2a
06
d5
a6
03
d9
e6

6
6f
47
f7
05
5a
b1
33
38
44
90
24
4e
b4
f6
8e
42

7
c5
f0
cc
9a
a0
5b
85
f5
17
88
5c
a9
c6
0e
94
68

y

8
30
ad
34
07
52
6a
45
bc
c4
46
c2
6c
e8
61
9b
41

9
01
d4
a5
12
3b
cb
f9
b6
a7
ee
d3
56
dd
35
1e
99

a
67
a2
e5
80
d6
be
02
da
7e
b8
ac
f4
74
57
87
2d

b
2b
af
f1
e2
b3
39
7f
21
3d
14
62
ea
1f
b9
e9
0f

c
fe
9c
71
eb
29
4a
50
10
64
de
91
65
4b
86
ce
b0

d
d7
a4
d8
27
e3
4c
3c
ff
5d
5e
95
7a
bd
c1
55
54

e
ab
72
31
b2
2f
58
9f
f3
19
0b
e4
ae
8b
1d
28
bb

f
76
c0
15
75
84
cf
a8
d2
73
db
79
08
8a
9e
df
16

example 4.8. lets assume the input byte to the s-box is ai  (c2)hex , then the
substituted value is
s((c2)hex )  (25)hex .

102

4 the advanced encryption standard (aes)

on a bit level  and remember, the only thing that is ultimate of interest in encryption is the manipulation of bits  this substitution can be described as
s(1100 0010)  (0010 0101).

even though the s-box is bijective, it does not have any fixed points, i.e., there
arent any input values ai such that s(ai )  ai . even the zero-input is not a fixed
point s(0000 0000)  (0110 0011).
example 4.9. lets assume the input to the byte substitution layer is
(c2,c2, . . . ,c2)
in hexadecimal notation. the output state is then
(25, 25, . . . , 25).

mathematical description of the s-box for readers who are interested in how
the s-box entries are constructed, a more detailed description now follows. this
description, however, is not necessary for a basic understanding of aes, and the
remainder of this subsection can be skipped without problem. unlike the des sboxes, which are essentially random tables that fulfill certain properties, the aes
s-boxes have a strong algebraic structure. an aes s-box can be viewed as a twostep mathematical transformation (fig. 4.4).



 








fig. 4.4 the two operations within the aes s-box which computes the function bi  s(ai )

the first part of the substitution is a galois field inversion, the mathematics of
which were introduced in sect. 4.3.2. for each input element ai , the inverse is com8
puted bi  a1
i , where both ai and bi are considered elements in the field gf(2 )
8
4
3
with the fixed irreducible polynomial p(x)  x + x + x + x + 1. a lookup table
with all inverses is shown in table 4.2. note that the inverse of the zero element does
not exist. however, for aes it is defined that the zero element ai  0 is mapped to
itself.
in the second part of the substitution, each byte bi is multiplied by a constant bitmatrix followed by the addition of a constant 8-bit vector. the operation is described
by

4.4 internal structure of aes

103

  
1
b0
b1 1
  
b2 1
  
b3 1
 
b4 1
  
b5 0
  
b6 0
0
b7

0
1
1
1
1
1
0
0

0
0
1
1
1
1
1
0

0
0
0
1
1
1
1
1

1
0
0
0
1
1
1
1

1
1
0
0
0
1
1
1

1
1
1
0
0
0
1
1

   
b0
1
1
b  1
1
  1  
  
1
 b2 0
  
1
 b3 + 0 mod 2.
  
0
 b4 0
  
0
 b5 1
0 b6 1
1
0
b7

note that b  (b7 , . . . , b0 ) is the bitwise vector representation of bi (x)  a1
i (x).
this second step is referred to as affine mapping. lets look at an example of how
the s-box computations work.
example 4.10. we assume the s-box input ai  (1100 0010)2  (c2)hex . from table 4.2 we can see that the inverse is
a1
i  bi  (2f)hex  (0010 1111)2 .
we now apply the bi bit vector as input to the affine transformation. note that the
least significant bit (lsb) b0 of bi is at the rightmost position.
bi  (0010 0101)  (25)hex
thus, s((c2)hex )  (25)hex , which is exactly the result that is also given in the s-box
table 4.3.

if one computes both steps for all 256 possible input elements of the s-box and
stores the results, one obtains table 4.3. in most aes implementations, in particular
in virtually all software realizations of aes, the s-box outputs are not explicitly
computed as shown here, but rather lookup tables like table 4.3 are used. however,
for hardware implementations it is sometimes advantageous to realize the s-boxes
as digital circuits which actually compute the inverse followed by the affine mapping.
the advantage of using inversion in gf(28 ) as the core function of the byte
substitution layer is that it provides a high degree of nonlinearity, which in turn
provides optimum protection against some of the strongest known analytical attacks.
the affine step destroys the algebraic structure of the galois field, which in turn
is needed to prevent attacks that would exploit the finite field inversion.

4.4.2 diffusion layer
in aes, the diffusion layer consists of two sublayers, the shiftrows transformation
and the mixcolumn transformation. we recall that diffusion is the spreading of the
influence of individual bits over the entire state. unlike the nonlinear s-box, the

104

4 the advanced encryption standard (aes)

diffusion layer performs a linear operation on state matrices a, b, i.e., diff(a) +
diff(b)  diff(a + b).

shiftrows sublayer
the shiftrows transformation cyclically shifts the second row of the state matrix
by three bytes to the right, the third row by two bytes to the right and the fourth
row by one byte to the right. the first row is not changed by the shiftrows transformation. the purpose of the shiftrows transformation is to increase the diffusion
properties of aes. if the input of the shiftrows sublayer is given as a state matrix
b  (b0 , b1 , . . . , b15 )
b0
b1
b2
b3

b4
b5
b6
b7

b8
b9
b10
b11

b12
b13
b14
b15

the output is the new state
b0
b5
b10
b15

b4
b9
b14
b3

b8
b13
b2
b7

b12
no shift
b1  one position left shift
b6  two positions left shift
b11  three positions left shift

(4.1)

mixcolumn sublayer
the mixcolumn step is a linear transformation which mixes each column of the
state matrix. since every input byte influences four output bytes, the mixcolumn
operation is the major diffusion element in aes. the combination of the shiftrows
and mixcolumn layer makes it possible that after only three rounds every byte of
the state matrix depends on all 16 plaintext bytes.
in the following, we denote the 16-byte input state by b and the 16-byte output
state by c
mixcolumn(b)  c,
where b is the state after the shiftrows operation as given in expression (4.1).
now, each 4-byte column is considered as a vector and multiplied by a fixed
4  4 matrix. the matrix contains constant entries. multiplication and addition of
the coefficients is done in gf(28 ). as an example, we show how the first four output
bytes are computed

4.4 internal structure of aes

105

  
c0
02
c1 01
 
c2 01
c3
03

03
02
01
01

01
03
02
01

 
01
b0
b5 
01
 .
03 b10
b15
02

the second column of output bytes (c4 ,c5 ,c6 ,c7 ) is computed by multiplying
the four input bytes (b4 , b9 , b14 , b3 ) by the same constant matrix, and so on. figure 4.3 shows which input bytes are used in each of the four mixcolumn operations.
we discuss now the details of the vectormatrix multiplication which forms the
mixcolum operations. we recall that each state byte ci and bi is an 8-bit value
representing an element from gf(28 ). all arithmetic involving the coefficients is
done in this galois field. for the constants in the matrix a hexadecimal notation is
used 01 refers to the gf(28 ) polynomial with the coefficients (0000 0001), i.e., it
is the element 1 of the galois field 02 refers to the polynomial with the bit vector
(0000 0010), i.e., to the polynomial x and 03 refers to the polynomial with the bit
vector (0000 0011), i.e., the galois field element x + 1.
the additions in the vectormatrix multiplication are gf(28 ) additions, that is
simple bitwise xors of the respective bytes. for the multiplication of the constants, we have to realize multiplications with the constants 01, 02 and 03. these
are quite efficient, and in fact, the three constants were chosen such that software
implementation is easy. multiplication by 01 is multiplication by the identity and
does not involve any explicit operation. multiplication by 02 and 03 can be done
through table look-up in two 256-by-8 tables. as an alternative, multiplication by
02 can also be implemented as a multiplication by x, which is a left shift by one bit,
and a modular reduction with p(x)  x8 + x4 + x3 + x + 1. similarly, multiplication
by 03, which represents the polynomial (x + 1), can be implemented by a left shift
by one bit and addition of the original value followed by a modular reduction with
p(x).
example 4.11. we continue with our example from sect. 4.4.1 and assume that the
input state to the mixcolumn layer is
b  (25, 25, . . . , 25).
in this special case, only two multiplications in gf(28 ) have to be done. these are
02  25 and 03  25, which can be computed in polynomial notation
02  25  x  (x5 + x2 + 1)
 x6 + x3 + x,
03  25  (x + 1)  (x5 + x2 + 1)
 (x6 + x3 + x) + (x5 + x2 + 1)
 x6 + x5 + x3 + x2 + x + 1.
since both intermediate values have a degree smaller than 8, no modular reduction
with p(x) is necessary.
the output bytes of c result from the following addition in gf(28 )

106

4 the advanced encryption standard (aes)

01  25
01  25
02  25
03  25
ci


x5 +
x2 +
1
5
x2 +
1

x +
x3 +
x
 x6 +
 x6 + x5 + x3 + x2 + x+ 1

x5 +
x2 +
1,

where i  0, . . . , 15. this leads to the output state c  (25, 25, . . . , 25).


4.4.3 key addition layer
the two inputs to the key addition layer are the current 16-byte state matrix and
a subkey which also consists of 16 bytes (128 bits). the two inputs are combined
through a bitwise xor operation. note that the xor operation is equal to addition in the galois field gf(2). the subkeys are derived in the key schedule that is
described below in sect. 4.4.4.

4.4.4 key schedule
the key schedule takes the original input key (of length 128, 192 or 256 bit) and
derives the subkeys used in aes. note that an xor addition of a subkey is used
both at the input and output of aes. this process is sometimes referred to as key
whitening. the number of subkeys is equal to the number of rounds plus one, due
to the key needed for key whitening in the first key addition layer, cf. fig. 4.2.
thus, for the key length of 128 bits, the number of rounds is nr  10, and there are
11 subkeys, each of 128 bits. the aes with a 192-bit key requires 13 subkeys of
length 128 bits, and aes with a 256-bit key has 15 subkeys. the aes subkeys are
computed recursively, i.e., in order to derive subkey ki , subkey ki1 must be known,
etc.
the aes key schedule is word-oriented, where 1 word  32 bits. subkeys are
stored in a key expansion array w that consists of words. there are different key
schedules for the three different aes key sizes of 128, 192 and 256 bit, which are
all fairly similar. we introduce the three key schedules in the following.

key schedule for 128-bit key aes
the ll subkeys are stored in a key expansion array with the elements w [0], . . . ,w [43].
the subkeys are computed as depicted in fig. 4.5. the elements k0 , . . . , k15 denote
the bytes of the original aes key.
first, we note that the first subkey k0 is the original aes key, i.e., the key is
copied into the first four elements of the key array w . the other array elements are

4.4 internal structure of aes

107

k0 k1 k2 k3 k 4 k 5 k 6 k 7 k 8 k 9 k 10 k 11 k 12 k 13 k 14 k 15
32

round key 0

32

w[0]

32

w[1]

32

w[2]

w[3]

g

function g of round i
32

round key 1

w[4]

w[5]

w[6]

w[7]

v0 v1 v2 v3
8

8

8

....

....

....

8

v1 v2 v3 v0
round key 9

w[36]

w[37]

w[38]

w[39]

s
g

s

s

s

rc[i]
8

32

round key 10

w[40]

w[41]

w[42]

w[43]

fig. 4.5 aes key schedule for 128-bit key size

computed as follows. as can be seen in the figure, the leftmost word of a subkey
w [4i], where i  1, . . . , 10, is computed as
w [4i]  w [4(i  1)] + g(w [4i  1]).
here g() is a nonlinear function with a four-byte input and output. the remaining
three words of a subkey are computed recursively as
w [4i + j]  w [4i + j  1] +w [4(i  1) + j],
where i  1, . . . , 10 and j  1, 2, 3. the function g() rotates its four input bytes,
performs a byte-wise s-box substitution, and adds a round coefficient rc to it. the
round coefficient is an element of the galois field gf(28 ), i.e, an 8-bit value. it is
only added to the leftmost byte in the function g(). the round coefficients vary from
round to round according to the following rule

108

4 the advanced encryption standard (aes)

rc[1]  x0  (0000 0001)2 ,
rc[2]  x1  (0000 0010)2 ,
rc[3]  x2  (0000 0100)2 ,
..
.
rc[10]  x9  (0011 0110)2 .
the function g() has two purposes. first, it adds nonlinearity to the key schedule. second, it removes symmetry in aes. both properties are necessary to thwart
certain block cipher attacks.

key schedule for 192-bit key aes
aes with 192-bit key has 12 rounds and, thus, 13 subkeys of 128 bit each. the
subkeys require 52 words, which are stored in the array elements w [0], . . . ,w [51].
the computation of the array elements is quite similar to the 128-bit key case and
is shown in fig. 4.6. there are eight iterations of the key schedule. (note that these
key schedule iterations do not correspond to the 12 aes rounds.) each iteration
computes six new words of the subkey array w . the subkey for the first aes round
is formed by the array elements (w [0],w[1], w [2],w [3]), the second subkey by
the elements (w [4],w[5], w [6],w [7]), and so on. eight round coefficients rc[i] are
needed within the function g(). they are computed as in the 128-bit case and range
from rc[1], . . . , rc[8].

key schedule for 256-bit key aes
aes with 256-bit key needs 15 subkeys. the subkeys are stored in the 60 words
w [0], . . . ,w [59]. the computation of the array elements is quite similar to the 128bit key case and is shown in fig. 4.7. the key schedule has seven iterations, where
each iteration computes eight words for the subkeys. (again, note that these key
schedule iterations do not correspond to the 14 aes rounds.) the subkey for the first
aes round is formed by the array elements (w [0],w[1], w [2],w [3]), the second
subkey by the elements (w [4],w[5], w [6],w [7]), and so on. there are seven round
coefficients rc[1], . . . , rc[7] within the function g() needed, that are computed as
in the 128-bit case. this key schedule also has a function h() with 4-byte input and
output. the function applies the s-box to all four input bytes.
in general, when implementing any of the key schedules, two different approaches exist
1. precomputation all subkeys are expanded first into the array w . the encryption
(decryption) of a plaintext (ciphertext) is executed afterwards. this approach is often
taken in pc and server implementations of aes, where large pieces of data are
encrypted under one key. please note that this approach requires (nr + 1)  16 bytes
of memory, e.g., 11  16  176 bytes if the key size is 128 bits. this is the reason

4.4 internal structure of aes

109

k0 k1 k2 k3 k 4 k 5 k 6 k 7 k 8 k 9 k 10 k 11 k12 k13 k14 k15 k16 k17 k18 k19 k20 k21 k22 k23
32

32

w[0]

32

w[1]

32

w[2]

32

w[3]

32

w[4]

w[5]

g

function g of round i
32

w[6]

w[7]

w[8]

w[9]

w[10]

v0 v1 v2 v3

w[11]

....

....

....

....

....

8

w[43]

w[44]

w[45]

w[46]

8

8

v1 v2 v3 v0

s
w[42]

8

w[47]

s

s

s

rc[i]
8

g
32

w[48]

w[49]

w[50]

w[51]

fig. 4.6 aes key schedule for 192-bit key sizes

why such an implementation on a device with limited memory resources, such as a
smart card, is sometimes not desireable.
2. on-the-fly a new subkey is derived for every new round during the encryption
(decryption) of a plaintext (ciphertext). please note that when decrypting ciphertexts, the last subkey is xored first with the ciphertext. therefore, it is required to
recursively derive all subkeys first and then start with the decryption of a ciphertext
and the on-the-fly generation of subkeys. as a result of this overhead, the decryption
of a ciphertext is always slightly slower than the encryption of a plaintext when the
on-the-fly generation of subkeys is used.

110

4 the advanced encryption standard (aes)

k0 k1 k2 k3 k 4 k 5 k 6 k 7 k 8 k 9 k 10 k 11 k 12 k 13 k 14 k 15 k 16 k 17 k 18 k19 k 20 k 21 k 22 k23 k 24 k 25 k 26 k27 k28 k29 k30 k31
32

32

w[0]

32

w[1]

32

w[2]

32

w[3]

32

32

32

w[4]

w[5]

w[6]

w[7]

w[12]

w[13]

w[14]

w[15]

g

w[48]

w[49]

w[50]

w[51]

w[52]

....

....

w[11]

....

....

w[10]

....

w[9]

....

w[8]

....

h

w[53]

w[54]

w[55]

g
function g of round i

h function

32

32

v0 v1 v2 v3
8

8

8

v0 v1 v2 v3

8

s

s

s

s

v1 v2 v3 v0

w[56]

w[57]

w[58]

w[59]

s

s

s

s

32

rc[i]
8

32

fig. 4.7 aes key schedule for 256-bit key size

4.5 decryption
because aes is not based on a feistel network, all layers must actually be inverted, i.e., the byte substitution layer becomes the inv byte substitution layer,
the shiftrows layer becomes the inv shiftrows layer, and the mixcolumn layer
becomes inv mixcolumn layer. however, as we will see, it turns out that the inverse
layer operations are fairly similar to the layer operations used for encryption. in ad-

4.5 decryption

111

dition, the order of the subkeys is reversed, i.e., we need a reversed key schedule. a
block diagram of the decryption function is shown in fig. 4.8.
ciphertext

y

key addition layer
inverse of round n r

k nr
transform n r

inv shiftrows layer
inv byte substitution

key addition layer

k nr 1
transform n r 1

inv mixcolumn layer

inverse of round n r 1
inv shiftrows layer

inv byte substitution

k1
key addition layer

transform 1

inv mixcolumn layer

inverse of round 1
inv shiftrows layer

inv byte substitution

k0
key addition layer

transform 0

key k
plaintext

x aes 1( y)

fig. 4.8 aes decryption block diagram

since the last encryption round does not perform the mixcolum operation, the
first decryption round also does not contain the corresponding inverse layer. all
other decryption rounds, however, contain all aes layers. in the following, we discuss the inverse layers of the general aes decryption round (fig. 4.9). since the

112

4 the advanced encryption standard (aes)

xor operation is its own inverse, the key addition layer in the decryption mode is
the same as in the encryption mode it consists of a row of plain xor gates.

key addition

ki

c0 c1 c2 c3

c4 c5 c6 c7

c8 c9 c10 c11

c12 c13 c14 c15

b0 b13 b10 b7

b4 b1 b14 b11

b8 b5 b2 b15

b12 b9 b6 b3

s s s s

s s s s

s s s s

s s s s

a0 a1 a2 a3

a4 a5 a6 a7

a8 a9 a10 a11

a12 a13 a14 a15

invmixcolumn

invshiftrows

invsubbytes

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

1

fig. 4.9 aes decryption round function 1, 2, . . . , nr  1

inverse mixcolumn sublayer
after the addition of the subkey, the inverse mixcolumn step is applied to the state
(again, the exception is the first decryption round). in order to reverse the mixcolumn operation, the inverse of its matrix must be used. the input is a 4-byte column
of the state c which is multiplied by the inverse 4  4 matrix. the matrix contains
constant entries. multiplication and addition of the coefficients is done in gf(28 ).
  
0e
b0
b1  09
 
b2 0d
0b
b3

0b
0e
09
0d

 
0d 09
c0
c1
0b 0d
 
0e 0b c2
09 0e
c3

the second column of output bytes (b4 , b5 , b6 , b7 ) is computed by multiplying the
four input bytes (c4 ,c5 ,c6 ,c7 ) by the same constant matrix, and so on. each value

4.5 decryption

113

bi and ci is an element from gf(28 ). also, the constants are elements from gf(28 ).
the notation for the constants is hexadecimal and is the same as was used for the
mixcolumn layer, for example
0b  (0b)hex  (0000 1011)2  x3 + x + 1.
additions in the vectormatrix multiplication are bitwise xors.

inverse shiftrows sublayer
in order to reverse the shiftrows operation of the encryption algorithm, we must
shift the rows of the state matrix in the opposite direction. the first row is not
changed by the inverse shiftrows transformation. if the input of the shiftrows
sublayer is given as a state matrix b  (b0 , b1 , . . . , b15 )
b0
b1
b2
b3

b4
b5
b6
b7

b8
b9
b10
b11

b12
b13
b14
b15

the inverse shiftrows sublayer yields the output
b0
b13
b10
b7

b4
b1
b14
b11

b8
b5
b2
b15

b12
no shift
b9  one position right shift
b6  two positions right shift
b3  three positions right shift

inverse byte substitution layer
the inverse s-box is used when decrypting a ciphertext. since the aes s-box is
a bijective, i.e., a one-to-one mapping, it is possible to construct an inverse s-box
such that
ai  s1 (bi )  s1 (s(ai )),
where ai and bi are elements of the state matrix. the entries of the inverse s-box
are given in table 4.4.
for readers who are interested in the details of how the entries of inverse s-box
are constructed, we provide a derivation. however, for a functional understanding
of aes, the remainder of this section can be skipped. in order to reverse the sbox substitution, we first have to compute the inverse of the affine transformation.
for this, each input byte bi is considered an element of gf(28 ). the inverse affine
transformation on each byte bi is defined by

114

4 the advanced encryption standard (aes)

table 4.4 inverse aes s-box substitution values in hexadecimal notation for input byte (xy)

x

0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f

0
52
7c
54
08
72
6c
90
d0
3a
96
47
fc
1f
60
a0
17

1
09
e3
7b
2e
f8
70
d8
2c
91
ac
f1
56
dd
51
e0
2b

2
6a
39
94
a1
f6
48
ab
1e
11
74
1a
3e
a8
7f
3b
04

  
b0
0
b  0
 1  
b  1
 2  
b  0
 3   
b  0
 4  
b  1
 5  
b  0
6
b7
1

3
d5
82
32
66
64
50
00
8f
41
22
71
4b
33
a9
4d
7e

4
30
9b
a6
28
86
fd
8c
ca
4f
e7
1d
c6
88
19
ae
ba

5
36
2f
c2
d9
68
ed
bc
3f
67
ad
29
d2
07
b5
2a
77

1
0
0
1
0
0
1
0

01
10
01
00
10
01
00
10

6
a5
ff
23
24
98
b9
d3
0f
dc
35
c5
79
c7
4a
f5
d6

00
10
01
10
01
00
10
01

y

7
38
87
3d
b2
16
da
0a
02
ea
85
89
20
31
0d
b0
26

8
bf
34
ee
76
d4
5e
f7
c1
97
e2
6f
9a
b1
2d
c8
e1

9
40
8e
4c
5b
a4
15
e4
af
f2
f9
b7
db
12
e5
eb
69

a
a3
43
95
a2
5c
46
58
bd
cf
37
62
c0
10
7a
bb
14

b
9e
44
0b
49
cc
57
05
03
ce
e8
0e
fe
59
9f
3c
63

c
81
c4
42
6d
5d
a7
b8
01
f0
1c
aa
78
27
93
83
55

d
f3
de
fa
8b
65
8d
b3
13
b4
75
18
cd
80
c9
53
21

e
d7
e9
c3
d1
b6
9d
45
8a
e6
df
be
5a
ec
9c
99
0c

f
fb
cb
4e
25
92
84
06
6b
73
6e
1b
f4
5f
ef
61
7d

   
10
b0
0
b1 0
0 1
   
  
0 0
 b2 0
  
1 0
 b3 + 0 mod 2,
  
0 1
 b4 0
  
1 0
 b5 1
0 1 b6 0
00
b7
1

where (b7 , . . . , b0 ) is the bitwise vector representation of bi (x), and (b7 , . . . , b0 ) the
result after the inverse affine transformation.
in the second step of the inverse s-box operation, the galois field inverse has to
1
be reversed. for this, note that ai  (a1
i ) . this means that the inverse operation
is reversed by computing the inverse again. in our notation we thus have to compute
ai  (bi )1  gf(28 )
with the fixed reduction polynomial p(x)  x8 + x4 + x3 + x + 1. again, the zero element is mapped to itself. the vector ai  (a7 , . . . , a0 ) (representing the field element
a7 x7 +    + a1 x + a0 ) is the result of the substitution
ai  s1 (bi ).
decryption key schedule
since decryption round one needs the last subkey, the second decryption round
needs the second-to-last subkey and so on, we need the subkey in reversed order
as shown in fig. 4.8. in practice this is mainly achieved by computing the entire
key schedule first and storing all 11, 13 or 15 subkeys, depending on the number or

4.6 implementation in software and hardware

115

rounds aes is using (which in turn depends on the three key lengths supported by
aes). this precomputation adds usually a small latency to the decryption operation
relative to encryption.

4.6 implementation in software and hardware
we briefly comment on the efficiency of the aes cipher with respect to software
and hardware implementation.

software
unlike des, aes was designed such that an efficient software implementation is
possible. a straightforward implementation of aes which directly follows the data
path description, such as the description given in this chapter, is well suited for 8bit processors such as those found on smart cards, but is not particularly efficient
on 32-bit or 64-bit machines, which are common in todays pcs. in a nave implementation, all time-critical functions (byte substitution, shiftrows, mixcolumn)
operate on individual bytes. processing 1 byte per instruction is inefficient on modern 32-bit or 64-bit processors.
however, the rijndael designers proposed a method which results in fast software implementations. the core idea is to merge all round functions (except the
rather trivial key addition) into one table look-up. this results in four tables, each
of which consists of 256 entries, where each entry is 32 bits wide. these tables
are named a t-box. four table accesses yield 32 output bits of one round. hence,
one round can be computed with 16 table look-ups. on a 1.2-ghz intel processor,
a throughput of 400 mbit/s (or 50 mbyte/s) is possible. the fastest known implementation on a 64-bit athlon cpu achieves a theoretical throughput of more than
1.6 gbit/s. however, conventional hard disc encryption tools with aes or an opensource implementation of aes reach a perfomance of a few hundred mbit/s on
similar platforms.

hardware
compared to des, aes requires more hardware resources for an implementation.
however, due to the high integration density of modern integrated circuits, aes
can be implemented with very high throughputs in modern asic or fpga (field
programmable gate array  these are programmable hardware devices) technology. commercial aes asics can exceed throughputs of 10gbit/sec. through parallelization of aes encryption units on one chip, the speed can be further increased.
it can be said that symmetric encryption with todays ciphers is extremely fast, not
only compared to asymmetric cryptosystems but also compared to other algorithms

116

4 the advanced encryption standard (aes)

needed in modern communication systems, such as data compression or signal processing schemes.

4.7 discussion and further reading
aes algorithm and security a detailed description of the design principles of
aes can be found in [52]. this book by the rijndael inventors describes the design
of the block cipher. recent research in context to aes can be found online in the
aes lounge [68]. this website is a dissemination effort within ecrypt, the network of excellence in cryptology, and is a rich resource of activities around aes.
it gives many links to further information and papers regarding implementation and
theoretical aspects of aes.
there is currently no analytical attack against aes known which has a complexity less than a brute-force attack. an elegant algebraic description was found
[122], which in turn triggered speculations that this could lead to attacks. subsequent research showed that an attack is, in fact, not feasible. by now, the common
assumption is that the approach will not threaten aes. a good summary on algebraic attacks can be found in [43]. in addition, there have been proposals for many
other attacks, including square attack, impossible differential attack or related key
attack. again, a good source for further references is the aes lounge.
the standard reference for the mathematics of finite fields is [110]. a very accessible but brief introduction is also given in [19]. the international workshop on the
arithmetic of finite fields (waifi), a relatively new workshop series, is concerned
with both the applications and the theory of galois fields [171].
implementation as mentioned in sect. 4.6, in most software implementations on
modern cpus special lookup tables are being used (t-boxes). an early detailed description of the construction of t-boxes can be found in [51, sect. 5]. a description
of a high-speed software implementation on modern 32-bit and 64-bit cpus is given
in [116, 115]. the bit slicing technique which was developed in the context of des
is also applicable to aes and can lead to very fast code as shown in [117].
a strong indication for the importance of aes was the recent introduction of
special aes instructions by intel in cpus starting in 2008. the instructions allow
these machines to compute the round operation particularly quickly.
there is wealth of literature dealing with hardware implementation of aes.
a good introduction to the area of aes hardware architectures is given in [104,
chap. 10]. as an example of the variety of aes implementations, reference [86] describes a very small fpga implementation with 2.2mbit/s and a very fast pipelined
fpga implementation with 25gbit/s. it is also possible to use the dsp blocks (i.e.,
fast arithmetic units) available on modern fpgas for aes, which can also yield
throughputs beyond 50mbit/s [63]. the basic idea in all high-speed architectures is
to process several plaintext blocks in parallel by means of pipelining. on the other
end of the performance spectrum are lightweight architectures which are optimized

4.8 lessons learned

117

for applications such as rfid. the basic idea here is to serialize the data path, i.e.,
one round is processed in several time steps. good references are [75, 42].

4.8 lessons learned







aes is a modern block cipher which supports three key lengths of 128, 192 and
256 bit. it provides excellent long-term security against brute-force attacks.
aes has been studied intensively since the late 1990s and no attacks have been
found that are better than brute-force.
aes is not based on feistel networks. its basic operations use galois field arithmetic and provide strong diffusion and confusion.
aes is part of numerous open standards such as ipsec or tls, in addition to
being the mandatory encryption algorithm for us government applications. it
seems likely that the cipher will be the dominant encryption algorithm for many
years to come.
aes is efficient in software and hardware.

118

4 the advanced encryption standard (aes)

problems
4.1. since may 26, 2002, the aes (advanced encryption standard) describes the
official standard of the us government.
1. the evolutionary history of aes differs from that of des. briefly describe the
differences of the aes history in comparison to des.
2. outline the fundamental events of the developing process.
3. what is the name of the algorithm that is known as aes
4. who developed this algorithm
5. which block sizes and key lengths are supported by this algorithm
4.2. for the aes algorithm, some computations are done by galois fields (gf).
with the following problems, we practice some basic computations.
compute the multiplication and addition table for the prime field gf(7). a multiplication table is a square (here 7  7) table which has as its rows and columns all
field elements. its entries are the products of the field element at the corresponding
row and column. note that the table is symmetric along the diagonal. the addition
table is completely analogous but contains the sums of field elements as entries.
4.3. generate the multiplication table for the extension field gf(23 ) for the case
that the irreducible polynomial is p(x)  x3 + x + 1. the multiplication table is in
this case a 8  8 table. (remark you can do this manually or write a program for
it.)
4.4. addition in gf(24 ) compute a(x) + b(x) mod p(x) in gf(24 ) using the irreducible polynomial p(x)  x4 + x + 1. what is the influence of the choice of the
reduction polynomial on the computation
1. a(x)  x2 + 1, b(x)  x3 + x2 + 1
2. a(x)  x2 + 1, b(x)  x + 1
4.5. multiplication in gf(24 ) compute a(x)  b(x) mod p(x) in gf(24 ) using the
irreducible polynomial p(x)  x4 + x + 1. what is the influence of the choice of the
reduction polynomial on the computation
1. a(x)  x2 + 1, b(x)  x3 + x2 + 1
2. a(x)  x2 + 1, b(x)  x + 1
4.6. compute in gf(28 )
(x4 + x + 1)/(x7 + x6 + x3 + x2 ),
where the irreducible polynomial is the one used by aes, p(x)  x8 +x4 +x3 +x+1.
note that table 4.2 contains a list of all multiplicative inverses for this field.
4.7. we consider the field gf(24 ), with p(x)  x4 +x+1 being the irreducible polynomial. find the inverses of a(x)  x and b(x)  x2 + x. you can find the inverses

problems

119

either by trial and error, i.e., brute-force search, or by applying the euclidean algorithm for polynomials. (however, the euclidean algorithm is only sketched in this
chapter.) verify your answer by multiplying the inverses you determined by a and
b, respectively.
4.8. find all irreducible polynomials
1. of degree 3 over gf(2),
2. of degree 4 over gf(2).
the best approach for doing this is to consider all polynomials of lower degree and
check whether they are factors. please note that we only consider monic irreducible
polynomials, i.e., polynomials with the highest coefficient equal to one.
4.9. we consider aes with 128-bit block length and 128-bit key length. what is the
output of the first round of aes if the plaintext consists of 128 ones, and the first
subkey (i.e., the first subkey) also consists of 128 ones you can write your final
results in a rectangular array format if you wish.
4.10. in the following, we check the diffusion properties of aes after a single round. let w  (w0 , w1 , w2 , w3 )  (0x01000000, 0x00000000, 0x00000000,
0x00000000) be the input in 32-bit chunks to a 128-bit aes. the subkeys for the
computation of the result of the first round of aes are w0 , . . . ,w7 with 32 bits each
are given by
w0  (0x2b7e1516),
w1  (0x28aed2a6),
w2  (0xabf71588),
w3  (0x09cf4f3c),
w4  (0xa0fafe17),
w5  (0x88542cb1),
w6  (0x23a33939),
w7  (0x2a6c7605).
use this book to figure out how the input is processed in the first round (e.g., sboxes). for the solution, you might also want to write a short computer program or
use an existing one. in any case, indicate all intermediate steps for the computation
of shiftrows, subbytes and mixcolumns
1. compute the output of the first round of aes to the input w and the subkeys
w0 , . . . ,w7 .
2. compute the output of the first round of aes for the case that all input bits are
zero.
3. how many output bits have changed remark that we only consider a single
round  after every further round, more output bits will be affected (avalanche
effect).

120

4 the advanced encryption standard (aes)

4.11. the mixcolumn transformation of aes consists of a matrixvector multiplication in the field gf(28 ) with p(x)  x8 + x4 + x3 + x + 1. let b  (b7 x7 + . . . + b0 )
be one of the (four) input bytes to the vectormatrix multiplication. each input byte
is multiplied with the constants 01, 02 and 03. your task is to provide exact equations for computing those three constant multiplications. we denote the result by
d  (d7 x7 + . . . + d0 ).
1. equations for computing the 8 bits of d  01  b.
2. equations for computing the 8 bits of d  02  b.
3. equations for computing the 8 bits of d  03  b.
note the aes specification uses 01 to represent the polynomial 1, 02 to represent the polynomial x, and 03 to represent x + 1.
4.12. we now look at the gate (or bit) complexity of the mixcolumn function, using
the results from problem 4.11. we recall from the discussion of stream ciphers that
a 2-input xor gate performs a gf(2) addition.
1. how many 2-input xor gates are required to perform one constant multiplication by 01, 02 and 03, respectively, in gf(28 ).
2. what is the overall gate complexity of a hardware implementation of one matrix
vector multiplication
3. what is the overall gate complexity of a hardware implementation of the entire
diffusion layer we assume permutations require no gates.
4.13. we consider the first part of the bytesub operation, i.e, the galois field inversion.
1. using table 4.2, what is the inverse of the bytes 29, f3 and 01, where each byte
is given in hexadecimal notation
2. verify your answer by performing a gf(28 ) multiplication with your answer and
the input byte. note that you have to represent each byte first as polynomials in
gf(28 ). the msb of each byte represents the x7 coefficient.
4.14. your task is to compute the s-box, i.e., the bytesub, values for the input bytes
29, f3 and 01, where each byte is given in hexadecimal notation.
1. first, look up the inverses using table 4.2 to obtain values b . now, perform the
affine mapping by computing the matrixvector multiplication and addition.
2. verify your result using the s-box table 4.3.
3. what is the value of s(0)
4.15. derive the bit representation for the following round constants within the key
schedule




rc[8]
rc[9]
rc[10]

problems

121

4.16. the minimum key length for the aes algorithm is 128 bit. assume that a
special-purpose hardware key-search machine can test one key in 10 ns on one processor. the processors can be parallelized. assume further that one such processor
costs 10, including overhead. (note that both the processor speed and the prize are
rather optimistic assumptions.) we assume also that moores law holds, according
to which processor performance doubles every 18 months.
how long do we have to wait until an aes key search machine can be built
which breaks the algorithm on average in one week and which doesnt cost more
than 1 million
4.17. for the following, we assume aes with 192-bit key length. furthermore, let
us assume an asic which can check 3  107 keys per second.
1. if we use 100,000 such ics in parallel, how long does an average key search take
compare this period of time with the age of the universe (approx. 1010 years).
2. assume moores law will still be valid for the next few years, how many years
do we have to wait until we can build a key search machine to perform an average
key search of aes-192 in 24 hours again, assume that we use 100,000 ics in
parallel.

chapter 5

more about block ciphers

a block cipher is much more than just an encryption algorithm. it can be used as
a versatile building block with which a diverse set of cryptographic mechanisms
can be realized. for instance, we can use them for building different types of blockbased encryption schemes, and we can even use block ciphers for realizing stream
ciphers. the different ways of encryption are called modes of operation and are
discussed in this chapter. block ciphers can also be used for constructing hash functions, message authentication codes which are also knowns as macs, or key establishment protocols, all of which will be described in later chapters. there are also
other uses for block ciphers, e.g., as pseudo-random generators. in addition to modes
of operation, this chapter also discusses two very useful techniques for increasing
the security of block ciphers, namely key whitening and multiple encryption.
in this chapter you will learn






the most important modes of operation for block ciphers in practice
security pitfalls when using modes of operations
the principles of key whitening
why double encryption is not a good idea, and the meet-in-the-middle attack
triple encryption

c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 5, 

123

124

5 more about block ciphers

5.1 encryption with block ciphers modes of operation
in the previous chapters we introduced how des, 3des and aes encrypt a block
of data. of course, in practice one wants typically to encrypt more than one single
8-byte or 16-byte block of plaintext, e.g., when encrypting an e-mail or a computer
file. there are several ways of encrypting long plaintexts with a block cipher. we
introduce several popular modes of operation in this chapter, including






electronic code book mode (ecb),
cipher block chaining mode (cbc),
cipher feedback mode (cfb),
output feedback mode (ofb),
counter mode (ctr).

the latter three modes use the block cipher as a building block for a stream cipher.
all of the five modes have one goal they encrypt data and thus provide confidentiality for a message sent from alice to bob. in practice, we often not only want
to keep data confidential, but bob also wants to know whether the message is really coming from alice. this is called authentication and the galois counter mode
(gcm), which we will also introduce, is a mode of operation that lets the receiver
(bob) determine whether the message was really sent by the person he shares a key
with (alice). moreover, authentication also allows bob to detect whether the ciphertext was altered during transmission. more on authentication is found in chap. 10.
the ecb and cfb modes require that the length of the plaintext be an exact
multiple of the block size of the cipher used, e.g., a multiple of 16 bytes in the
case of aes. if the plaintext does not have this length, it must be padded. there
are several ways of doing this padding in practice. one possible padding method
is to append a single 1 bit to the plaintext and then to append as many 0 bits
as necessary to reach a multiple of the block length. should the plaintext be an
exact multiple of the block length, an extra block consisting only of padding bits is
appended.

5.1.1 electronic codebook mode (ecb)
the electronic code book (ecb) mode is the most straightforward way of encrypting a message. in the following, let ek (xi ) denote the encryption of plaintext block
xi with key k using some arbitrary block cipher. let e1
k (yi ) denote the decryption
of ciphertext block yi with key k. let us assume that the block cipher encrypts (decrypts) blocks of size b bits. messages which exceed b bits are partitioned into b-bit
blocks. if the length of the message is not a multiple of b bits, it must be padded to
a multiple of b bits prior to encryption. as shown in fig. 5.1, in ecb mode each
block is encrypted separately. the block cipher can, for instance, be aes or 3des.
encryption and decryption in the ecb mode is formally described as follows

5.1 encryption with block ciphers modes of operation




125









fig. 5.1 encryption and decryption in ecb mode

definition 5.1.1 electronic codebook mode (ecb)
let e() be a block cipher of block size b, and let xi and yi be bit
strings of length b.
encryption yi  ek (xi ), i  1
1
decryption xi  e1
k (yi )  ek (ek (xi )), i  1
it is straightforward to verify the correctness of the ecb mode
1
e1
k (yi )  ek (ek (xi ))  xi .

the ecb mode has advantages. block synchronization between the encryption
and decryption parties alice and bob is not necessary, i.e., if the receiver does not
receive all encrypted blocks due to transmission problems, it is still possible to decrypt the received blocks. similarly, bit errors, e.g., caused by noisy transmission
lines, only affect the corresponding block but not succeeding blocks. also, block ciphers operating in ecb mode can be parallelized, e.g., one encryption unit encrypts
(or decrypts) block 1, the next one block 2, and so on. this is an advantage for
high-speed implementations, but many other modes such as the cfb do not allow
parallelization.
however, as is often the case in cryptography, there are some unexpected weaknesses associated with the ecb mode which we will discuss in the following. the
main problem of the ecb mode is that it encrypts highly deterministically. this
means that identical plaintext blocks result in identical ciphertext blocks, as long as
the key does not change. the ecb mode can be viewed as a gigantic code book 
hence the modes name  which maps every input to a certain output. of course, if
the key is changed the entire code book changes, but as long as the key is static the
book is fixed. this has several undesirable consequences. first, an attacker recognizes if the same message has been sent twice simply by looking at the ciphertext.
deducing information from the ciphertext in this way is called traffic analysis. for
instance, if there is a fixed header that always precedes a message, the header always
results in the same ciphertext. from this, an attacker can, for instance, learn when
a new message has been sent. second, plaintext blocks are encrypted independently
of previous blocks. if an attacker reorders the ciphertext blocks, this might result in
valid plaintext and the reordering might not be detected. we demonstrate two simple
attacks which exploit these weaknesses of the ecb mode.
the ecb mode is susceptible to substitution attacks, because once a particular
plaintext to ciphertext block mapping xi  yi is known, a sequence of ciphertext

126

5 more about block ciphers

blocks can easily be manipulated. we demonstrate how a substitution attack could
work in the real world. imagine the following example of an electronic wire transfer
betweens banks.
example 5.1. substitution attack against electronic bank transfer
lets assume a protocol for wire transfers between banks (fig. 5.2). there are five
fields which specify a transfer the sending banks id and account number, the receiving banks id and account number, and the amount. we assume now (and this
is a major simplification) that each of the fields has exactly the size of the block
cipher width, e.g., 16 bytes in the case of aes. furthermore, the encryption key between the two banks does not change too frequently. due to the nature of the ecb,
an attacker can exploit the deterministic nature of this mode of operation by simple
substitution of the blocks. the attack details are as follows
block 

1
sending
bank a

2

3

4

5

sending
receiving receiving amount
account  bank b
account 


fig. 5.2 example for a substitution attack against ecb encryption

1. the attacker, oscar, opens one account at bank a and one at bank b.
2. oscar taps the encrypted line of the banking communication network.
3. he sends 1.00 transfers from his account at bank a to his account at bank b
repeatedly. he observes the ciphertexts going through the communication network. even though he cannot decipher the random-looking ciphertext blocks, he
can check for ciphertext blocks that repeat. after a while he can recognize the
five blocks of his own transfer. he now stores blocks 1, 3 and 4 of these transfers.
these are the encrypted versions of the id numbers of both banks as well as the
encrypted version of his account at bank b.
4. recall that the two banks do not change the key too frequently. this means that
the same key is used for several other transfers between bank a and b. by comparing blocks 1 and 3 of all subsequent messages with the ones he has stored,
oscar recognizes all transfers that are made from some account at bank a to
some account at bank b. he now simply replaces block 4  which contains the
receiving account number  with the block 4 that he stored before. this block
contains oscars account number in encrypted form. as a consequence, all transfers from some account of bank a to some account of bank b are redirected to
go into oscars b account note that bank b now has means of detecting that the
block 4 has been replaced in some of the transfers it receives.
5. withdraw money from bank b quickly and fly to a country that has a relaxed
attitude about the extradition of white-collar criminals.

whats interesting about this attack is that it works completely without attacking the block cipher itself. so even if we would use aes with a 256-bit key and if

5.1 encryption with block ciphers modes of operation

127

we would encrypt each block, say, 1000 times, this would not prevent the attack. it
should be stressed, however, that this is not an attack that breaks the block cipher
itself. messages that are unknown to oscar still remain confidential. he simply replaced parts of the ciphertext with some other (previous) ciphertexts. this is called
a violation of the integrity of the message. there are available techniques for preserving the integrity of a message, namely message authentication codes (macs)
and digital signatures. both are widely used in practice to prevent such an attack,
and are introduced in chaps. 10 and 12. also, the galois counter mode, which is
described below, is an encryption mode with a built-in integrity check. note that this
attack only works if the key between bank a and b is not changed too frequently.
this is another reason why frequent key freshness is a good idea.
we now look at another problem posed by the ecb mode.
example 5.2. encryption of bitmaps in ecb mode
figure 5.3 clearly shows a major disadvantage of the ecb mode identical plaintexts
are mapped to identical ciphertexts. in case of a simple bitmap, the information (text
in the picture) can still be read out from the encrypted picture even though we used
aes with a 256-bit key for encryption. this is because the background consists of
only a few different plaintext blocks which yields a fairly uniformly looking background in the ciphertext. on the other hand, all plaintext blocks which contain part
of the letters result in random-looking ciphertexts. these random-looking ciphertexts are clearly distinguishable from the uniform background by the human eye.

fig. 5.3 image and encrypted image using aes with 256-bit key in ecb mode



128

5 more about block ciphers

this weakness is similar to the attack of the substitution cipher that was introduced in the first example. in both cases, statistical properties in the plaintext are
preserved in the ciphertext. note that unlike an attack against the substitution cipher
or the above banking transfer attack, an attacker does not have to do anything in the
case here. the human eye automatically makes use of the statistical information.
both attacks above were examples of the weakness of a deterministic encryption
scheme. thus, it is usually preferable that different ciphertexts are produced every
time we encrypt the same plaintext. this behavior is called probabilistic encryption. this can be achieved by introducing some form of randomness, typically in
form of an initialization vector (iv). the following modes of operation all encrypt
probabilistically by means of an iv.

5.1.2 cipher block chaining mode (cbc)
there are two main ideas behind the cipher block chaining (cbc) mode. first, the
encryption of all blocks are chained together such that ciphertext yi depends not
only on block xi but on all previous plaintext blocks as well. second, the encryption
is randomized by using an initialization vector (iv). here are the details of the cbc
mode.
the ciphertext yi , which is the result of the encryption of plaintext block xi , is
fed back to the cipher input and xored with the succeeding plaintext block xi+1 .
this xor sum is then encrypted, yielding the next ciphertext yi+1 , which can then
be used for encrypting xi+2 , and so on. this process is shown on the left-hand side
of fig. 5.4. for the first plaintext block x1 there is no previous ciphertext. for this an
iv is added to the first plaintext, which also allows us to make each cbc encryption
nondeterministic. note that the first ciphertext y1 depends on plaintext x1 (and the
iv). the second ciphertext depends on the iv, x1 and x2 . the third ciphertext y3
depends on the iv and x1 , x2 , x3 , and so on. the last ciphertext is a function of all
plaintext blocks and the iv.



fig. 5.4 encryption and decryption in cbc mode

when decrypting a ciphertext block yi in cbc mode, we have to reverse the two
operations we have done on the encryption side. first, we have to reverse the block
cipher encryption by applying the decryption function e1 (). after this we have to

5.1 encryption with block ciphers modes of operation

129

undo the xor operation by again xoring the correct ciphertext block. this can
be expressed for general blocks yi as e1
k (yi )  xi  yi1 . the right-hand side of
fig. 5.4 shows this process. again, if the first ciphertext block y1 is decrypted, the
result must be xored with the initialization vector iv to determine the plaintext
block x1 , i.e., x1  iv  e1
k (y1 ). the entire process of encryption and decryption
can be described as
definition 5.1.2 cipher block chaining mode (cbc)
let e() be a block cipher of block size b let xi and yi be bit strings
of length b and iv be a nonce of length b.
encryption (first block) y1  ek (x1  iv )
encryption (general block) yi  ek (xi  yi1 ), i  2
decryption (first block) x1  e1
k (y1 )  iv
i2
decryption (general block) xi  e1
k (yi )  yi1 ,
we now verify the mode, i.e., we show that the decryption actually reverses the
encryption. for the decryption of the first block y1 , we obtain
1
d(y1 )  e1
k (y1 )  iv  ek (ek (x1  iv ))  iv  (x1  iv )  iv  x1

for the decryption of all subsequent blocks yi , i  2, we obtain
1
d(yi )  e1
k (yi )  yi1  ek (ek (xi  yi1 ))  yi1  (xi  yi1 )  yi1  xi

if we choose a new iv every time we encrypt, the cbc mode becomes a probabilistic encryption scheme. if we encrypt a string of blocks x1 , . . . , xt once with a
first iv and a second time with a different iv, the two resulting ciphertext sequences
look completely unrelated to each other for an attacker. note that we do not have
to keep the iv secret. however, in most cases, we want the iv to be a nonce, i.e., a
number used only once. there are many different ways of generating and agreeing
on initialization values. in the simplest case, a randomly chosen number is transmitted in the clear between the two communication parties prior to the encrypted
session. alternatively it is a counter value that is known to alice and bob, and it is
incremented every time a new session starts (which requires that the counter value
must be stored between sessions). it could be derived from values such as alices
and bobs id number, e.g., their ip addresses, together with the current time. also,
in order to strengthen any of these methods, we can take a value as described above
and ecb-encrypt it once using the block cipher with the key known to alice and
bob, and use the resulting ciphertext as the iv. there are some advanced attacks
which also require that the iv is nonpredictable.
it is instructive to discuss whether the substitution attack against the bank transfer that worked for the ecb mode is applicable to the cbc mode. if the iv is
properly chosen for every wire transfer, the attack will not work at all since oscar will not recognize any patterns in the ciphertext. if the iv is kept the same for
several transfers, he would recognize the transfers from his account at bank a to

130

5 more about block ciphers

his account at bank b. however, if he substitutes ciphertext block 4, which is his
encrypted account number, in other wire transfers going from bank a to b, bank
b would decrypt block 4 and 5 to some random value. even though money would
not be redirected into oscars account, it might be redirected to some other random
account. the amount would be a random value too. this is obviously also highly
undesirable for banks. this example shows that even though oscar cannot perform
specific manipulations, ciphertext alterations by him can cause random changes to
the plaintext, which can have major negative consequences. hence in many, if not in
most, real-world systems, encryption itself is not sufficient we also have to protect
the integrity of the message. this can be achieved by message authentication codes
(macs) or digital signatures, which are introduced in chap. 12. the galois counter
mode described below provides encryption and integrity check simultaneously.

5.1.3 output feedback mode (ofb)
in the output feedback (ofb) mode a block cipher is used to build a stream cipher
encryption scheme. this scheme is shown in fig. 5.5. note that in ofb mode the
key stream is not generated bitwise but instead in a blockwise fashion. the output
of the cipher gives us b key stream bits, where b is the width of the block cipher
used, with which we can encrypt b plaintext bits using the xor operation.
the idea behind the ofb mode is quite simple. we start with encrypting an iv
with a block cipher. the cipher output gives us the first set of b key stream bits.
the next block of key stream bits is computed by feeding the previous cipher output
back into the block cipher and encrypting it. this process is repeated as shown in
fig. 5.5.
the ofb mode forms a synchronous stream cipher (cf. fig. 2.3) as the key stream
does not depend on the plain or ciphertext. in fact, using the ofb mode is quite similar to using a standard stream cipher such as rc4 or trivium. since the ofb mode
forms a stream cipher, encryption and decryption are exactly the same operation.
as can be seen in the right-hand part of fig. 5.5, the receiver does not use the block
cipher in decryption mode e1 () to decrypt the ciphertext. this is because the actual
encryption is performed by the xor function, and in order to reverse it, i.e., to decrypt it, we simply have to perform another xor function on the receiver side. this
is in contrast to ecb and cbc mode, where the data is actually being encrypted and
decrypted by the block cipher.
encryption and decryption using the ofb scheme is as follows

5.1 encryption with block ciphers modes of operation














131







fig. 5.5 encryption and decryption in ofb mode

definition 5.1.3 output feedback mode (ofb)
let e() be a block cipher of block size b let xi , yi and si be bit
strings of length b and iv be a nonce of length b.
encryption (first block) s1  ek (iv ) and y1  s1  x1
encryption (general block) si  ek (si1 ) and yi  si  xi , i  2
decryption (first block) s1  ek (iv ) and x1  s1  y1
decryption (general block) si  ek (si1 ) and xi  si  yi , i  2
as a result of the use of an iv, the ofb encryption is also nondeterministic,
hence, encrypting the same plaintext twice results in different ciphertexts. as in the
case for the cbc mode, the iv should be a nonce. one advantage of the ofb mode
is that the block cipher computations are independent of the plaintext. hence, one
can precompute one or several blocks si of key stream material.

5.1.4 cipher feedback mode (cfb)
the cipher feedback (cfb) mode also uses a block cipher as a building block for a
stream cipher. it is similar to the ofb mode but instead of feeding back the output
of the block cipher, the ciphertext is fed back. (hence, a somewhat more accurate
term for this mode would have been ciphertext feedback mode.) as in the ofb
mode, the key stream is not generated bitwise but instead in a blockwise fashion.
the idea behind the cfb mode is as follows to generate the first key stream block
s1 , we encrypt an iv. for all subsequent key stream blocks s2 , s3 , . . ., we encrypt the
previous ciphertext. this scheme is shown in fig. 5.6.
since the cfb mode forms a stream cipher, encryption and decryption are exactly
the same operation. the cfb mode is an example of an asynchronous stream cipher
(cf. fig. 2.3) since the stream cipher output is also a function of the ciphertext.
the formal description of the cfb mode follows

132

5 more about block ciphers





















fig. 5.6 encryption and decryption in cfb mode

definition 5.1.4 cipher feedback mode (cfb)
let e() be a block cipher of block size b let xi and yi be bit strings
of length b and iv be a nonce of length b.
encryption (first block) y1  ek (iv )  x1
encryption (general block) yi  ek (yi1 )  xi , i  2
decryption (first block) x1  ek (iv )  y1
decryption (general block) xi  ek (yi1 )  yi , i  2
as a result of the use of an iv, the cfb encryption is also nondeterministic,
hence, encrypting the same plaintext twice results in different ciphertexts. as in the
case for the cbc and ofb modes, the iv should be a nonce.
a variant of the cfb mode can be used in situations where short plaintext blocks
are to be encrypted. lets use the encryption of the link between a (remote) keyboard and a computer as an example. the plaintexts generated by the keyboard are
typically only 1 byte long, e.g., an ascii character. in this case, only 8 bits of the
key stream are used for encryption (it does not matter which ones we choose as they
are all secure), and the ciphertext also only consists of 1 byte. the feedback of the
ciphertext as input to the block cipher is a bit tricky. the previous block cipher input
is shifted by 8 bit positions to the left, and the 8 least significant positions of the input register are filled with the ciphertext byte. this process repeats. of course, this
approach works not only for plaintext blocks of length 8, but for any lengths shorter
than the cipher output.

5.1.5 counter mode (ctr)
another mode which uses a block cipher as a stream cipher is the counter (ctr)
mode. as in the ofb and cfb modes, the key stream is computed in a blockwise
fashion. the input to the block cipher is a counter which assumes a different value
every time the block cipher computes a new key stream block. figure 5.7 shows the
principle.
we have to be careful how to initialize the input to the block cipher. we must
prevent using the same input value twice. otherwise, if an attacker knows one of

5.1 encryption with block ciphers modes of operation




133
 







fig. 5.7 encryption and decryption in counter mode

the two plaintexts that were encrypted with the same input, he can compute the key
stream block and thus immediately decrypt the other ciphertext. in order to achieve
this uniqueness, often the following approach is taken in practice. lets assume a
block cipher with an input width of 128 bits, such as an aes. first we choose
an iv that is a nonce with a length smaller than the block length, e.g., 96 bits.
the remaining 32 bits are then used by a counter with the value ct r which is
initialized to zero. for every block that is encrypted during the session, the counter
is incremented but the iv stays the same. in this example, the number of blocks we
can encrypt without choosing a new iv is 232 . since every block consists of 8 bytes,
a maximum of 8  232  235 bytes, or about 32 gigabytes, can be encrypted before
a new iv must be generated. here is a formal description of the counter mode with
a cipher input construction as just introduced
definition 5.1.5 counter mode (ctr)
let e() be a block cipher of block size b, and let xi and yi be bit
strings of length b. the concatenation of the initialization value iv
and the counter ct ri is denoted by (iv ct ri ) and is a bit string
of length b.
encryption yi  ek (iv ct ri )  xi , i  1
decryption xi  ek (iv ct ri )  yi , i  1
please note that the string (iv ct r1 ) does not have to be kept secret. it can, for
instance, be generated by alice and sent to bob together with the first ciphertext
block. the counter ct r can either be a regular integer counter or a slightly more
complex function such as a maximum-length lfsr.
one might wonder why so many modes are needed. one attractive feature of the
counter mode is that it can be parallelized because, unlike the ofb or cfb mode, it
does not require any feedback. for instance, we can have two block cipher engines
running in parallel, where the first block cipher encrypts the counter value ct r1 and
the other ct r2 at the same time. when the two block cipher engines are finished,
the first engine encrypts the value ct r3 and the other one ct r4 , and so on. this
scheme would allow us to encrypt at twice the data rate of a single implementation.
of course, we can have more than two block ciphers running in parallel, increasing
the speed-up proportionally. for applications with high throughput demands, e.g.,

134

5 more about block ciphers

in networks with data rates in the range of gigabits per second, encryption modes
that can be parallelized are very desirable.

5.1.6 galois counter mode (gcm)
the galois counter mode (gcm) is an encryption mode which also computes a
message authentication code (mac) [160]. a mac provides a cryptographic checksum that is computed by the sender, alice, and appended to the message. bob also
computes a mac from the message and checks whether his mac is the same as
the one computed by alice. this way, bob can make sure that (1) the message was
really created by alice and (2) that nobody tampered with the ciphertext during
transmission. these two properties are called message authentication and integrity,
respectively. much more about macs is found in chap. 12. we presented a slightly
simplified version of the gcm mode in the following.
gcm protects the confidentiality of the plaintext x by using an encryption in
counter mode. additionally, gcm protects not only the authenticity of the plaintext
x but also the authenticity of a string aad called additional authenticated data.
this authenticated data is, in contrast to the plaintext, left in clear in this mode of
operation. in practice, the string aad might include addresses and parameters in a
network protocol.
the gcm consists of an underlying block cipher and a galois field multiplier
with which the two gcm functions authenticated encryption and authenticated decryption are realized. the cipher needs to have a block size of 128 bits such as aes.
on the sender side, gcm encrypts data using the counter mode (ctr) followed by
the computation of a mac value. for encryption, first an initial counter is derived
from an iv and a serial number. then the initial counter value is incremented, and
this value is encrypted and xored with the first plaintext block. for subsequent
plaintexts, the counter is incremented and then encrypted. note that the underlying
block cipher is only used in encryption mode. gcm allows for precomputation of
the block cipher function if the initialization vector is known ahead of time.
for authentication, gcm performs a chained galois field multiplication. for every plaintext xi an intermediate authentication parameter gi is derived. gi is computed as the xor sum of the current ciphertext yi and gi , and multiplied by the
constant h. the value h is a hash subkey which is generated by encryption of the
all-zero input with the block cipher. all multiplications are in the 128-bit galois
field gf(2128 ) with the irreducible polynomial p(x)  x128 + x7 + x2 + x + 1. since
only one multiplication is required per block cipher encryption, the gcm mode adds
very little computational overhead to the encryption.

5.1 encryption with block ciphers modes of operation

135

definition 5.1.6 basic galois counter mode (gcm)
let e() be a block cipher of block size 128 bit let x be the plaintext
consisting of the blocks x1 , . . . , xn  and let aad be the additional
authenticated data.
1. encryption
a. derive a counter value ct r0 from the iv and compute
ct r1  ct r0 + 1.
b. compute ciphertext yi  ek (ct ri )  xi , i  1
2. authentication
a. generate authentication subkey h  ek (0)
b. compute g0  aad  h (galois field multiplication)
c. compute gi  (gi1  yi )  h, 1  i  n (galois field
multiplication)
d. final authentication tag t  (gn  h)  ek (ct r0 )
figure 5.8 shows a diagram of the gcm.





































fig. 5.8 basic authenticated encryption in galois counter mode

the receiver of the packet [(y1 , . . . , yn ), t, add] decrypts the ciphertext by also
applying the counter mode. to check the authenticity of the data, the receiver also
computes an authentication tag t using the received ciphertext and add as input.
he employs exactly the same steps as the sender. if t and t match, the receiver is

136

5 more about block ciphers

assured that the cipertext (and add) were not manipulated in transit and that only
the sender could have generated the message.

5.2 exhaustive key search revisited
in sect. 3.5.1 we saw that given a plaintextciphertext pair (x1 , y1 ) a des key can
be exhaustively searched using the simple algorithm


deski (x1 )  y1 ,

i  0, 1, . . . , 256  1.

(5.1)

for most other block ciphers, however, a key search is somewhat more complicated.
somewhat surprisingly, a brute-force attack can produce false positive results, i.e.,
keys ki are found that are not the one used for the encryption, yet they perform a
correct encryption in eq. (5.1). the likelihood of this occurring is related to the
relative size of the key space and the plaintext space.
a brute-force attack is still possible, but several pairs of plaintextciphertext are
needed. the length of the respective plaintext required to break the cipher with a
brute-force attack is referred to as unicity distance. after trying every possible key,
there should be just one plaintext that makes sense.
lets first look why one pair (x1 , y1 ) might not be sufficient to identify the correct
key. for illustration purposes we assume a cipher with a block width of 64 bit and a
key size of 80 bit. if we encrypt x1 under all possible 280 keys, we obtain 280 ciphertexts. however, there exist only 264 different ones, and thus some keys must map x1
to the same ciphertext. if we run through all keys for a given plaintextciphertext
pair, we find on average 280 /264  216 keys that perform the mapping ek (x1 )  y1 .
this estimation is valid since the encryption of a plaintext for a given key can be
viewed as a random selection of a 64-bit ciphertext string. the phenomenon of multiple paths between a given plaintext and ciphertext is depicted in fig. 5.9, in
which k(i) denote the keys that map x1 to y1 . these keys can be considered key
candidates.



  









    

fig. 5.9 multiple keys map between one plaintext and one ciphertext

5.3 increasing the security of block ciphers

137

among the approximately 216 key candidates k(i) is the correct one that was used
by to perform the encryption. lets call this one the target key. in order to identify
the target key we need a second plaintextciphertext pair (x2 , y2 ). again, there are
about 216 key candidates that map x2 to y2 . one of them is the target key. the other
keys can be viewed as randomly drawn from the 280 possible ones. it is crucial to
note that the target key must be present in both sets of key candidates. to determine
the effectiveness of a brute-force attack, the crucial question is now what is the
likelihood that another (false) key is contained in both sets the answer is given by
the following theorem
theorem 5.2.1 given a block cipher with a key length of  bits
and block size of n bits, as well as t plaintextciphertext pairs
(x1 , y1 ), . . . , (xt , yt ), the expected number of false keys which encrypt all plaintexts to the corresponding ciphertexts is
2 tn
returning to our example and assuming two plaintextciphertext pairs, the likelihood of a false key k f that performs both encryptions ek f (x1 )  y1 and ek f (x2 )  y2
is
280264  248
this value is so small that for almost all practical purposes it is sufficient to test two
plaintextciphertext pairs. if the attacker chooses to test three pairs, the likelihood
of a false key decreases to 280364  2112 . as we saw from this example, the likelihood of a false alarm decreases rapidly with the number t of plaintextciphertext
pairs. in practice, typically we only need a few pairs.
the theorem above is not only important if we consider an individual block cipher but also if we perform multiple encryptions with a cipher. this issue is addressed in the following section.

5.3 increasing the security of block ciphers
in some situations we wish to increase the security of block ciphers, e.g., if a cipher such as des is available in hardware or software for legacy reasons in a given
application. we discuss two general approaches to strengthen a cipher, multiple encryption and key whitening. multiple encryption, i.e., encrypting a plaintext more
than once, is already a fundamental design principle of block ciphers, since the
round function is applied many times to the cipher. our intuition tells us that the
security of a block cipher against both brute-force and analytical attacks increases
by performing multiple encryptions in a row. even though this is true in principle,
there are a few surprising facts. for instance, doing double encryption does very
little to increase the brute-force resistance over a single encryption. we study this

138

5 more about block ciphers

counterintuitive fact in the next section. another very simple yet effective approach
to increase the brute-force resistance of block ciphers is called key whitening it is
also discussed below.
we note here that when using aes, we already have three different security levels
given by the key lengths of 128, 192 and 256 bits. given that there are no realistic
attacks known against aes with any of those key lengths, there appears no reason
to perform multiple encryption with aes for practical systems. however, for some
selected older ciphers, especially for des, multiple encryption can be a useful tool.

5.3.1 double encryption and meet-in-the-middle attack
lets assume a block cipher with a key length of  bits. for double encryption, a
plaintext x is first encrypted with a key kl , and the resulting ciphertext is encrypted
again using a second key kr . this scheme is shown in fig. 5.10.

























fig. 5.10 double encryption and meet-in-the-middle attack

a nave brute-force attack would require us to search through all possible combinations of both keys, i.e., the effective key lengths would be 2 and an exhaustive
key search would require 2  2  22 encryptions (or decryptions). however, using
the meet-in-the-middle attack, the key space is drastically reduced. this is a divideand-conquer attack in which oscar first brute-force-attacks the encryption on the
left-hand side, which requires 2 cipher operations, and then the right encryption,
which again requires 2 operations. if he succeeds with this attack, the total complexity is 2 + 2  2  2  2 +1 . this is barely more complex than a key search of
a single encryption and of course is much less complex than performing 22 search
operations.
the attack has two phases. in the first one, the left encryption is brute-forced and
a lookup table is computed. in the second phase the attacker tries to find a match in
the table which reveals both encryption keys. here are the details of this approach.

5.3 increasing the security of block ciphers

139

phase i table computation for a given plaintext x1 , compute a lookup table for
all pairs (kl,i , zl,i ), where ekl,i (x1 )  zl,i and i  1, 2, . . . , 2 . these computations
are symbolized by the left arrow in the figure. the zl,i are the intermediate values
that occur in between the two encryptions. this list should be ordered by the values
of the zl,i . the number of entries in the table is 2 , with each entry being n +  bits
wide. note that one of the keys we used for encryption must be the correct target
key, but we still do not know which one it is.
phase ii key matching in order to find the key, we now decrypt y1 , i.e., we
perform the computations symbolized by the right arrow in the figure. we select the
first possible key kr,1 , e.g., the all-zero key, and compute
e1
kr,1 (x1 )  zr,1 .
we now check whether zr,1 is equal to any of the zl,i values in the table which we
computed in the first phase. if it is not in the table, we increment the key to kr,1 ,
decrypt y1 again, and check whether this value is in the table. we continue until we
have a match.
we now have what is called a collision of two values, i.e., zl,i  zr, j . this gives
us two keys the value zl,i is associated with the key kl,i from the left encryption,
and kr, j is the key we just tested from the right encryption. this means there exists
a key pair (kl,i , kr, j ) which performs the double encryption
ekr, j (ekl,i (x1 ))  y1

(5.2)

as discussed in sect. 5.2, there is a chance that this is not the target key pair we
are looking for since there are most likely several possible key pairs that perform
the mapping x1  y1 . hence, we have to verify additional key candidates by encrypting several plaintextciphertext pairs according to eq. (5.2). if the verification
fails for any of the pairs (x1 , y1 ), (x2 , y2 ), . . ., we go back to beginning of phase ii
and increment the key kr again and continue with the search.
lets briefly discuss how many plaintextciphertext pairs we will need to rule
out faulty keys with a high likelihood. with respect to multiple mappings between a
plaintext and a ciphertext as depicted in fig. 5.9, double encryption can be modeled
as a cipher with 2 key bits and n block bits. in practice, one often has 2  n,
in which case we need several plaintextciphertext pairs. the theorem in sect. 5.2
can easily be adopted to the case of multiple encryption, which gives us a useful
guideline about how many (x, y) pairs should be available
theorem 5.3.1 given are l subsequent encryptions with a block
cipher with a key length of  bits and block size of n bits, as well as
t plaintextciphertext pairs (x1 , y1 ), . . . , (xt , yt ). the expected number of false keys which encrypt all plaintexts to the corresponding
ciphertexts is given by
2l  tn

140

5 more about block ciphers

lets look at an example.
example 5.3. as an example, if we double-encrypt with des and choose to test
three plaintextciphertext pairs, the likelihood of a faulty key pair surviving all three
key tests is
2256364  280 .

let us examine the computational complexity of the meet-in-the-middle attack.
in the first phase of the attack, corresponding to the left arrow in the figure, we perform 2 encryptions and store them in 2 memory locations. in the second stage,
corresponding to the right arrow in the figure, we perform a maximum of 2 decryptions and table look-ups. we ignore multiple key tests at this stage. the total cost
for the meet-in-the-middle attack is
number of encryptions and decryptions  2 + 2  2 +1
number of storage locations  2
this compares to 2 encryptions or decryptions and essentially no storage cost in
the case of a brute-force attack against a single encryption. even though the storage
requirements go up quite a bit, the costs in computation and memory are still only
proportional to 2 . thus, it is widely believed that double encryption is not worth
the effort. instead, triple encryption should be used this method is described in the
following section.
note that for a more exact complexity analysis of the meet-in-the-middle attack,
we would also need take the cost of sorting the table entries in phase i into account
as well as the table look-ups in phase ii. for our purposes, however, we can ignore
these additional costs.

5.3.2 triple encryption
compared to double encryption, a much more secure approach is the encryption of
a block of data three times in a row
y  ek3 (ek2 (ek1 (x))).
in practice, often a variant of the triple encryption from above is used
y  ek1 (e1
k2 (ek3 (x))).
this type of triple encryption is sometimes referred to as encryptiondecryption
encryption (ede). the reason for this has nothing to do with security. if k1  k2 ,
the operation effectively performed is
y  ek3 (x),

5.3 increasing the security of block ciphers

141

which is single encryption. since it is sometimes desirable that one implementation
can perform both triple encryption and single encryption, i.e., in order to interoperate with legacy systems, ede is a popular choice for triple encryption. moreover,
for a 112-bit security, it is sufficient to choose two different keys k1 and k2 and set
k3  k1 in case of 3des.
of course, we can still perform a meet-in-the-middle attack as shown in fig. 5.11.



  

























fig. 5.11 triple encryption and sketch of a meet-in-the-middle attack

again, we assume  bits per key. the problem for an attacker is that she has to
compute a lookup table either after the first or after the second encryption. in both
cases, the attacker has to compute two encryptions or decryptions in a row in order
to reach the lookup table. here lies the cryptographic strength of triple encryption
there are 22k possibilities to run through all possible keys of two encryptions or
decryptions. in the case of 3des, this forces an attacker to perform 2112 key tests,
which is entirely infeasible with current technology. in summary, the meet-in-themiddle attack reduces the effective key length of triple encryption from 3  to 2  .
because of this, it is often said that the effective key length of triple des is 112 bits
as opposed to 3  56  168 bits which are actually used as input to the cipher.

5.3.3 key whitening
using an extremely simple technique called key whitening, it is possible to make
block ciphers such as des much more resistant against brute-force attacks. the
basic scheme is shown in fig. 5.12.
in addition to the regular cipher key k, two whitening keys k1 and k2 are used to
xor-mask the plaintext and ciphertext. this process can be expressed as

142

5 more about block ciphers













fig. 5.12 key whitening of a block cipher

definition 5.3.1 key whitening for block ciphers
encryption y  ek,k1 ,k2 (x)  ek (x  k1 )  k2 .
1
decryption x  e1
k,k1 ,k2 (x)  ek (y  k2 )  k1
it is important to stress that key whitening does not strengthen block ciphers
against most analytical attacks such as linear and differential cryptanalysis. this
is in contrast to multiple encryption, which often also increases the resistance to
analytical attacks. hence, key whitening is not a cure for inherently weak ciphers.
its main application is ciphers that are relatively strong against analytical attacks
but possess too short a key space. the prime example of such a cipher is des. a
variant of des which uses key whitening is desx. in the case of desx, the key k2
is derived from k and k1 . please note that most modern block ciphers such as aes
already apply key whitening internally by adding a subkey prior to the first round
and after the last round.
lets now discuss the security of key whitening. a nave brute-force attack
against the scheme requires 2 +2n search steps, where  is the bit length of the key
and n the block size. using the meet-in-the-middle attack introduced in sect. 5.3,
the computational load can be reduced to approximately 2 +n steps, plus storage
of 2n data sets. however, if the adversary oscar can collect 2m plaintextciphertext
pairs, a more advanced attack exists with a computational complexity of
2 +nm
cipher operations. even though we do not introduce the attack here, well briefly
discuss its consequences if we apply key whitening to des. we assume that the attacker knows 2m plaintextciphertext pairs. note that the designer of a security system can often control how many plaintextciphertext are generated before a new key
is established. thus, the parameter m cannot be arbitrarily increased by the attacker.
also, since the number of known plaintexts grows exponentially with m, values beyond, say, m  40, seem quite unrealistic. as a practical example, lets assume key
whitening of des, and that oscar can collect a maximum of 232 plaintexts. he now
has to perform
256+6432  288

5.4 discussion and further reading

143

des computations. given that with todays technology even 256 des operations require several days with special hardware, performing 288 encryptions is completely
out of reach. note that the number of plaintexts (which oscar is not supposed to
know in most circumstances) corresponds to 32 gbyte of data, the collection of
which is also a formidable task in most real-world situations.
a particular attractive feature of key whitening is that the additional computational load is negligible. a typical block cipher implementation in software requires
several hundred instructions for encrypting one input block. in contrast, a 64-bit
xor operation only takes 2 instructions on a 32-bit machine, so that the performance impact due to key whitening is in the range of 1% or less in most cases.

5.4 discussion and further reading
modes of operation after the aes selection process, the us national institute of
standards and technology (nist) supported the process of evaluating new modes of
operations in a series of special publications and workshops [124]. currently, there
are eight approved block cipher modes five for confidentiality (ecb, cbc, cfb,
ofb, ctr), one for authentication (cmac) and two combined modes for confidentiality and authentication (ccm, gcm). the modes are widely used in practice
and are part of many standards, e.g., for computer networks or banking.
other applications for block ciphers the most important application of block
ciphers in practice, in addition to data encryption, is message authentication codes
(macs), which are discussed in chap. 12. the schemes cbc-mac, omac and
pmac are constructed with a block cipher. authenticated encryption (ae) uses
block ciphers to both encrypt and generate a mac in order to provide confidentiality
and authentication, respectively. in addition to the gcm introduced in this chapter,
other ae modes include the eax mode, ocb mode, and gc mode.
another application is the cryptographically secure pseudo random number
generators (csprng) built from block ciphers. in fact, the stream cipher modes
introduced in this chapter, ofb, cfb and ctr mode, form csprngs. there are
also standards such as [4, appendix a.2.4] which explicitly specify random number
generators from block ciphers.
block ciphers can also be used to build cryptographic hash functions, as discussed in chap. 11.
extending brute-force attacks even though there are no algorithmic shortcuts
to brute-force attacks, there are methods which are efficient if several exhaustive key
searches have to be performed. those methods are called timememory tradeoff attacks (tmto). the general idea is to encrypt a fixed plaintext under a large number
of keys and to store certain intermediate results. this is the precomputation phase,
which is typically at least as complex as a single brute-force attack and which results
in large lookup tables. in the online phase, a search through the tables takes place
which is considerably faster than a brute-force attack. thus, after the precomputa-

144

5 more about block ciphers

tion phase, individual keys can be found much more quickly. tmto attacks were
originally proposed by hellman [91] and were improved with the introduction of
distinguished points by rivest [145]. more recently rainbow tables were proposed
to further improve tmto attacks [131]. a limiting factor of tmto attacks in practice is that for each individual attack it is required that the same piece of known
plaintext was encrypted, e.g., a file header.
block ciphers and quantum computers with the potential rise of quantum
computers in the future, the security of currently used crypto algorithms has to be
reevaluated. (it should be noted that the possible existence of quantum computers in
a few decades from now is hotly debated.) whereas all popular existing asymmetric
algorithms such as rsa are vulnerable to attacks using quantum computers [153],
symmetric algorithms are much more resilient. a potential quantum computer using grovers algorithm [87] would require only 2(n/2) steps in order to perform a
complete key search on a cipher with a keyspace of 2n elements. hence, key lengths
of more than 128 bit are required if resistance against quantum computer attacks
is desired. this observation was also the motivation for requiring the 192-bit and
256-bit key lengths for aes. interestingly, it can be shown that there can be no
quantum algorithm which performs such an attack more efficiently than grovers
algorithm [16].

5.5 lessons learned









there are many different ways to encrypt with a block cipher. each mode of
operation has some advantages and disadvantages.
several modes turn a block cipher into a stream cipher.
there are modes that perform encryption together together with authentication,
i.e., a cryptographic checksum protects against message manipulation.
the straightforward ecb mode has security weaknesses, independent of the underlying block cipher.
the counter mode allows parallelization of encryption and is thus suited for highspeed implementations.
double encryption with a given block cipher only marginally improves the resistance against brute-force attacks.
triple encryption with a given block cipher roughly doubles the key length.
triple des (3des) has an effective key length of 112 bits.
key whitening enlarges the des key length without much computational overhead.

problems

145

problems
5.1. consider the storage of data in encrypted form in a large database using aes.
one record has a size of 16 bytes. assume that the records are not related to one
another. which mode would be best suited and why
5.2. we consider known-plaintext attacks on block ciphers by means of an exhaustive key search where the key is k bits long. the block length counts n bits with
n  k.
1. how many plaintexts and ciphertexts are needed to successfully break a block
cipher running in ecb mode how many steps are done in the worst case
2. assume that the initialization vector iv for running the considered block cipher
in cbc mode is known. how many plaintexts and ciphertexts are now needed to
break the cipher by performing an exhaustive key search how many steps need
now maximally be done briefly describe the attack.
3. how many plaintexts and ciphertexts are necessary, if you do not know the iv
4. is breaking a block cipher in cbc mode by means of an exhaustive key search
considerably more difficult than breaking an ecb mode block cipher
5.3. in a company, all files which are sent on the network are automatically encrypted by using aes-128 in cbc mode. a fixed key is used, and the iv is changed
once per day. the network encryption is file-based, so that the iv is used at the
beginning of every file.
you managed to spy out the fixed aes-128 key, but do not know the recent iv.
today, you were able to eavesdrop two different files, one with unidentified content
and one which is known to be an automatically generated temporary file and only
contains the value 0xff. briefly describe how it is possible to obtain the unknown
initialization vector and how you are able to determine the content of the unknown
file.
5.4. keeping the iv secret in ofb mode does not make an exhaustive key search
more complex. describe how we can perform a brute-force attack with unknown iv.
what are the requirements regarding plaintext and ciphertext
5.5. describe how the ofb mode can be attacked if the iv is not different for each
execution of the encryption operation.
5.6. propose an ofb mode scheme which encrypts one byte of plaintext at a time,
e.g., for encrypting key strokes from a remote keyboard. the block cipher used is
aes. perform one block cipher operation for every new plaintext byte. draw a block
diagram of your scheme and pay particular attention to the bit lengths used in your
diagram (cf. the descripton of a byte mode at the end of sect. 5.1.4).
5.7. as is so often true in cryptography, it is easy to weaken a seemingly strong
scheme by small modifications. assume a variant of the ofb mode by which we
only feed back the 8 most significant bits of the cipher output. we use aes and fill
the remaining 120 input bits to the cipher with 0s.

146

5 more about block ciphers

1. draw a block diagram of the scheme.
2. why is this scheme weak if we encrypt moderately large blocks of plaintext, say
100 kbyte what is the maximum number of known plaintexts an attacker needs
to completely break the scheme
3. let the feedback byte be denoted by fb. does the scheme become cryptographically stronger if we feedback the 128-bit value fb, fb, . . . , fb to the input (i.e.,
we copy the feedback byte 16 times and use it as aes input)
5.8. in the text, a variant of the cfb mode is proposed which encrypts individual
bytes. draw a block diagram for this mode when using aes as block cipher. indicate
the width (in bit) of each line in your diagram.
5.9. we are using aes in counter mode for encrypting a hard disk with 1 tb of
capacity. what is the maximum length of the iv
5.10. sometimes error propagation is an issue when choosing a mode of operation
in practice. in order to analyze the propagation of errors, let us assume a bit error
(i.e., a substitution of a 0 bit by a 1 bit or vice versa) in a ciphertext block yi .
1. assume an error occurs during the transmission in one block of ciphertext, lets
say yi . which cleartext blocks are affected on bobs side when using the ecb
mode
2. again, assume block yi contains an error introduced during transmission. which
cleartext blocks are affected on bobs side when using the cbc mode
3. suppose there is an error in the cleartext xi on alices side. which cleartext
blocks are affected on bobs side when using the cbc mode
4. assume a single bit error occurs in the transmission of a ciphertext character in
8-bit cfb mode. how far does the error propagate describe exactly how each
block is affected.
5. prepare an overview of the effect of bit errors in a ciphertext block for the modes
ecb, cbc, cfb, ofb and ctr. differentiate between random bit errors and
specific bit errors when decrypting yi .
5.11. besides simple bit errors, the deletion or insertion of a bit yields even more
severe effects since the synchronization of blocks is disrupted. in most cases, the
decryption of subsequent blocks will be incorrect. a special case is the cfb mode
with a feedback width of 1 bit. show that the synchronization is automatically restored after  + 1 steps, where  is the block size of the block cipher.
5.12. we now analyze the security of des double encryption (2des) by doing a
cost-estimate
2des(x)  desk2 (desk1 (x))
1. first, let us assume a pure key search without any memory usage. for this purpose, the whole key space spanned by k1 and k2 has to be searched. how much
does a key-search machine for breaking 2des (worst case) in 1 week cost
in this case, assume asics which can perform 107 keys per second at a cost of
5 per ic. furthermore, assume an overhead of 50% for building the key search
machine.

problems

147

2. let us now consider the meet-in-the-middle (or time-memory tradeoff) attack, in
which we can use memory. answer the following questions




how many entries have to be stored
how many bytes (not bits) have to be stored for each entry
how costly is a key search in one week please note that the key space has to
be searched before filling up the memory completely. then we can begin to
search the key space of the second key. assume the same hardware for both
key spaces.

for a rough cost estimate, assume the following costs for hard disk space
8/10 gbyte, where 1 gbyte  109 byte.
3. assuming moores law, when do the costs move below 1 million
5.13. imagine that aliens  rather than abducting earthlings and performing strange
experiments on them  drop a computer on planet earth that is particularly suited
for aes key searches. in fact, it is so powerful that we can search through 128, 192
and 256 key bits in a matter of days. provide guidelines for the number of plaintext
ciphertext pairs the aliens need so that they can rule out false keys with a reasonable
likelihood. (remark since the existence of both aliens and human-built computers
for such key lengths seem extremely unlikely at the time of writing, this problem is
pure science fiction.)
5.14. given multiple plaintextciphertext pairs, your objective is to attack an encryption scheme based upon multiple encryptions.
1. you want to break an encryption system e, which makes use of triple aes-192
encryption (e.g. block length n  128 bit, key size of k  192 bit). how many
tuples (xi , yi ) with yi  ek (xi ) do you need to level down the probability of finding
a key k, which matches the condition yi  ek (xi ) for one particular i, but fails
for most other values of i (a so called false positive), to pr(k  k)  220 
2. what is the maximum key size of a block cipher that you could still effectively
attack with an error probability of at most pr(k  k)  210  1/1024, if this
cipher always uses double encryption (l  2) and has a block length of n  80
bit
3. estimate the success probability, if you are provided with four plaintextciphertext
blocks which are double encrypted using aes-256 (n  128 bits, k  256 bits).
please justify your results.
note that this is a purely theoretical problem. key spaces of size 2128 and beyond
can not be brute-forced.
5.15. 3des with three different keys can be broken with about 22k encryptions
and 2k memory cells, k  56. design the corresponding attack. how many pairs
(x, y) should be available so that the probability to determine an incorrect key triple
(k1 , k2 , k3 ) is sufficiently low

148

5 more about block ciphers

5.16. this is your chance to break a cryptosystem. as we know by now, cryptography is a tricky business. the following problem illustrates how easy it is to turn a
strong scheme into a weak one with minor modifications.
we saw in this chapter that key whitening is a good technique for strengthening
block ciphers against brute-force attacks. we now look at the following variant of
key whitening against des, which well call desa
desak,k1 (x)  desk (x)  k1 .
even though the method looks similar to key whitening, it hardly adds to the security. your task is to show that breaking the scheme is roughly as difficult as a
brute-force attack against single des. assume you have a few pairs of plaintext
ciphertext.

chapter 6

introduction to public-key cryptography

before we learn about the basics of public-key cryptography, let us recall that the
term public-key cryptography is used interchangeably with asymmetric cryptography they both denote exactly the same thing and are used synonymously.
as stated in chap. 1, symmetric cryptography has been used for at least 4000
years. public-key cryptography, on the other hand, is quite new. it was publicly
introduced by whitfield diffie, martin hellman and ralph merkle in 1976. much
more recently, in 1997 british documents which were declassified revealed that the
researchers james ellis, clifford cocks and graham williamson from the uks
government communications headquarters (gchq) discovered and realized the
principle of public-key cryptography a few years earlier, in 1972. however, it is
still being debated whether the government office fully recognized the far-reaching
consequences of public-key cryptography for commercial security applications.
in this chapter you will learn




a brief history of public-key cryptography
the pros and cons of public-key cryptography
some number theoretical topics that are needed for understanding public-key
algorithms, most importantly the extended euclidean algorithm

c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 6, 

149

150

6 introduction to public-key cryptography

6.1 symmetric vs. asymmetric cryptography
in this chapter we will see that asymmetric, i.e., public-key, algorithms are very different from symmetric algorithms such as aes or des. most public-key algorithms
are based on number-theoretic functions. this is quite different from symmetric ciphers, where the goal is usually not to have a compact mathematical description
between input and output. even though mathematical structures are often used for
small blocks within symmetric ciphers, for instance, in the aes s-box, this does
not mean that the entire cipher forms a compact mathematical description.

symmetric cryptography revisited
in order to understand the principle of asymmetric cryptography, let us first recall
the basic symmetric encryption scheme in fig. 6.1.





fig. 6.1 principle of symmetric-key encryption

such a system is symmetric with respect to two properties
1. the same secret key is used for encryption and decryption.
2. the encryption and decryption function are very similar (in the case of des they
are essentially identical).
there is a simple analogy for symmetric cryptography, as shown in fig. 6.2.
assume there is a safe with a strong lock. only alice and bob have a copy of the
key for the lock. the action of encrypting of a message can be viewed as putting the
message in the safe. in order to read, i.e., decrypt, the message, bob uses his key
and opens the safe.

fig. 6.2 analogy for symmetric encryption a safe with one lock

6.1 symmetric vs. asymmetric cryptography

151

modern symmetric algorithms such as aes or 3des are very secure, fast and
are in widespread use. however, there are several shortcomings associated with
symmetric-key schemes, as discussed below.
key distribution problem the key must be established between alice and bob
using a secure channel. remember that the communication link for the message is
not secure, so sending the key over the channel directly  which would be the most
convenient way of transporting it  cant be done.
number of keys even if we solve the key distribution problem, we must potentially deal with a very large number of keys. if each pair of users needs a separate
pair of keys in a network with n users, there are
n  (n  1)
2
key pairs, and every user has to store n  1 keys securely. even for mid-size networks, say, a corporation with 2000 people, this requires more than 4 million key
pairs that must be generated and transported via secure channels. more about this
problem is found in sect. 13.1.3. (there are smarter ways of dealing with keys
in symmetric cryptography networks as detailed in sect. 13.2 however, those approaches have other problems such as a single point of failure.)
no protection against cheating by alice or bob alice and bob have the same
capabilities, since they possess the same key. as a consequence, symmetric cryptography cannot be used for applications where we would like to prevent cheating by
either alice or bob as opposed to cheating by an outsider like oscar. for instance,
in e-commerce applications it is often important to prove that alice actually sent a
certain message, say, an online order for a flat screen tv. if we only use symmetric cryptography and alice changes her mind later, she can always claim that bob,
the vendor, has falsely generated the electronic purchase order. preventing this is
called nonrepudiation and can be achieved with asymmetric cryptography, as discussed in sect. 10.1.1. digital signatures, which are introduced in chap. 10, provide
nonrepudiation.

fig. 6.3 analogy for public-key encryption a safe with public lock for depositing a message and
a secret lock for retrieving a message

152

6 introduction to public-key cryptography

principles of asymmetric cryptography
in order to overcome these drawbacks, diffie, hellman and merkle had a revolutionary proposal based on the following idea it is not necessary that the key possessed
by the person who encrypts the message (thats alice in our example) is secret. the
crucial part is that bob, the receiver, can only decrypt using a secret key. in order
to realize such a system, bob publishes a public encryption key which is known to
everyone. bob also has a matching secret key, which is used for decryption. thus,
bobs key k consists of two parts, a public part, k pub , and a private one, k pr .
a simple analogy of such a system is shown in fig. 6.3. this systems works quite
similarly to the good old mailbox on the corner of a street everyone can put a letter
in the box, i.e., encrypt, but only a person with a private (secret) key can retrieve
letters, i.e., decrypt. if we assume we have cryptosystems with such a functionality,
a basic protocol for public-key encryption looks as shown in fig. 6.4.
alice

bob
k pub


y  ek pub (x)

(k pub , k pr )  k

y


x  dk pr (y)
fig. 6.4 basic protocol for public-key encryption

by looking at that protocol you might argue that even though we can encrypt a
message without a secret channel for key establishment, we still cannot exchange a
key if we want to encrypt with, say, aes. however, the protocol can easily be modified for this use. what we have to do is to encrypt a symmetric key, e.g., an aes
key, using the public-key algorithm. once the symmetric key has been decrypted
by bob, both parties can use it to encrypt and decrypt messages using symmetric
ciphers. figure 6.5 shows a basic key transport protocol where we use aes as the
symmetric cipher for illustration purposes (of course, one can use any other symmetric algorithm in such a protocol). the main advantage of the protocol in fig. 6.5
over the protocol in fig. 6.4 is that the payload is encrypted with a symmetric cipher,
which tends to be much faster than an asymmetric algorithm.
from the discussion so far, it looks as though asymmetric cryptography is a
desirable tool for security applications. the question remains how one can build
public-key algorithms. in chaps. 7, 8 and 9 we introduce most asymmetric schemes
of practical relevance. they are all built from one common principle, the one-way
function. the informal definition of it is as follows

6.2 practical aspects of public-key cryptography
alice

bob
k pub


choose random k
y  ek pub (k)

153

k pub , k pr

y


k  dk pr (y)
encrypt message x
z  aesk (x)

z


x  aesk1 (z)
fig. 6.5 basic key transport protocol with aes as an example of a symmetric cipher

definition 6.1.1 one-way function
a function f () is a one-way function if
1. y  f (x) is computationally easy, and
2. x  f 1 (y) is computationally infeasible.
obviously, the adjectives easy and infeasible are not particularly exact. in
mathematical terms, a function is easy to compute if it can be evaluated in polynomial time, i.e., its running time is a polynomial expression. in order to be useful in
practical crypto schemes, the computation y  f (x) should be sufficiently fast that
it does not lead to unacceptably slow execution times in an application. the inverse
computation x  f 1 (y) should be so computationally intensive that it is not feasible to evaluate it in any reasonable time period, say, 10,000 years, when using the
best known algorithm.
there are two popular one-way functions which are used in practical public-key
schemes. the first is the integer factorization problem, on which rsa is based.
given two large primes, it is easy to compute the product. however, it is very difficult to factor the resulting product. in fact, if each of the primes has 150 or more
decimal digits, the resulting product cannot be factored, even with thousands of pcs
running for many years. the other one-way function that is used widely is the discrete logarithm problem. this is not quite as intuitive and is introduced in chap. 8.

6.2 practical aspects of public-key cryptography
actual public-key algorithms will be introduced in the next chapters, since there is
some mathematics we must study first. however, it is very interesting to look at the
principal security functions of public-key cryptography which we address in this
section.

154

6 introduction to public-key cryptography

6.2.1 security mechanisms
as shown in the previous section, public-key schemes can be used for encryption of
data. it turns out that we can do many other, previously unimaginable, things with
public-key cryptography. the main functions that they can provide are listed below
main security mechanisms of public-key algorithms
key establishment there are protocols for establishing secret keys over
an insecure channel. examples for such protocols include the diffie
hellman key exchange (dhke) or rsa key transport protocols.
nonrepudiation providing nonrepudiation and message integrity can be
realized with digital signature algorithms, e.g., rsa, dsa or ecdsa.
identification we can identify entities using challenge-and-response protocols together with digital signatures, e.g., in applications such as smart
cards for banking or for mobile phones.
encryption we can encrypt messages using algorithms such as rsa or
elgamal.
we note that identification and encryption can also be achieved with symmetric
ciphers, but they typically require much more effort with key management. it looks
as though public-key schemes can provide all functions required by modern security
protocols. even though this is true, the major drawback in practice is that encryption
of data is very computationally intensive  or more colloquially extremely slow 
with public-key algorithms. many block and stream ciphers can encrypt about one
hundred to one thousand times faster than public-key algorithms. thus, somewhat
ironically, public-key cryptography is rarely used for the actual encryption of data.
on the other hand, symmetric algorithms are poor at providing nonrepudiation and
key establishment functionality. in order to use the best of both worlds, most practical protocols are hybrid protocols which incorporate both symmetric and public-key
algorithms. examples include the ssl/tls potocol that is commonly used for secure web connections, or ipsec, the security part of the internet communication
protocol.

6.2.2 the remaining problem authenticity of public keys
from the discussion so far weve seen that a major advantage of asymmetric
schemes is that we can freely distribute public keys, as shown in the protocols in
figs. 6.4 and 6.5. however, in practice, things are a bit more tricky because we still
have to assure the authenticity of public keys. in other words do we really know
that a certain public key belongs to a certain person in practice, this issue is often

6.2 practical aspects of public-key cryptography

155

solved with what is called certificates. roughly speaking, certificates bind a public
key to a certain identity. this is a major issue in many security application, e.g.,
when doing e-commerce transactions on the internet. we discuss this topic in more
detail in sect. 13.3.2.
another problem, which is not as fundamental, is that public-key algorithms require very long keys, resulting in slow execution times. the issue of key lengths and
security is discussed below.

6.2.3 important public-key algorithms
in the previous chapters, we learned about some block ciphers, des and aes. however, there exist many other symmetric algorithms. several hundred algorithms have
been proposed over the years and even though a lot were found not to be secure,
there exist many cryptographically strong ones as discussed in sect. 3.7. the situation is quite different for asymmetric algorithms. there are only three major families of public-key algorithms which are of practical relevance. they can be classified
based on their underlying computational problem.
public-key algorithm families of practical relevance
integer-factorization schemes several public-key schemes are based on
the fact that it is difficult to factor large integers. the most prominent representative of this algorithm family is rsa.
discrete logarithm schemes there are several algorithms which are
based on what is known as the discrete logarithm problem in finite fields.
the most prominent examples include the diffiehellman key exchange,
elgamal encryption or the digital signature algorithm (dsa).
elliptic curve (ec) schemes a generalization of the discrete logarithm
algorithm are elliptic curve public-key schemes. the most popular examples include elliptic curve diffiehellman key exchange (ecdh) and the
elliptic curve digital signature algorithm (ecdsa).
the first two families were proposed in the mid-1970s, and elliptic curves were
proposed in the mid-1980s. there are no known attacks against any of the schemes
if the parameters, especially the operand and key lengths, are chosen carefully. algorithms belonging to each of the families will be introduced in chaps. 7, 8 and
9. it is important to note that each of the three families can be used to provide the
main public-key mechanisms of key establishment, nonrepudiation through digital
signatures and encryption of data.
in addition to the three families above, there have been proposals for several
other public-key schemes. they often lack cryptographic maturity, i.e., it is not
known how robust they are against mathematical attacks. multivariate quadratic

156

6 introduction to public-key cryptography

(mq) or some lattice-based schemes are examples of this. another common problem is that they have poor implementation characteristics, like key lengths in the
range of megabytes, e.g., the mceliece cryptosystems. however, there are also some
other schemes, for instance, hyperelliptic curve cryptosystems, which are both as efficient and secure as the three established families shown above, but which simply
have not gained widespread adoption. for most applications it is recommended to
use public-key schemes from the three established algorithm families.

6.2.4 key lengths and security levels
all three of the established public-key algorithm families are based on numbertheoretic functions. one distinguishing feature of them is that they require arithmetic with very long operands and keys. not surprisingly, the longer the operands
and keys, the more secure the algorithms become. in order to compare different
algorithms, one often considers the security level. an algorithm is said to have a
security level of n bit if the best known attack requires 2n steps. this is a quite
natural definition because symmetric algorithms with a security level of n have a key
of length n bit. the relationship between cryptographic strength and security is not
as straightforward in the asymmetric case, though. table 6.1 shows recommended
bit lengths for public-key algorithms for the four security levels 80, 128, 192 and 256
bit. we see from the table that rsa-like schemes and discrete-logarithm schemes
require very long operands and keys. the key length of elliptic curve schemes is
significantly smaller, yet still twice as long as symmetric ciphers with the same
cryptographic strength.
table 6.1 bit lengths of public-key algorithms for different security levels
algorithm family

cryptosystems

80
integer factorization rsa
1024 bit
discrete logarithm dh, dsa, elgamal 1024 bit
elliptic curves
ecdh, ecdsa
160 bit
symmetric-key
aes, 3des
80 bit

security level (bit)
128
192
256
3072 bit 7680 bit 15360 bit
3072 bit 7680 bit 15360 bit
256 bit 384 bit 512 bit
128 bit 192 bit 256 bit

you may want to compare this table with the one given in sect. 1.3.2, which
provides information about the security estimations of symmetric-key algorithms. in
order to provide long-term security, i.e., security for a timespan of several decades,
a security level of 128 bit should be chosen, which requires fairly long keys for all
three algorithm families.
an undesired consequence of the long operands is that public-key schemes are
extremely arithmetically intensive. as mentioned earlier, it is not uncommon that
one public-operation, say a digital signature, is by 23 orders of magnitude slower
than the encryption of one block using aes or 3des. moreover, the computational

6.3 essential number theory for public-key algorithms

157

complexity of the three algorithm families grows roughly with the cube bit length.
as an example, increasing the bit length from 1024 to 3076 in a given rsa signature
generation software results in an execution that is 33  27 times slower on modern
pcs, execution times in the range of several 10 msec to a few 100 msec are common,
which does not pose a problem for many applications. however, public-key performance can be a more serious bottleneck in constrained devices where small cpus
are prevalent, e.g., mobile phones or smart cards, or on network servers that have
to compute many public-key operations per second. chaps. 7, 8 and 9 introduce
several techniques for implementing public-key algorithms reasonably efficiently.

6.3 essential number theory for public-key algorithms
we will now study a few techniques from number theory which are essential for
public-key cryptography. we introduce the euclidean algorithm, eulers phi function as well as fermats little theorem and eulers theorem. all are important for
asymmetric algorithms, especially for understanding the rsa crypto scheme.

6.3.1 euclidean algorithm
we start with the problem of computing the greatest common divisor (gcd). the gcd
of two positive integers r0 and r1 is denoted by
gcd(r0 , r1 )
and is the largest positive number that divides both r0 and r1 . for instance gcd(21, 9) 
3. for small numbers, the gcd is easy to calculate by factoring both numbers and
finding the highest common factor.
example 6.1. let r0  84 and r1  30. factoring yields
r0  84  2  2  3  7
r1  30  2  3  5
the gcd is the product of all common prime factors
2  3  6  gcd(30, 84)

for the large numbers which occur in public-key schemes, however, factoring
often is not possible, and a more efficient algorithm is used for gcd computations, the
euclidean algorithm. the algorithm, which is also referred to as euclids algorithm,
is based on the simple observation that

158

6 introduction to public-key cryptography

gcd(r0 , r1 )  gcd(r0  r1 , r1 ),
where we assume that r0  r1 , and that both numbers are positive integers. this
property can easily be proven let gcd(r0 , r1 )  g. since g divides both r0 and r1 ,
we can write r0  g  x and r1  g  y, where x  y, and x and y are coprime integers,
i.e., they do not have common factors. moreover, it is easy to show that (x  y) and
y are also coprime. it follows from here that
gcd(r0  r1 , r1 )  gcd(g  (x  y), g  y)  g.
lets verify this property with the numbers from the previous example
example 6.2. again, let r0  84 and r1  30. we now look at the gcd of (r0  r1 )
and r1 
r0  r1  54  2  3  3  3
r1  30  2  3  5
the largest common factor still is 2  3  6  gcd(30, 54)  gcd(30, 84).

it also follows immediately that we can apply the process iteratively
gcd(r0 , r1 )  gcd(r0  r1 , r1 )  gcd(r0  2r1 , r1 )      gcd(r0  m r1 , r1 )
as long as (r0  m r1 )  0. the algorithm uses the fewest number of steps if we
choose the maximum value for m. this is the case if we compute
gcd(r0 , r1 )  gcd(r0 mod r1 , r1 ).
since the first term (r0 mod r1 ) is smaller than the second term r1 , we usually swap
them
gcd(r0 , r1 )  gcd(r1 , r0 mod r1 ).
the core observation from this process is that we can reduce the problem of
finding the gcd of two given numbers to that of the gcd of two smaller numbers.
this process can be applied recursively until we obtain finally gcd(rl , 0)  rl . since
each iteration preserves the gcd of the previous iteration step, it turns out that this
final gcd is the gcd of the original problem, i.e.,
gcd(r0 , r1 )      gcd(rl , 0)  rl .
we first show some examples for finding the gcd using the euclidean algorithm and
then discuss the algorithm a bit more formally.
example 6.3. let r0  27 and r1  21. fig. 6.6 gives us some feeling for the algorithm by showing how the lengths of the parameters shrink in every iteration.
the shaded parts in the iteration are the new remainders r2  6 (first iteration), and
r3  3 (second iteration) which form the input terms for the next iterations. note

6.3 essential number theory for public-key algorithms

159

that in the last iteration the remainder is r4  0, which indicates the termination of
the algorithm. 
21

6

3

6

6
6

gcd(27, 21)  gcd(1 21+6, 21)  gcd(21, 6)
gcd(21, 6)  gcd(3 6+3, 6)  gcd(6, 3)

3

gcd(6, 3)  gcd(2 3+0, 3)  gcd(3, 0)  3

3

gcd(27, 21)  gcd(21, 6)  gcd(6, 3)  gcd(3, 0)  3

fig. 6.6 example of the euclidean algorithm for the input values r0  27 and r1  21

it is also helpful to look at the euclidean algorithm with slightly larger numbers, as
happens in example 6.4.
example 6.4. let r0  973 and r1  301. the gcd is then computed as
973
301
70
21

 3  301 + 70
 4  70 + 21
 3  21 + 7
 37+0

gcd(973, 301)
gcd(301, 70)
gcd(70, 21)
gcd(21, 7)






gcd(301, 70)
gcd(70, 21)
gcd(21, 7)
gcd(7, 0)  7


by now we should have an idea of euclids algorithm, and we can give a more
formal description of the algorithm.
euclidean algorithm
input positive integers r0 and r1 with r0  r1
output gcd(r0 , r1 )
initialization i  1
algorithm
1
do
1.1
i  i+1
1.2
ri  ri2 mod ri1
while ri  0
2
return
gcd(r0 , r1 )  ri1
note that the algorithm terminates if a remainder with the value ri  0 is computed. the remainder computed in the previous iteration, denoted by rl1 , is the gcd
of the original problem.

160

6 introduction to public-key cryptography

the euclidean algorithm is very efficient, even with the very long numbers typically used in public-key cryptography. the number of iterations is close to the number of digits of the input operands. that means, for instance, that the number of
iterations of a gcd involving 1024-bit numbers is 1024 times a constant. of course,
algorithms with a few thousand iterations can easily be executed on todays pcs,
making the algorithms very efficient in practice.

6.3.2 extended euclidean algorithm
so far, we have seen that finding the gcd of two integers r0 and r1 can be done
by recursively reducing the operands. however, it turns out that finding the gcd is
not the main application of the euclidean algorithm. an extension of the algorithm
allows us to compute modular inverses, which is of major importance in public-key
cryptography. in addition to computing the gcd, the extended euclidean algorithm
(eea) computes a linear combination of the form
gcd(r0 , r1 )  s  r0 + t  r1
where s and t are integer coefficients. this equation is often referred to as diophantine equation.
the question now is how do we compute the two coefficients s and t the idea
behind the algorithm is that we execute the standard euclidean algorithm, but we
express the current remainder ri in every iteration as a linear combination of the
form
(6.1)
r i  s i r0 + ti r1 .
if we succeed with this, we end up in the last iteration with the equation
rl  gcd(r0 , r1 )  sl r0 + tl r1  sr0 + tr1 .
this means that the last coefficient sl is the coefficient s in eq. (6.1) we are looking
for, and also tl  t. lets look at an example.
example 6.5. we consider the extended euclidean algorithm with the same values as
in the previous example, r0  973 and r1  301. on the left-hand side, we compute
the standard euclidean algorithm, i.e., we compute new remainders r2 , r3 , . . .. also,
we have to compute the integer quotient qi1 in every iteration. on the right-hand
side we compute the coefficients si and ti such that ri  si r0 + ti r1 . the coefficients
are always shown in brackets.

6.3 essential number theory for public-key algorithms

161

i ri2  qi1  ri1 + ri ri  [si ]r0 + [ti ]r1
2 973  3  301 + 70
70  [1]r0 + [3]r1
3 301  4  70 + 21
21  301  4  70
 r1  4(1r0  3 r1 )
 [4]r0 + [13]r1
4 70  3  21 + 7
7  70  3  21
 (1r0  3r1 )  3(4r0 + 13r1 )
 [13]r0 + [42]r1
21  3  7 + 0
the algorithm computed the three parameters gcd(973, 301)  7, s  13 and
t  42. the correctness can be verified by
gcd(973, 301)  7  [13]973 + [42]301  12649  12642.

you should carefully watch the algebraic steps taking place in the right column
of the example above. in particular, observe that the linear combination on the righthand side is always constructed with the help of the previous linear combinations.
we will now derive recursive formulae for computing si and ri in every iteration.
assume we are in iteration with index i. in the two previous iterations we computed
the values
ri2  [si2 ]r0 + [ti2 ]r1
ri1  [si1 ]r0 + [ti1 ]r1

(6.2)
(6.3)

in the current iteration i we first compute the quotient qi1 and the new remainder
ri from ri1 and ri2 
ri2  qi1  ri1 + ri .
this equation can be rewritten as
ri  ri2  qi1  ri1 .

(6.4)

recall that our goal is to represent the new remainder ri as a linear combination of
r0 and r1 as shown in eq. (6.1). the core step for achieving this happens now in
eq. (6.4) we simply substitute ri2 by eq. (6.2) and ri1 by eq. (6.3)
ri  (si2 r0 + ti2 r1 )  qi1 (si1 r0 + ti1 r1 )
if we rearrange the terms we obtain the desired result
ri  [si2  qi1 si1 ]r0 + [ti2  qi1ti1 ]r1
ri  [si ]r0 + [ti ]r1

(6.5)

eq. (6.5) also gives us immediately the recursive formulae for computing si and
ti , namely si  si2  qi1 si1 and ti  ti2  qi1ti1 . these recursions are valid

162

6 introduction to public-key cryptography

for index values i  2. like any recursion, we need starting values for s0 , s1 ,t0 ,t1 .
these initial values (which we derive in problem 6.13) can be shown to be s0 
1, s1  0,t0  0,t1  1.
extended euclidean algorithm (eea)
input positive integers r0 and r1 with r0  r1
output gcd(r0 , r1 ), as well as s and t such that gcd(r0 , r1 )  s  r0 + t  r1 .
initialization
t0  0
s0  1
t1  1
s1  0
i 1
algorithm
1 do
1.1
i
 i+1
1.2
ri  ri2 mod ri1
1.3
qi1  (ri2  ri )/ri1
1.4
si  si2  qi1  si1
1.5
ti  ti2  qi1  ti1
while ri  0
2 return
gcd(r0 , r1 )  ri1
s  si1
t  ti1
as mentioned above, the main application of the eea in asymmetric cryptography is to compute the inverse modulo of an integer. we already encountered this
problem in the context of the affine cipher in chap. 1. for the affine cipher, we
were required to find the inverse of the key value a modulo 26. with the euclidean
algorithm, this is straightforward. lets assume we want to compute the inverse
of r1 mod r0 where r1  r0 . recall from sect. 1.4.2 that the inverse only exists if
gcd(r0 , r1 )  1. hence, if we apply the eea, we obtain sr0 +t r1  1  gcd(r0 , r1 ).
taking this equation modulo r0 we obtain
s  r0 + t  r 1  1
s  0 + t  r1  1 mod r0
r1  t  1 mod r0

(6.6)

equation (6.6) is exactly the definition of the inverse of r1 . that means, that t itself
is the inverse of r1 
t  r11 mod r0 .

6.3 essential number theory for public-key algorithms

163

thus, if we need to compute an inverse a1 mod m, we apply the eea with the
input parameters m and a. the output value t that is computed is the inverse. lets
look at an example.
example 6.6. our goal is to compute 121 mod 67. the values 12 and 67 are relatively prime, i.e., gcd(67, 12)  1. if we apply the eea, we obtain the coefficients s
and t in gcd(67, 12)  1  s  67 +t  12. starting with the values r0  67 and r1  12,
the algorithm proceeds as follows
i qi1 ri si ti
2
5 7 1 -5
1 5 -1 6
3
1 2 2 -11
4
2 1 -5 28
5
this gives us the linear combination
5  67 + 28  12  1
as shown above, the inverse of 12 follows from here as
121  28 mod 67.
this result can easily be verified
28  12  336  1 mod 67.

note that the s coefficient is not needed and is in practice often not computed.
please note also that the result of the algorithm can be a negative value for t. the
result is still correct, however. we have to compute t  t + r0 , which is a valid
operation since t  t + r0 mod r0 .
for completeness, we show how the eea can also be used for computing multiplicative inverses in galois fields. in modern cryptography this is mainly relevant
for the derivation of the aes s-boxes and for elliptic curve public-key algorithms.
the eea can be used completely analogously with polynomials instead of integers. if we want to compute an inverse in a finite field gf(2m ), the inputs to the
algorithm are the field element a(x) and the irreducible polynomial p(x). the eea
computes the auxiliary polynomials s(x) and t(x), as well as the greatest common
divisor gcd(p(x), a(x)) such that
s(x)p(x) + t(x)a(x)  gcd(p(x), a(x))  1
note that since p(x) is irreducible, the gcd is always equal to 1. if we take the
equation above and reduce both sides modulo p(x), it is straightforward to see that
the auxiliary polynomial t(x) is equal to the inverse of a(x)

164

6 introduction to public-key cryptography

s(x) 0 + t(x) a(x)  1 mod p(x)
t(x)  a1 (x) mod p(x)
we give at this point an example of the algorithm for the small field gf(23 ).
example 6.7. we are looking for the inverse of a(x)  x2 in the finite field gf(23 )
with p(x)  x3 + x + 1. the initial values for the t(x) polynomial are t0 (x)  0,
t1 (x)  1
iteration
2
3
4

ri2 (x)  [qi1 (x)] ri1 (x) + [ri (x)]
x3 + x + 1  [x] x2 + [x + 1]
x2
 [x] (x + 1) + [x]
x+1
 [1] x + [1]

5

x

 [x] 1 + [0]

ti (x)
t2  t0  q1t1  0  x 1  x
t3  t1  q2t2  1  x (x)  1 + x2
t4  t2  q3t3  x  1 (1 + x2 )
t4  1 + x + x 2
termination since r5  0

note that polynomial coefficients are computed in gf(2), and since addition and
multiplication are the same operations, we can always replace a negative coefficient
(such as x) by a positive one. the new quotient and the new remainder that are
computed in every iteration are shown in brackets above. the polynomials ti (x)
are computed according to the recursive formula that was used for computing the
integers ti earlier in this section. the eea terminates if the remainder is 0, which is
the case in the iteration with index 5. the inverse is now given as the last ti (x) value
that was computed, i.e., t4 (x)
a1 (x)  t(x)  t4 (x)  x2 + x + 1.
here is the check that t(x) is in fact the inverse of x2 , where we use the properties
that x3  x + 1 mod p(x) and x4  x2 + x mod p(x)
t4 (x)  x2  x4 + x3 + x2
 (x2 + x) + (x + 1) + x2 mod p(x)
 1 mod p(x)

note that in every iteration of the eea, one uses long division (not shown above)
to determine the new quotient qi1 (x) and the new remainder ri (x).
the inverse table 4.2 in chap. 4 was computed using the extended euclidean
algorithm.

6.3.3 eulers phi function
we now look at another tool that is useful for public-key cryptosystems, especially
for rsa. we consider the ring zm , i.e., the set of integers {0, 1, . . . , m  1}. we are

6.3 essential number theory for public-key algorithms

165

interested in the (at the moment seemingly odd) problem of knowing how many
numbers in this set are relatively prime to m. this quantity is given by eulers phi
function, which is defined as follows
definition 6.3.1 eulers phi function
the number of integers in zm relatively prime to m is denoted by
 (m).
we first look at some examples and calculate eulers phi function by actually
counting all the integers in zm which are relatively prime.
example 6.8. let m  6. the associated set is z6  {0, 1, 2, 3, 4, 5}.
gcd(0, 6)  6
gcd(1, 6)  1 
gcd(2, 6)  2
gcd(3, 6)  3
gcd(4, 6)  2
gcd(5, 6)  1 
since there are two numbers in the set which are relatively prime to 6, namely 1 and
5, the phi function takes the value 2, i.e.,  (6)  2.

here is another example
example 6.9. let m  5. the associated set is z5  {0, 1, 2, 3, 4}.
gcd(0, 5)  5
gcd(1, 5)  1 
gcd(2, 5)  1 
gcd(3, 5)  1 
gcd(4, 5)  1 
this time we have four numbers which are relatively prime to 5, hence,  (5)  4.

from the examples above we can guess that calculating eulers phi function by
running through all elements and computing the gcd is extremely slow if the numbers are large. in fact, computing eulers phi function in this nave way is completely out of reach for the large numbers occurring in public-key cryptography.
fortunately, there exists a relation to calculate it much more easily if we know the
factorization of m, which is given in following theorem.

166

6 introduction to public-key cryptography

theorem 6.3.1 let m have the following canonical factorization
m  pe11  pe22  . . .  penn ,
where the pi are distinct prime numbers and ei are positive integers,
then
n

 (m)  (pei i  piei 1 ).
i1

since the value of n, i.e., the number of distinct prime factors, is always quite small
even for large numbers m, evaluating the product symbol  is computationally easy.
lets look at an example where we calculate eulers phi function using the relation
example 6.10. let m  240. the factorization of 240 in the canonical factorization
form is
e
m  240  16  15  24  3  5  pe11  pe22  p33
there are three distinct prime factors, i.e., n  3. the value for eulers phi functions
follows then as

 (m)  (24  23 )(31  30 )(51  50 )  8  2  4  64.
that means that 64 integers in the range {0, 1, . . . , 239} are coprime to m  240.
the alternative method, which would have required to evaluate the gcd 240 times,
would have been much slower even for this small number.

it is important to stress that we need to know the factorization of m in order to
calculate eulers phi function quickly in this manner. as we will see in the next
chapter, this property is at the heart of the rsa public-key scheme conversely, if
we know the factorization of a certain number, we can compute eulers phi function
and decrypt the ciphertext. if we do not know the factorization, we cannot compute
the phi function and, hence, cannot decrypt.

6.3.4 fermats little theorem and eulers theorem
we describe next two theorems which are quite useful in public-key crpytography.
we start with fermats little theorem.1 the theorem is helpful for primality testing
and in many other aspects of public-key cryptography. the theorem gives a seemingly surprising result if we do exponentiations modulo an integer.
1

you should not confuse this with fermats last theorem, one of the most famous numbertheoretical problems, which was proved in the 1990s after 350 years.

6.3 essential number theory for public-key algorithms

167

theorem 6.3.2 fermats little theorem
let a be an integer and p be a prime, then
a p  a ( mod p).
we note that arithmetic in finite fields gf(p) is done modulo p, and hence, the
theorem holds for all integers a which are elements of a finite field gf(p). the
theorem can be stated in the form
a p1  1 ( mod p)
which is often useful in cryptography. one application is the computation of the
inverse in a finite field. we can rewrite the equation as a  a p2  1 ( mod p). this
is exactly the definition of the multiplicative inverse. thus, we immediately have a
way for inverting an integer a modulo a prime
a1  a p2 ( mod p)

(6.7)

we note that this inversion method holds only if p is a prime. lets look at an
example
example 6.11. let p  7 and a  2. we can compute the inverse of a as
a p2  25  32  4 mod 7.
this is easy to verify 2  4  1 mod 7.

performing the exponentiation in eq. (6.7) is usually slower than using the extended
euclidean algorithm. however, there are situations where it is advantageous to use
fermats little theorem, e.g., on smart cards or other devices which have a hardware accelerator for fast exponentiation anyway. this is not uncommon because
many public-key algorithms require exponentiation, as we will see in subsequent
chapters.
a generalization of fermats little theorem to any integer moduli, i.e., moduli
that are not necessarily primes, is eulers theorem.
theorem 6.3.3 eulers theorem
let a and m be integers with gcd(a, m)  1, then
a (m)  1 ( mod m).
since it works modulo m, it is applicable to integer rings zm . we show now an
example for eulers theorem with small values.
example 6.12. let m  12 and a  5. first, we compute eulers phi function of m

168

6 introduction to public-key cryptography

 (12)   (22  3)  (22  21 )(31  30 )  (4  2)(3  1)  4.
now we can verify eulers theorem
5 (12)  54  252  625  1 mod 12.

it is easy to show that fermats little theorem is a special case of eulers theorem.
if p is a prime, it holds that  (p)  (p1  p0 )  p  1. if we use this value for
eulers theorem, we obtain a (p)  a p1  1 ( mod p), which is exactly fermats
little theorem.

6.4 discussion and further reading
public-key cryptography in general asymmetric cryptography was introduced
in the landmark paper by whitfield diffie and martin hellman [58]. ralph merkle
independently invented the concept of asymmetric cryptography but proposed an
entirely different public-key algorithm [121]. there are a few good accounts of the
history of public-key cryptography. the treatment in [57] by diffie is recommended.
another good overview on public-key cryptography is [127]. a very instructive and
detailed history of elliptic curve cryptography, including the relatively intense competition between rsa and ecc during the 1990s, is described in [100]. more recent
development in asymmetric cryptography is tracked by the workshop on public-key
cryptography (pkc) series.
modular arithmetic with respect to the mathematics introduced in this chapter,
the introductory books on number theory recommended in sect. 1.5 make good
sources for further reading. in practical terms, the extended euclidean algorithm
(eea) is the most crucial, since virtually all implementations of public-key schemes
incorporate it, especially modular inversion. an important acceleration technique
for the scheme is the binary eea. its advantage over the standard eea is that it
replaces divisions by bit shifts. this is in particular attractive for the very long numbers occurring in public-key schemes.
alternative public-key algorithms in addition to the three established families
of asymmetric schemes, there exist several others. first, there are algorithms which
have been broken or are believed to be insecure, e.g., knapsack schemes. second,
there are generalizations of the established algorithms, e.g., hyperelliptic curves,
algebraic varieties or non-rsa factoring-based schemes. these schemes use the
same one-way function, that is, integer factorization or the discrete logarithm in
certain groups. third, there are asymmetric algorithms which are based on different one-way functions. four families of one-way function are of particular interest
hash-based, code-based, lattice-based and multivariate quadratic (mq) public-key
algorithms. there are, of course, reasons why they are not as widely used today.

6.5 lessons learned

169

in most cases, they have either practical drawbacks, such as very long keys (sometimes in the range of several megabytes), or the cryptographic strength is not well
understood. since about 2005, there has been growing interest in the cryptographic
community in such asymmetric schemes. this is in part motivated by the fact that
no quantum computing attacks are currently known against these four families of
alternative asymmetric schemes. this is in contrast to rsa, discrete logarithm, and
elliptic curve schemes and their variants, which are all vulnerable to attacks using
quantum computers [153]. even though it is not clear whether quantum computers
will ever exist (the most optimistic estimates state that they are still several decades
away), the alternative public-key algorithms are at times collectively referred to as
post-quantum cryptography. a recent book [18] and a new workshop series [36, 35]
provide more information about this area of active research.

6.5 lessons learned






public-key algorithms have capabilities that symmetric ciphers dont have, in
particular digital signature and key establishment functions.
public-key algorithms are computationally intensive (a nice way of saying that
they are slow), and hence are poorly suited for bulk data encryption.
only three families of public-key schemes are widely used. this is considerably
fewer than in the case of symmetric algorithms.
the extended euclidean algorithm allows us to compute modular inverses quickly,
which is important for almost all public-key schemes.
eulers phi function gives us the number of elements smaller than an integer n
that are relatively prime to n. this is an important function for the rsa crypto
scheme.

170

6 introduction to public-key cryptography

problems
6.1. as we have seen in this chapter, public-key cryptography can be used for encryption and key exchange. furthermore, it has some properties (such as nonrepudiation) which are not offered by secret key cryptography.
so why do we still use symmetric cryptography in current applications
6.2. in this problem, we want to compare the computational performance of symmetric and asymmetric algorithms. assume a fast public-key library such as
openssl [132] that can decrypt data at a rate of 100 kbit/sec using the rsa algorithm on a modern pc. on the same machine, aes can decrypt at a rate of
17 mbit/sec. assume we want to decrypt a movie stored on a dvd. the movie
requires 1 gbyte of storage. how long does decryption take with either algorithm
6.3. assume a (small) company with 120 employees. a new security policy demands encrypted message exchange with a symmetric cipher. how many keys are
required, if you are to ensure a secret communication for every possible pair of
communicating parties
6.4. the level of security in terms of the corresponding bit length directly influences the performance of the respective algorithm. we now analyze the influence of
increasing the security level on the runtime.
assume that a commercial web server for an online shop can use either rsa
or ecc for signature generation. furthermore, assume that signature generation for
rsa-1024 and ecc-160 takes 15.7 ms and 1.3 ms, respectively.
1. determine the increase in runtime for signature generation if the security level
from rsa is increased from 1024 bit to 3072 bit.
2. how does the runtime increase from 1024 bit to 15,360 bit
3. determine these numbers for the respective security levels of ecc.
4. describe the difference between rsa and ecc when increasing the security
level.
hint recall that the computational complexity of both rsa and ecc grows with
the cube of bit length. you may want to use table 6.1 to determine the adequate bit
length for ecc, given the security level of rsa.
6.5. using the basic form of euclids algorithm, compute the greatest common divisor of
1. 7469 and 2464
2. 2689 and 4001
for this problem use only a pocket calculator. show every iteration step of euclids
algorithm, i.e., dont write just the answer, which is only a number. also, for every
gcd, provide the chain of gcd computations, i.e.,
gcd(r0 , r1 )  gcd(r1 , r2 )     .

problems

171

6.6. using the extended euclidean algorithm, compute the greatest common divisor
and the parameters s,t of
1. 198 and 243
2. 1819 and 3587
for every problem check if s r0 +t r1  gcd(r0 , r1 ) is actually fulfilled. the rules are
the same as above use a pocket calculator and show what happens in every iteration
step.
6.7. with the euclidean algorithm we finally have an efficient algorithm for finding
the multiplicative inverse in zm that is much better than exhaustive search. find the
inverses in zm of the following elements a modulo m
1. a  7, m  26 (affine cipher)
2. a  19, m  999
note that the inverses must again be elements in zm and that you can easily verify
your answers.
6.8. determine  (m), for m  12, 15, 26, according to the definition check for each
positive integer n smaller m whether gcd(n, m)  1. (you do not have to apply euclids algorithm.)
6.9. develop formulae for  (m) for the special cases when
1. m is a prime
2. m  p  q, where p and q are primes. this case is of great importance for the
rsa cryptosystem. verify your formula for m  15, 26 with the results from the
previous problem.
6.10. compute the inverse a1 mod n with fermats theorem (if applicable) or eulers theorem




a  4, n  7
a  5, n  12
a  6, n  13

6.11. verify that eulers theorem holds in zm , m  6, 9, for all elements a for which
gcd(a, m)  1. also verify that the theorem does not hold for elements a for which
gcd(a, m)  1.
6.12. for the affine cipher in chapter 1 the multiplicative inverse of an element
modulo 26 can be found as
a1  a11 mod 26.
derive this relationship by using eulers theorem.
6.13. the extended euclidean algorithm has the initial conditions s0  1, s1  0,t0 
0,t1  1. derive these conditions. it is helpful to look at how the general iteration
formula for the euclidean algorithm was derived in this chapter.

chapter 7

the rsa cryptosystem

after whitfield diffie and martin hellman introduced public-key cryptography in
their landmark 1976 paper [58], a new branch of cryptography suddenly opened
up. as a consequence, cryptologists started looking for methods with which publickey encryption could be realized. in 1977, ronald rivest, adi shamir and leonard
adleman (cf. fig. 7.1) proposed a scheme which became the most widely used
asymmetric cryptographic scheme, rsa.

fig. 7.1 an early picture of adi shamir, ron rivest, and leonard adleman (reproduced with
permission from ron rivest)

in this chapter you will learn





how rsa works
practical aspects of rsa, such as computation of the parameters, and fast encryption and decryption
security estimations
implementational aspects

c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 7, 

173

174

7 the rsa cryptosystem

7.1 introduction
the rsa crypto scheme, sometimes referred to as the rivestshamiradleman algorithm, is currently the most widely used asymmetric cryptographic scheme, even
though elliptic curves and discrete logarithm schemes are gaining ground. rsa was
patented in the usa (but not in the rest of the world) until 2000.
there are many applications for rsa, but in practice it is most often used for



encryption of small pieces of data, especially for key transport
digital signatures, which is discussed in chap. 10, e.g., for digital certificates on
the internet

however, it should be noted that rsa encryption is not meant to replace symmetric ciphers because it is several times slower than ciphers such as aes. this
is because of the many computations involved in performing rsa (or any other
public-key algorithm) as we learn later in this chapter. thus, the main use of the
encryption feature is to securely exchange a key for a symmetric cipher (key transport). in practice, rsa is often used together with a symmetric cipher such as aes,
where the symmetric cipher does the actual bulk data encryption.
the underlying one-way function of rsa is the integer factorization problem
multiplying two large primes is computationally easy (in fact, you can do it with
paper and pencil), but factoring the resulting product is very hard. eulers theorem
(theorem 6.3.3) and eulers phi function play important roles in rsa. in the following, we first describe how encryption, decryption and key generation work, then
we talk about practical aspects of rsa.

7.2 encryption and decryption
rsa encryption and decryption is done in the integer ring zn and modular computations play a central role. recall that rings and modular arithmetic in rings were
introduced in sect. 1.4.2. rsa encrypts plaintexts x, where we consider the bit string
representing x to be an element in zn  {0, 1, . . . , n  1}. as a consequence the binary value of the plaintext x must be less than n. the same holds for the ciphertext.
encryption with the public key and decryption with the private key are as shown
below
rsa encryption given the public key (n, e)  k pub and the plaintext x, the
encryption function is
y  ek pub (x)  xe mod n
where x, y  zn .

(7.1)

7.3 key generation and proof of correctness

175

rsa decryption given the private key d  k pr and the ciphertext y, the
decryption function is
x  dk pr (y)  yd mod n

(7.2)

where x, y  zn .
in practice, x, y, n and d are very long numbers, usually 1024 bit long or more.
the value e is sometimes referred to as encryption exponent or public exponent, and
the private key d is sometimes called decryption exponent or private exponent. if
alice wants to send an encrypted message to bob, alice needs to have his public
key (n, e), and bob decrypts with his private key d. we discuss in sect. 7.3 how
these three crucial parameters d, e, and n are generated.
even without knowing more details, we can already state a few requirements for
the rsa cryptosystem
1. since an attacker has access to the public key, it must be computationally infeasible to determine the private-key d given the public-key values e and n.
2. since x is only unique up to the size of the modulus n, we cannot encrypt more
than l bits with one rsa encryption, where l is the bit length of n.
3. it should be relatively easy to calculate xe mod n, i.e., to encrypt, and yd mod n,
i.e., to decrypt. this means we need a method for fast exponentiation with very
long numbers.
4. for a given n, there should be many private-key/public-key pairs, otherwise an
attacker might be able to perform a brute-force attack. (it turns out that this requirement is easy to satisfy.)

7.3 key generation and proof of correctness
a distinctive feature of all asymmetric schemes is that there is a set-up phase during which the public and private key are computed. depending on the public-key
scheme, key generation can be quite complex. as a remark, we note that key generation is usually not an issue for block or stream ciphers.
here are the steps involved in computing the public and private-key for an rsa
cryptosystem.

176

7 the rsa cryptosystem

rsa key generation
output public key k pub  (n, e) and private key k pr  (d)
1. choose two large primes p and q.
2. compute n  p  q.
3. compute  (n)  (p  1)(q  1).
4. select the public exponent e  {1, 2, . . . ,  (n)  1} such that
gcd(e,  (n))  1.
5. compute the private key d such that
d  e  mod  (n)
the condition that gcd(e,  (n))  1 ensures that the inverse of e exists modulo
 (n), so that there is always a private key d.
two parts of the key generation are nontrivial step 1, in which the two large
primes are chosen, as well as steps 4 and 5 in which the public and private key
are computed. the prime generation of step 1 is quite involved and is addressed
in sect. 7.6. the computation of the keys d and e can be done at once using the
extended euclidean algorithm (eea). in practice, one often starts by first selecting a
public parameter e in the range 0  e   (n). the value e must satisfy the condition
gcd(e,  (n))  1. we apply the eea with the input parameters n and e and obtain
the relationship
gcd( (n), e)  s   (n) + t  e
if gcd(e,  (n))  1, we know that e is a valid public key. moreover, we also know
that the parameter t computed by the extended euclidean algorithm is the inverse of
e, and thus
d  t mod  (n)
in case that e and  (n) are not relatively prime, we simply select a new value for
e and repeat the process. note that the coefficient s of the eea is not required for
rsa and does not need to be computed.
we now see how rsa works by presenting a simple example.
example 7.1. alice wants to send an encrypted message to bob. bob first computes
his rsa parameters in steps 15. he then sends alice his public key. alice encrypts
the message (x  4) and sends the ciphertext y to bob. bob decrypts y using his
private key.

7.3 key generation and proof of correctness
alice
message x  4

177
bob
1. choose p  3 and q  11
2. n  p  q  33
3.  (n)  (3  1)(11  1)  20
4. choose e  3
5. d  e1  7 mod 20

k pub (33,3)


y  xe  43  31 mod 33
y31


yd  317  4  x mod 33

note that the private and public exponents fulfill the condition e  d  3  7 
1 mod  (n).

practical rsa parameters are much, much larger. as can be seen from table 6.1,
the rsa modulus n should be at least 1024 bit long, which results in a bit length for
p and q of 512. here is an example of rsa parameters for this bit length
p  e0dfd2c2a288acebc705efab30e4447541a8c5a47a37185c5a9
cb98389ce4de19199aa3069b404fd98c801568cb9170eb712bf
10b4955ce9c9dc8ce6855c6123h
q  ebe0fcf21866fd9a9f0d72f7994875a8d92e67aee4b515136b2
a778a8048b149828aea30bd0ba34b977982a3d42168f 594ca99
f3981ddabfab2369f229640115h
n  cf33188211fdf6052bdbb1a37235e0abb5978a45c71fd381a91
ad12fc76da0544c47568ac83d855d47ca8d8a779579ab72e635
d0b0aaac22d28341e998e90f82122a2c06090f43a37e0203c2b
72e401fd06890ec8ead4f07e686e906f01b2468ae7b30cbd670
255c1fede1a2762cf4392c0759499cc0abecff008728d9a11adfh
e  40b028e1e4ccf07537643101ff72444a0be1d7682f1edb553e3
ab4f6dd8293ca1945db12d796ae9244d60565c2eb692a89b888
1d58d278562ed60066dd8211e67315cf89857167206120405b0
8b54d10d4ec4ed4253c75fa74098fe3f7fb751ff5121353c554
391e114c85b56a9725e9bd5685d6c9c7eed8ee442366353dc39h
d  c21a93ee751a8d4fbfd77285d79d6768c58ebf283743d2889a3
95f266c78f4a28e86f545960c2ce01eb8ad5246905163b28d0b
8baabb959cc03f4ec499186168ae9ed6d88058898907e61c7cc
cc584d65d801cfe32dfc983707f87f5aa6ae4b9e77b9ce630e2
c0df05841b5e4984d059a35d7270d500514891f7b77b804bed81h

178

7 the rsa cryptosystem

what is interesting is that the message x is first raised to the eth power during
encryption and the result y is raised to the dth power in the decryption, and the
result of this is again equal to the message x. expressed as an equation, this process
is
(7.3)
dk pr (y)  dk pr (ek pub (x))  (xe )d  xde  x mod n.
this is the essence of rsa. we will now prove why the rsa scheme works.
proof. we need to show that decryption is the inverse function of encryption,
dk pr (ek pub (x))  x. we start with the construction rule for the public and private
key d  e  1 mod  (n). by definition of the modulo operator, this is equivalent to
d  e  1 + t   (n),
where t is some integer. inserting this expression in eq. (7.3)
dk pr (y)  xde  x1+t (n)  xt (n)  x1  (x (n) )t  x mod n.

(7.4)

this means we have to prove that x  (x (n) )t  x mod n. we use now eulers theorem from sect. 6.3.3, which states that if gcd(x, n)  1 then 1  x (n) mod n. a
minor generalization immediately follows
1  1t  (x (n) )t mod n,

(7.5)

where t is any integer. for the proof we distinguish two cases
first case gcd(x, n)  1
eulers theorem holds here and we can insert eq. (7.5) into (7.4)
dk pr (y)  (x (n) )t  x  1  x  x mod n.

q.e.d.

this part of the proof establishes that decryption is actually the inverse function of encryption for plaintext values x which are relatively prime to the rsa
modulus n. we provide now the proof for the other case.
second case gcd(x, n)  gcd(x, p  q)  1
since p and q are primes, x must have one of them as a factor
x  r p

or

x  s  q,

where r, s are integers such that r  q and s  p. without loss of generality we
assume x  r  p, from which follows that gcd(x, q)  1. eulers theorem holds
in the following form
1  1t  (x (q) )t mod q,
where t is any positive integer. we now look at the term (x (n) )t again
(x (n) )t  (x(q1)(p1) )t  ((x (q) )t ) p1  1(p1)  1 mod q.
using the definition of the modulo operator, this is equivalent to

7.4 encryption and decryption fast exponentiation

179

(x (n) )t  1 + u  q,
where u is some integer. we multiply this equation by x
x  (x (n) )t  x + x  u  q
 x + (r  p)  u  q
 x + r  u  (p  q)
 x+run

x  (x (n) )t  x mod n.

(7.6)

inserting eq. (7.6) into eq. (7.4) yields the desired result



dk pr  (x (n) )t  x  x mod n.

if this proof seems somewhat lengthy, please remember that the correctness of
rsa is simply assured by step 5 of the rsa key generation phase. the proof becomes simpler by using the chinese remainder theorem which we have not introduced.

7.4 encryption and decryption fast exponentiation
unlike symmetric algorithms such as aes, des or stream ciphers, public-key algorithms are based on arithmetic with very long numbers. unless we pay close
attention to how to realize the necessary computations, we can easily end up with
schemes that are too slow for practical use. if we look at rsa encryption and decryption in eqs. (7.1) and (7.2), we see that both are based on modular exponentiation. we restate both operations here for convenience
y  ek pub (x)  xe mod n (encryption)
x  dk pr (y)  yd mod n (decryption)
a straightforward way of exponentiation looks like this
sq

mul

mul

mul

x  x2  x3  x4  x5   
where sq denotes squaring and mul multiplication. unfortunately, the exponents
e and d are in general very large numbers. the exponents are typically chosen in the
range of 10243072 bit or even larger. (the public exponent e is sometimes chosen
to be a small value, but d is always very long.) straightforward exponentiation as
shown above would thus require around 21024 or more multiplications. since the
number of atoms in the visible universe is estimated to be around 2300 , computing 21024 multiplications to set up one secure session for our web browser is not

180

7 the rsa cryptosystem

too tempting. the central question is whether there are considerably faster methods for exponentiation available. the answer is, luckily, yes. otherwise we could
forget about rsa and pretty much all other public-key cryptosystems in use today,
since they all rely on exponentiation. one such method is the square-and-multiply
algorithm. we first show a few illustrative examples with small numbers before presenting the actual algorithm.
example 7.2. lets look at how many multiplications are required to compute the
simple exponentiation x8 . with the straightforward method
sq

mul

mul

mul

mul

mul

mul

x  x2  x3  x4  x5  x6  x7  x8
we need seven multiplications and squarings. alternatively, we can do something
faster
sq
sq
sq
x  x2  x4  x8
which requires only three squarings that are roughly as complex as a multiplication.

this fast method works fine but is restricted to exponents that are powers of 2,
i.e., values e and d of the form 2i . now the question is, whether we can extend the
method to arbitrary exponents let us look at another example
example 7.3. this time we have the more general exponent 26, i.e., we want to
compute x26 . again, the nave method would require 25 multiplications. a faster
way is as follows
sq

mul

sq

sq

mul

sq

x  x2  x3  x6  x12  x13  x26 .
this approach takes a total of six operations, two multiplications and four squarings.

looking at the last example, we see that we can achieve the desired result by
performing two basic operations
1. squaring the current result,
2. multiplying the current result by the base element x.
in the example above we computed the sequence sq, mul, sq, sq, mul, sq.
however, we do not know the sequence in which the squarings and multiplications
have to be performed for other exponents. one solution is the square-and-multiply
algorithm. it provides a systematic way for finding the sequence in which we have
to perform squarings and multiplications by x for computing xh . roughly speaking,
the algorithm works as follows
the algorithm is based on scanning the bit of the exponent from the left (the
most significant bit) to the right (the least significant bit). in every iteration, i.e.,
for every exponent bit, the current result is squared. if and only if the currently

7.4 encryption and decryption fast exponentiation

181

scanned exponent bit has the value 1, a multiplication of the current result by
x is executed following the squaring.
this seems like a simple if somewhat odd rule. for better understanding, lets
revisit the example from above. this time, lets pay close attention to the exponent
bits.
example 7.4. we again consider the exponentiation x26 . for the square-and-multiply
algorithm, the binary representation of the exponent is crucial
x26  x110102  x(h4 h3 h2 h1 h0 )2 .
the algorithm scans the exponent bits, starting on the left with h4 and ending with
the rightmost bit h0 .
step
0 x  x12

inital setting, bit processed h4  1

1a (x1 )2  x2  x102
1b x2  x  x3  x102 x12  x112

sq, bit processed h3
mul, since h3  1

2a (x3 )2  x6  (x112 )2  x1102
2b

sq, bit processed h2
no mul, since h2  0

3a (x6 )2  x12  (x1102 )2  x11002
3b x12  x  x13  x11002 x12  x11012

sq, bit processed h1
mul, since h1  1

4a (x13 )2  x26  (x11012 )2  x110102
4b

sq, bit processed h0
no mul, since h0  0

to understand the algorithm it is helpful to closely observe how the binary representation of the exponent evolves. we see that the first basic operation, squaring,
results in a left shift of the exponent, with a 0 put in the rightmost position. the other
basic operation, multiplication by x, results in filling a 1 into the rightmost position
of the exponent. compare how the highlighted exponents change from iteration to
iteration.

here is the pseudo code for the square-and-multiply algorithm

182

7 the rsa cryptosystem

square-and-multiply for modular exponentiation
input
base element x
exponent h  ti0 hi 2i with hi  0, 1 and ht  1
and modulus n
output xh mod n
initialization r  x
algorithm
1 for i  t  1 downto 0
1.1
r  r2 mod n
if hi  1
1.2
r  r  x mod n
2 return (r)
the modulo reduction is applied after each multiplication and squaring operation
in order to keep the intermediate results small. it is helpful to compare this pseudo
code with the verbal description of the algorithm above.
we determine now the complexity of the square-and-multiply algorithm for an
exponent h with a bit length of t + 1, i.e., log2 h  t + 1. the number of squarings
is independent of the actual value of h, but the number of multiplications is equal
to the hamming weight, i.e., the number of ones in its binary representation. thus,
we provide here the average number of multiplication, denoted by mul
sq  t
mul  0.5t
because the exponents used in cryptography have often good random properties,
assuming that half of their bits have the value one is often a valid approximation.
example 7.5. how many operations are required on average for an exponentiation
with a 1024-bit exponent
straightforward exponentiation takes 21024  10300 multiplications. that is completely impossible, no matter what computer resources we might have at hand. however, the square-and-multiply algorithm requires only
1.5  1024  1536
squarings and multiplications on average. this is an impressive example for the
difference of an algorithm with linear complexity (straightforward exponentiation)
and logarithmic complexity (square-and-multiply algorithm). remember, though,
that each of the 1536 individual squarings and multiplications involves 1024-bit
numbers. that means the number of integer operations on a cpu is much higher
than 1536, but certainly doable on modern computers.


7.5 speed-up techniques for rsa

183

7.5 speed-up techniques for rsa
as we learned in sect. 7.4, rsa involves exponentiation with very long numbers.
even if the low-level arithmetic involving modular multiplication and squaring as
well as the square-and-multiply algorithm are implemented carefully, performing a
full rsa exponentiation with operands of length 1024 bit or beyond is computationally intensive. thus, people have studied speed-up techniques for rsa since its
invention. we introduce two of the most popular general acceleration techniques in
the following.

7.5.1 fast encryption with short public exponents
a surprisingly simple and very powerful trick can be used when rsa operations
with the public key e are concerned. this is in practice encryption and, as well
learn later, verification of an rsa digital signature. in this situation, the public key
e can be chosen to be a very small value. in practice, the three values e  3, e  17
and e  216 + 1 are of particular importance. the resulting complexities when using
these public keys are given in table 7.1.
table 7.1 complexity of rsa exponentiation with short public exponents
public key e
e as binary string mul + sq
3
112
3
17
100012
5
216 + 1 1 0000 0000 0000 00012
17

these complexities should be compared to the 1.5t multiplications and squarings
that are required for exponents of full length. here t + 1 is the bit length of the
rsa modulus n, i.e., log2 n  t + 1. we note that all three exponents listed above
have a low hamming weight, i.e., number of ones in the binary representation. this
results in a particularly low number of operations for performing an exponentiation.
interestingly, rsa is still secure if such short exponents are being used. note that
the private key d still has in general the full bit length t + 1 even though e is short.
an important consequence of the use of short public exponents is that encryption
of a message and verification of an rsa signature is a very fast operation. in fact,
for these two operations, rsa is in almost all practical cases the fastest public-key
scheme available. unfortunately, there is no such easy way to accelerate rsa when
the private key d is involved, i.e., for decryption and signature generation. hence,
these two operations tend to be slow. other public-key algorithms, in particular elliptic curves, are often much faster for these two operations. the following section
shows how we can achieve a more moderate speed-up when using the private exponent d.

184

7 the rsa cryptosystem

7.5.2 fast decryption with the chinese remainder theorem
we cannot choose a short private key without compromising the security for rsa.
if we were to select keys d as short as we did in the case of encryption in the section
above, an attacker could simply brute-force all possible numbers up to a given bit
length, i.e., 50 bit. but even if the numbers are larger, say 128 bit, there are key
recovery attacks. in fact, it can be shown that the private key must have a length of
at least 0.3t bit, where t is the bit length of the modulus n. in practice, e is often
chosen short and d has full bit length. what one does instead is to apply a method
which is based on the chinese remainder theorem (crt). we do not introduce
the crt itself here but merely how it applies to accelerate rsa decryption and
signature generation.
our goal is to perform the exponentiation xd mod n efficiently. first we note that
the party who possesses the private key also knows the primes p and q. the basic
idea of the crt is that rather than doing arithmetic with one long modulus n,
we do two individual exponentiations modulo the two short primes p and q. this
is a type of transformation arithmetic. like any transform, there are three steps
transforming into the crt domain, computation in the crt domain, and inverse
transformation of the result. those three steps are explained below.

transformation of the input into the crt domain
we simply reduce the base element x modulo the two factors p and q of the modulus
n, and obtain what is called the modular representation of x.
x p  x mod p
xq  x mod q

exponentiation in the crt domain
with the reduced versions of x we perform the following two exponentiations
d

y p  x pp mod p
d

yq  xqq mod q
where the two new exponents are given by
d p  d mod (p  1)
dq  d mod (q  1)
note that both exponents in the transform domain, d p and dq , are bounded by p and
q, respectively. the same holds for the transformed results y p and yq . since the two

7.5 speed-up techniques for rsa

185

primes are in practice chosen to have roughly the same bit length, the two exponents
as well as y p and yq have about half the bit length of n.

inverse transformation into the problem domain
the remaining step is now to assemble the final result y from its modular representation (y p , yq ). this follows from the crt and can be done as
y  [q c p ] y p + [p cq ] yq mod n

(7.7)

where the coefficients c p and cq are computed as
c p  q1 mod p,

cq  p1 mod q

since the primes change very infrequently for a given rsa implementation, the two
expressions in brackets in eq. (7.7) can be precomputed. after the precomputations,
the entire reverse transformation is achieved with merely two modular multiplications and one modular addition.
before we consider the complexity of rsa with crt, lets have a look at an
example.
example 7.6. let the rsa parameters be given by
p  11
e 7
q  13
d  e1  103 mod 120
n  p  q  143
we now compute an rsa decryption for the ciphertext y  15 using the crt, i.e.,
the value yd  15103 mod 143. in the first step, we compute the modular representation of y
y p  15  4 mod 11
y p  15  2 mod 13
in the second step, we perform the exponentiation in the transform domain with the
short exponents. these are
d p  103  3 mod 10
dq  103  7 mod 12
here are the exponentiations
d

x p  y pp  43  64  9 mod 11
d

xq  yqq  27  128  11 mod 13
in the last step, we have to compute x from its modular representation (x p , xq ). for
this, we need the coefficients

186

7 the rsa cryptosystem

c p  131  21  6 mod 11

cq  111  6 mod 13

the plaintext x follows now as
x  [qc p ]x p + [pcq ]xq mod n
x  [13  6]9 + [11  6]11 mod 143
x  702 + 726  1428  141 mod 143

if you want to verify the result, you can compute yd mod 143 using the square-andmultiply algorithm.
we will now establish the computational complexity of the crt method. if we
look at the three steps involved in the crt-based exponentiation, we conclude that
for a practical complexity analysis the transformation and inverse transformation
can be ignored since the operations involved are negligible compared to the actual
exponentiations in the transform domain. for convenience, we restate these crt
exponentiations here
d

y p  x pp mod p
d

yq  xqq mod q
if we assume that n has t + 1 bit, both p and q are about t/2 bit long. all numbers
involved in the crt exponentiations, i.e., x p , xq , d p and dq , are bound in size by
p and q, respectively, and thus also have a length of about t/2 bit. if we use the
square-and-multiply algorithm for the two exponentiations, each requires on average
approximately 1.5t/2 modular multiplications and squarings. together, the number
of multiplications and squarings is thus
sq + mul  2  1.5t/2  1.5t
this appears to be exactly the same computational complexity as regular exponentiation without the crt. however, each multiplication and squaring involves numbers which have a length of only t/2 bit. this is in contrast to the operations without
crt, where each multiplication was performed with t-bit variables. since the complexity of multiplication decreases quadratically with the bit length, each t/2-bit
multiplication is four times faster than a t-bit multiplication.1 thus, the total speedup obtained through the crt is a factor of 4. this speed-up by four can be very
valuable in practice. since there are hardly any drawbacks involved, crt-based
exponentiations are used in many cryptographic products, e.g., for web browser
encryption. the method is also particularly valuable for implementations on smart
1 the reason for the quadratic complexity is easy to see with the following example. if we multiply
a 4-digit decimal number abcd by another number wxyz, we multiply each digit from the first
operand with each digit of the second operand, for a total of 42  16 digit multiplications. on the
other hand, if we multiply two numbers with two digits, i.e., ab times wx, only 22  4 elementary
multiplications are needed.

7.6 finding large primes

187

cards, e.g., for banking applications, which are only equipped with a small microprocessor. here, digital signing is often needed, which involves the secret key d. by
applying the crt for signature computation, the smart card is four times as fast.
for example, if a regular 1024-bit rsa exponentiation takes 3 sec, using the crt
reduces that time to 0.75 sec. this acceleration might make the difference between a
product with high customer acceptance (0.75 sec) and a product with a delay that is
not acceptable for many applications (3 sec). this example is a good demonstration
how basic number theory can have direct impact in the real world.

7.6 finding large primes
there is one important practical aspect of rsa which we have not discussed yet
generating the primes p and q in step 1 of the key generation. since their product
is the rsa modulus n  p  q, the two primes should have about half the bit length
of n. for instance, if we want to set up rsa with a modulus of length log2 n 
1024, p and q should have a bit length of about 512 bit. the general approach is
to generate integers at random which are then checked for primality, as depicted in
fig. 7.2, where rng stands for random number generator. the rng should be non
predictable because if an attacker can compute or guess one of the two primes, rsa
can be broken easily as we will see later in this chapter.





 

 

  


   




fig. 7.2 principal approach to generating primes for rsa

in order to make this approach work, we have to answer two questions
1. how many random integers do we have to test before we have a prime (if the
likelihood of a prime is too small, it might take too long.)
2. how fast can we check whether a random integer is prime (again, if the test is
too slow, the approach is impractical.)
it turns out that both steps are reasonably fast, as is discussed in the following.

7.6.1 how common are primes
now well answer the question whether the likelihood that a randomly picked integer p is a prime is sufficiently high. we know from looking at the first few positive

188

7 the rsa cryptosystem

integers that primes become less dense as the value increases
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, . . .
the question is whether there is still a reasonable chance that a random number
with, say, 512 bit, is a prime. luckily, this is the case. the chance that a randomly
picked integer p is a prime follows from the famous prime number theorem and is
approximately 1/ ln( p). in practice, we only test odd numbers so that the likelihood
doubles. thus, the probability for a random odd number p to be prime is
p( p is prime) 

2
.
ln( p)

in order to get a better feeling for what this probability means for rsa primes, lets
look at an example
example 7.7. for rsa with a 1024-bit modulus n, the primes p and q each should
have a length of about 512 bits, i.e., p, q  2512 . the probability that a random odd
number p is a prime is
p( p is prime) 

2
2
1


.
ln(2512 ) 512 ln(2) 177

this means that we expect to test 177 random numbers before we find one that is a
prime.

the likelihood of integers being primes decreases slowly, proportional to the bit
length of the integer. this means that even for very long rsa parameters, say with
4096 bit, the density of primes is still sufficiently high.

7.6.2 primality tests
the other step we have to do is to decide whether the randomly generated integers p
are primes. a first idea could be to factor the number in question. however, for the
numbers used in rsa, factorization is not possible since p and q are too large. (in
fact, we especially choose numbers that cannot be factored because factoring n is the
best known attack against rsa.) the situation is not hopeless, though. remember
that we are not interested in the factorization of p. instead we merely need the
statement whether the number being tested is a prime or not. it turns out that such
primality tests are computationally much easier than factorization. examples for
primality tests are the fermat test, the millerrabin test or variants of them. we
introduce primality test algorithms in this section.
practical primality tests behave somewhat unusually if the integer p in question
is being fed into a primality test algorithm, the answer is either

7.6 finding large primes

189

1.  p is composite (i.e., not a prime), which is always a true statement, or
2.  p is prime, which is only true with a high probability.
if the algorithm output is composite, the situation is clear the integer in question
is not a prime and can be discarded. if the output statement is prime, p is probably
a prime. in rare cases, however, an integers prompts a prime statement but it lies,
i.e., it yields an incorrect positive answer. there is way to deal with this behavior.
practical primality tests are probabilistic algorithms. that means they have a second
parameter a as input which can be chosen at random. if a composite number p
together with a parameter a yields the incorrect statement  p is prime, we repeat
the test a second time with a different value for a. the general strategy is to test a
prime candidate p so often with several different random values a that the likelihood
that the pair ( p, a) lies every single time is sufficiently small, say, less than 280 .
remember that as soon as the statement  p is composite occurs, we know for
certain that p is not a prime and we can discard it.

fermat primality test
one primality test is based on fermats little theorem, theorem (6.3.2).
fermat primality test
input prime candidate p and security parameter s
output statement  p is composite or  p is likely prime
algorithm
1
for i  1 to s
1.1
choose random a  {2, 3, . . . , p  2}
1.2
if a p1  1
1.3
return ( p is composite)
2
return ( p is likely prime)
the idea behind the test is that fermats theorem holds for all primes. hence,
if a number is found for which a p1  1 in step 1.2, it is certainly not a prime.
however, the reverse is not true. there could be composite numbers which in fact
fulfill the condition a p1  1. in order to detect them, the algorithm is run s times
with different values of a.
unfortunately, there are certain composite integers which behave like primes in
the fermat test for many values of a. these are the carmichael numbers. given a
carmichael number c, the following expression holds for all integers a for which
gcd(a,c)  1
ac1  1 mod c
such special composites are very rare. for instance, there exist approximately only
100, 000 carmichael numbers below 1015 .

190

7 the rsa cryptosystem

example 7.8. carmichael number
n  561  3  11  17 is a carmichael number since
a560  1 mod 561
for all gcd(a, 561)  1.

if the prime factors of a carmichael numbers are all large, there are only few bases
a for which fermats test detects that the number is actually composite. for this
reason, in practice the more powerful millerrabin test is often used to generate
rsa primes.

millerrabin primality test
in contrast to fermats test, the millerrabin test does not have any composite numbers for which a large number of base elements a yield the statement prime. the
test is based on the following theorem
theorem 7.6.1 given the decomposition of an odd prime candidate p
p  1  2u r
where r is odd. if we can find an integer a such that
ar  1 mod p

and

j

ar 2  p  1 mod p

for all j  {0, 1, . . . , u  1}, then p is composite. otherwise, it is
probably a prime.
we can turn this into an efficient primality test.

7.6 finding large primes

191

millerrabin primality test
input prime candidate p with p  1  2u r and security parameter s
output statement  p is composite or  p is likely prime
algorithm
1
1.2
1.3
1.4

1.5
2

for i  1 to s
choose random a  {2, 3, . . . , p  2}
z  ar mod p
if z  1 and z  p  1
for j  1 to u  1
z  z2 mod p
if z  1
return ( p is composite)
if z  p  1
return ( p is composite)
return ( p is likely prime)

step 1.2 is computed by using the square-and-multiply algorithm. the if statement
in step 1.3 tests the theorem for the case j  0. the for loop 1.4 and the if statement 1.5 test the right-hand side of the theorem for the values j  1, . . . , u  1.
it can still happen that a composite number p gives the incorrect statement
prime. however, the likelihood of this rapidly decreases as we run the test with
several different random base elements a. the number of runs is given by the security parameter s in the millerrabin test. table 7.2 shows how many different values
a must be chosen in order to have a probability of less than 280 that a composite is
incorrectly detected as a prime.
table 7.2 number of runs within the millerrabin primality test for an error probability of less
than 280
bit lengths of p security parameter s
250
11
300
9
400
6
500
5
600
3

example 7.9. millerrabin test
let p  91. write p as p  1  21  45. we select a security parameter of s  4. now,
choose s times a random value a
1. let a  12 z  1245  90 mod 91, hence, p is likely prime.
2. let a  17 z  1745  90 mod 91, hence, p is likely prime.
3. let a  38 z  3845  90 mod 91, hence, p is likely prime.

192

7 the rsa cryptosystem

4. let a  39 z  3945  78 mod 91, hence, p is composite.
since the numbers 12, 17 and 38 give incorrect statements for the prime candidate
p  91, they are called liars for 91.


7.7 rsa in practice padding
what we described so far is the so-called schoolbook rsa system which has several weaknesses. in practice rsa has to be used with a padding scheme. padding
schemes are extremely important, and if not implemented properly, an rsa implementation may be insecure. the following properties of schoolbook rsa encryption
are problematic





rsa encryption is deterministic, i.e., for a specific key, a particular plaintext
is always mapped to a particular ciphertext. an attacker can derive statistical
properties of the plaintext from the ciphertext. furthermore, given some pairs
of plaintextciphertext, partial information can be derived from new ciphertexts
which are encrypted with the same key.
plaintext values x  0, x  1, or x  1 produce ciphertexts equal to 0, 1, or 1.
small public exponents e and small plaintexts x might be subject to attacks if
no padding or weak padding is used. however, there is no known attack against
small public exponents such as e  3.

rsa has another undesirable property, namely that it is malleable. a crypto
scheme is said to be malleable if the attacker oscar is capable of transforming the ciphertext into another ciphertext which leads to a known transformation of the plaintext. note that the attacker does not decrypt the ciphertext but is merely capable of
manipulating the plaintext in a predictable manner. this is easily achieved in the
case of rsa if the attacker replaces the ciphertext y by se y, where s is some integer.
if the receiver decrypts the manipulated ciphertext, he computes
(se y)d  sed xed  s x mod n.
even though oscar is not able to decrypt the ciphertext, such targeted manipulations
can still do harm. for instance, if x were an amount of money which is to be transferred or the value of a contract, by choosing s  2 oscar could exactly double the
amount in a way that goes undetected by the receiver.
a possible solution to all these problems is the use of padding, which embeds a random structure into the plaintext before encryption and avoids the above
mentioned problems. modern techniques such as optimal asymmetric encryption
padding (oaep) for padding rsa messages are specified and standardized in public key cryptography standard 1 (pkcs 1).
let m be the message to be padded, let k be the length of the modulus n in
bytes, let h be the length of the hash function output in bytes and let m be the

7.7 rsa in practice padding

193

length of the message in bytes. a hash function computes a message digest of fixed
length (e.g., 160 or 256 bit) for every input. more about hash functions is found
in chap. 11. furthermore, let l be an optional label associated with the message
(otherwise, l is an empty string as default). according to the most recent version
pkcs1 (v2.1), padding a message within the rsa encryption scheme is done in
the following way
1. generate a string ps of length k  m  2h  2 of zeroed bytes. the length of
ps may be zero.
2. concatenate hash(l), ps, a single byte with hexadecimal value 0x01, and the
message m to form a data block db of length k  h  1 bytes as
db  hash(l)ps0x01m.
3. generate a random byte string seed of length h.
4. let dbmask  mgf(seed, k h1), where mgf is the mask generation function. in practice, a hash function such as sha-1 is often used as mfg.
5. let maskeddb  db  dbmask.
6. let seedmask  mgf(maskeddb, h).
7. let maskedseed  seed  seedmask.
8. concatenate a single byte with hexadecimal value 0x00, maskedseed and
maskeddb to form an encoded message em of length k bytes as
em  0x00maskedseedmaskeddb.
figure 7.3 shows the structure of a padded message m.

seed

hash(l) 

ps



0x01



m

0x00
seedmask

1

dbmask

h

kh1

k

fig. 7.3 rsa encryption of a message m with optimal asymmetric encryption padding (oaep)

on the decryption side, the structure of the decrypted message has to be verified.
for instance, if there is no byte with hexadecimal value 0x01 to separate ps from
m, a decryption error occurred. in any case, returning a decryption error to the user
(or a potential attacker) should not reveal any information about the plaintext.

194

7 the rsa cryptosystem

7.8 attacks
there have been numerous attacks proposed against rsa since it was invented in
1977. none of the attacks are serious, and moreover, they typically exploit weaknesses in the way rsa is implemented or used rather than the rsa algorithm itself.
there are three general attack families against rsa
1. protocol attacks
2. mathematical attacks
3. side-channel attacks
we comment on each of them in the following.

protocol attacks
protocol attacks exploit weaknesses in the way rsa is being used. there have been
several protocol attacks over the years. among the better known ones are the attacks
that exploit the malleability of rsa, which was introduced in the previous section.
many of them can be avoided by using padding. modern security standards describe
exactly how rsa should be used, and if one follows those guidelines, protocol
attacks should not be possible.

mathematical attacks
the best mathematical cryptanalytical method we know is factoring the modulus.
an attacker, oscar, knows the modulus n, the public key e and the ciphertext y. his
goal is to compute the private key d which has the property that e  d  mod  (n).
it seems that he could simply apply the extended euclidean algorithm and compute
d. however, he does not know the value of  (n). at this point factoring comes in
the best way to obtain this value is to decompose n into its primes p and q. if oscar
can do this, the attack succeeds in three steps

 (n)  (p  1)(q  1)
d 1  e mod  (n)
x  yd mod n.
in order to prevent this attack, the modulus must be sufficiently large. this is the
sole reason why moduli of 1024 or more bit are needed for a rsa. the proposal of
the rsa scheme in 1977 sparked much interest in the old problem of integer factorization. in fact, the major progress that has been made in factorization in the last
three decades would most likely not have happened if it werent for rsa. table 7.3
shows a summary of the rsa factoring records that have occurred since the beginning of the 1990s. these advances have been possible mainly due to improvements
in factoring algorithms, and to a lesser extent due to improved computer technology.

7.8 attacks

195

even though factoring has become easier than the rsa designers had assumed 30
years ago, factoring rsa moduli beyond a certain size still is out of reach.
table 7.3 summary of rsa factoring records since 1991
decimal digits bit length
date
100
330
april 1991
110
364
april 1992
120
397
june 1993
129
426
april 1994
140
463
february 1999
155
512
august 1999
200
664
may 2005

of historical interest is the 129-digit modulus which was published in a column
by martin gardner in scientific american in 1997. it was estimated that the best
factoring algorithms of that time would take 40 trillion (4  1013 ) years. however,
factoring methods improved considerably, particularly during the 1980s and 1990s,
and it took in fact less than 30 years.
which exact length the rsa modulus should have is the topic of much discussion. until recently, many rsa applications used a bit length of 1024 bits as default.
today it is believed that it might be possible to factor 1024-bit numbers within a period of about 1015 years, and intelligence organizations might be capable of doing
it possibly even earlier. hence, it is recommended to choose rsa parameters in the
range of 20484096 bits for long-term security.

side-channel attacks
a third and entirely different family of attacks are side-channel attacks. they exploit
information about the private key which is leaked through physical channels such as
the power consumption or the timing behavior. in order to observe such channels, an
attacker must typically have direct access to the rsa implementation, e.g., in a cell
phone or a smart card. even though side-channel attacks are a large and active field
of research in modern cryptography and beyond the scope of this book, we show
one particularly impressive such attack against rsa in the following.
figure 7.4 shows the power trace of an rsa implementation on a microprocessor. more precisely, it shows the electric current drawn by the processor over time.
our goal is to extract the private key d which is used during the rsa decryption.
we clearly see intervals of high activity between short periods of less activity. since
the main computational load of rsa is the squarings and multiplication during the
exponentiation, we conclude that the high-activity intervals correspond to those two
operations. if we look more closely at the power trace, we see that there are high
activity intervals which are short and others which are longer. in fact, the longer
ones appear to be about twice as long. this behavior is explained by the squareand-multiply algorithm. if an exponent bit has the value 0, only a squaring is per-

196

7 the rsa cryptosystem

formed. if an exponent bit has the value 1, a squaring together with a multiplication
is computed. but this timing behavior reveals immediately the key a long period
of activity corresponds to the bit value 1 of the secret key, and a short period to a
key bit with value 0. as shown in the figure, by simply looking at the power trace
we can identify the secret exponent. thus we can learn the following 12 bits of the
private key by looking at the trace
operations
private key

s sm sm s sm s s sm sm sm s sm
0 1 1 0 1 00 1 1 1 0 1

obviously, in real-life we can also find all 1024 or 2048 bits of a full private key.
during the short periods with low activity, the square-and-multiply algorithm scans
and processes the exponent bits before it triggers the next squaring or squaring-andmultiplication sequence.

fig. 7.4 the power trace of an rsa implementation

this specific attack is classified as simple power analysis or spa. there are several countermeasures available to prevent the attack. a simple one is to execute a
multiplication with dummy variables after a squaring that corresponds to an exponent bit 0. this results in a power profile (and a run time) which is independent
of the exponent. however, countermeasures against more advanced side-channel attacks are not as straightforward.

7.9 implementation in software and hardware

197

7.9 implementation in software and hardware
rsa is the prime example (almost literally) for a public-key algorithm that is very
computationally intensive. hence, the implementation of public-key algorithms is
much more crucial than that of symmetric ciphers like 3des and aes, which are
significantly faster. in order to get an appreciation for the computational load, we
develop a rough estimate for the number of integer multiplications needed for an
rsa operation.
we assume a 2048-bit rsa modulus. for decryption we need on average 3072
squaring and multiplications, each of which involves 2048-bit operands. lets assume a 32-bit cpu so that each operand is represented by 2048/32  64 registers.
a single long-number multiplication requires now 642  4096 integer multiplications since we have to multiply every register of the first operand with every register
of the second operand. in addition, we have to modulo reduce each of these multiplications. the best algorithms for doing this also require roughly 642  4096 integer
multiplications. thus, in total, the cpu has to perform about 4096 + 4096  8192
integer multiplications for a single long-number multiplication. since we have 3072
of these, the number of integer multiplications for one decryption is
(32-bit mult)  3072  8192  25, 165, 824
of course, using a smaller modulus results in fewer operations, but given that integer
multiplications are among the most costly operations on current cpus, it is probably
clear that the computational demand is quite impressive. note that most other public
key schemes have a similar complexity.
the extremely high computational demand of rsa was, in fact, a serious hindrance to its adoption in practice after it had been invented. doing hundreds of
thousands of integer multiplications was out of question with 1970s-style computers. the only option for rsa implementations with an acceptable run time was
to realize rsa on special hardware chips until the mid- to late 1980s. even the
rsa inventors investigated hardware architecture in the early days of the algorithm.
since then much research has focused on ways to quickly perform modular integer
arithmetic. given the enormous capabilities of state-of-the-art vlsi chips, an rsa
operation can today be done in the range of 100  s on high-speed hardware.
similarly, due to moores law, rsa implementations in software have become
possible since the late 1980s. today, a typical decryption operation on a 2 ghz cpu
takes around 10 ms for 2048-bit rsa. even though this is sufficient for many pc
applications, the throughput is about 100  2048  204, 800 bit/s if one uses rsa
for encryption of large amounts of data. this is quite slow compared to the speed of
many of todays networks. for this reason rsa and other public-key algorithms are
not used for bulk data encryption. rather, symmetric algorithms are used that are
often faster by a factor of 1000 or so.

198

7 the rsa cryptosystem

7.10 discussion and further reading
rsa and variants the rsa cryptosystem is widely used in practice and is well
standardized in bodies such as pkcs1 [149]. over the years several variants have
been proposed. one generalization is to use a modulus which is composed of more
than two primes. also proposed have been multipower moduli of the form n  p2 q
[162] as well as multifactor ones where n  p q r [45]. in both cases speed-ups by a
factor of approximately 23 are possible.
there are also several other crypto schemes which are based on the integer factorization problem. a prominent one is the rabin scheme [140]. in contrast to rsa,
it can be shown that the rabin scheme is equivalent to factoring. thus, it is said
that the cryptosystem is provable secure. other schemes which rely on the hardness of integer factorization include the probabilistic encryption scheme by blum
goldwasser [28] and the blum blum shub pseudo-random number generator [27].
the handbook of applied cryptography [120] describes all the schemes mentioned
in a coherent form.
implementation the actual performance of an rsa implementation heavily depends on the efficiency of the arithmetic used. generally speaking, speed-ups are
possible at two levels. on the higher level, improvements of the square-and-multiply
algorithm are an option. one of the fastest methods is the sliding window exponentiation which gives an improvement of about 25% over the square-and-multiply algorithm. a good compilation of exponentiation methods is given in [120, chap. 14].
on the lower layer, modular multiplication and squaring with long numbers can be
improved. one set of techniques deals with efficient algorithms for modular reduction. in practice, montgomery reduction is the most popular choice see [41] for a
good treatment of software techniques and [72] for hardware. several alternatives
to the montgomery method have also been proposed over the years [123] [120,
chap. 14]. another angle to accelerate long number arithmetic is to apply fast multiplication methods. spectral techniques such as the fast fourier transform (fft) are
usually not applicable because the operands are still too short, but methods such as
the karatsuba algorithm [99] are very useful. reference [17] gives a comprehensive
but fairly mathematical treatment of the area of multiplication algorithms, and [172]
describes the karatsuba method from a practical viewpoint.
attacks breaking rsa analytically has been a subject of intense investigation for
the last 30 years. especially during the 1980s, major progress in factorization algorithms was made, which was not in small part motivated by rsa. there have been
numerous other attempts to mathematically break rsa, including attacks against
short private exponents. a good survey is given in [32]. more recently, proposals
have been made to build special computers whose sole purpose is to break rsa.
proposals include an optoelectronic factoring machine [151] and several other architectures based on conventional semiconductor technology [152, 79].
side channel attacks have been systematically studied in academia and industry
since the mid- to late 1990s. rsa, as well as most other symmetric and asymmetric
schemes, are vulnerable against differential power analysis (dpa), which is more

7.11 lessons learned

199

powerful than the simple power analysis (spa) shown in this section. on the other
hand, numerous countermeasures against dpa are known. good references are the
side channel cryptanalysis lounge [70] and the excellent book on dpa [113].
related implementation-based attacks are fault injection attacks and timing attacks.
it is important to stress that a cryptosystem can be mathematically very strong but
still be vulnerable to side-channel attacks.

7.11 lessons learned








rsa is the most widely used public-key cryptosystem. in the future, elliptic
curve cryptosystems will probably catch up in popularity.
rsa is mainly used for key transport (i.e., encryption of keys) and digital signatures.
the public key e can be a short integer. the private key d needs to have the
full length of the modulus. hence, encryption can be significantly faster than
decryption.
rsa relies on the integer factorization problem. currently, 1024-bit (about 310
decimal digits) numbers cannot be factored. progress in factorization algorithms
and factorization hardware is hard to predict. it is advisable to use rsa with
a 2048-bit modulus if one needs reasonable long-term security, especially with
respect to extremely well funded attackers.
schoolbook rsa allows several attacks, and in practice rsa should be used
together with padding.

200

7 the rsa cryptosystem

problems
7.1. let the two primes p  41 and q  17 be given as set-up parameters for rsa.
1. which of the parameters e1  32, e2  49 is a valid rsa exponent justify your
choice.
2. compute the corresponding private key kpr  (p, q, d). use the extended euclidean algorithm for the inversion and point out every calculation step.
7.2. computing modular exponentiation efficiently is inevitable for the practicability of rsa. compute the following exponentiations xe mod m applying the squareand-multiply algorithm
1. x  2, e  79, m  101
2. x  3, e  197, m  101
after every iteration step, show the exponent of the intermediate result in binary
notation.
7.3. encrypt and decrypt by means of the rsa algorithm with the following system
parameters
1. p  3, q  11, d  7, x  5
2. p  5, q  11, e  3, x  9
only use a pocket calculator at this stage.
7.4. one major drawback of public-key algorithms is that they are relatively slow.
in sect. 7.5.1 we learned that an acceleration technique is to use short exponents e.
now we study short exponents in this problem in more detail.
1. assume that in an implementation of the rsa cryptosystem one modular squaring takes 75% of the time of a modular multiplication. how much quicker is
one encryption on average if instead of a 2048-bit public key the short exponent
e  216 + 1 is used assume that the square-and-multiply algorithm is being used
in both cases.
2. most short exponents are of the form e  2n + 1. would it be advantageous to
use exponents of the form 2n  1 justify your answer.
3. compute the exponentiation xe mod 29 of x  5 with both variants of e from
above for n  4. use the square-and-multiply algorithm and show each step of
your computation.
7.5. in practice the short exponents e  3, 17 and 216 + 1 are widely used.
1. why cant we use these three short exponents as values for the exponent d in
applications where we want to accelerate decryption
2. suggest a minimum bit length for the exponent d and explain your answer.
7.6. verify the rsa with crt example in the chapter by computing yd  15103 mod
143 using the square-and-multiply algorithm.

problems

201

7.7. an rsa encryption scheme has the set-up parameters p  31 and q  37. the
public key is e  17.
1. decrypt the ciphertext y  2 using the crt.
2. verify your result by encrypting the plaintext without using the crt.
7.8. popular rsa modulus sizes are 1024, 2048, 3072 and 4092 bit.
1. how many random odd integers do we have to test on average until we expect to
find one that is a prime
2. derive a simple formula for any arbitrary rsa modulus size.
7.9. one of the most attractive applications of public-key algorithms is the establishment of a secure session key for a private-key algorithm such as aes over an
insecure channel.
assume bob has a pair of public/private keys for the rsa cryptosystem. develop
a simple protocol using rsa which allows the two parties alice and bob to agree
on a shared secret key. who determines the key in this protocol, alice, bob, or both
7.10. in practice, it is sometimes desirable that both communication parties influence the selection of the session key. for instance, this prevents the other party from
choosing a key which is a weak key for a symmetric algorithm. many block ciphers
such as des and idea have weak keys. messages encrypted with weak keys can
be recovered relatively easily from the ciphertext.
develop a protocol similar to the one above in which both parties influence the
key. assume that both alice and bob have a pair of public/private keys for the rsa
cryptosystem. please note that there are several valid approaches to this problem.
show just one.
7.11. in this exercise, you are asked to attack an rsa encrypted message. imagine
being the attacker you obtain the ciphertext y  1141 by eavesdropping on a certain
connection. the public key is k pub  (n, e)  (2623, 2111).
1. consider the encryption formula. all variables except the plaintext x are known.
why cant you simply solve the equation for x
2. in order to determine the private key d, you have to calculate d  e1 mod  (n).
there is an efficient expression for calculating  (n). can we use this formula
here
3. calculate the plaintext x by computing the private key d through factoring n 
p  q. does this approach remain suitable for numbers with a length of 1024 bit
or more
7.12. we now show how an attack with chosen ciphertext can be used to break an
rsa encryption.
1. show that the multiplicative property holds for rsa, i.e., show that the product
of two ciphertexts is equal to the encryption of the product of the two respective
plaintexts.

202

7 the rsa cryptosystem

2. this property can under certain circumstances lead to an attack. assume that
bob first receives an encrypted message y1 from alice which oscar obtains by
eavesdropping. at a later point in time, we assume that oscar can send an innocent looking ciphertext y2 to bob, and that oscar can obtain the decryption of y2 .
in practice this could, for instance, happen if oscar manages to hack into bobs
system such that he can get access to decrypted plaintext for a limited period of
time.
7.13. in this exercise, we illustrate the problem of using nonprobabilistic cryptosystems, such as schoolbook rsa, imprudently. nonprobabilistic means that the same
sequence of plaintext letters maps to the same ciphertext. this allows traffic analysis
(i.e., to draw some conclusion about the cleartext by merely observing the ciphertext) and in some cases even to the total break of the cryptoystem. the latter holds
especially if the number of possible plaintexts is small. suppose the following situation
alice wants to send a message to bob encrypted with his public key pair (n, e).
therefore, she decides to use the ascii table to assign a number to each character
(space  32,   33, . . . , a  65, b  66, . . . ,  126) and to encrypt them
separately.
1. oscar eavesdrops on the transferred ciphertext. describe how he can successfully
decrypt the message by exploiting the nonprobabilistic property of rsa.
2. bobs rsa public key is (n, e)  (3763, 11). decrypt the ciphertext
y  2514, 1125, 333, 3696, 2514, 2929, 3368, 2514
with the attack proposed in 1. for simplification, assume that alice only chose
capital letters az during the encryption.
3. is the attack still possible if we use the oaep padding exactly explain your
answer.
7.14. the modulus of rsa has been enlarged over the years in order to thwart improved attacks. as one would assume, public-key algorithms become slower as the
modulus length increases. we study the relation between modulus length and performance in this problem. the performance of rsa, and of almost any other public-key
algorithm, is dependent on how fast modulo exponentiation with large numbers can
be performed.
1. assume that one modulo multiplication or squaring with k-bit numbers takes
c  k2 clock cycles, where c is a constant. how much slower is rsa encryption/decryption with 1024 bits compared to rsa with 512 bits on average only
consider the encryption/decryption itself with an exponent of full length and the
square-and-multiply algorithm.
2. in practice, the karatsuba algorithm, which has an asymptotical complexity that
is proportional to klog2 3 , is often used for long number multiplication in cryptography. assume that this more advanced technique requires c  klog2 3  c  k1.585
clock cycles for multiplication or squaring where c is a constant. what is the

problems

203

ratio between rsa encryption with 1024 bit and rsa with 512 bit if the karatsuba algorithm is used in both cases again, assume that full-length exponents
are being used.
7.15. (advanced problem) there are ways to improve the square-and-multiply algorithm, that is, to reduce the number of operations required. although the number
of squarings is fixed, the number of multiplications can be reduced. your task is to
come up with a modified version of the square-and-multiply algorithm which requires fewer multiplications. give a detailed description of how the new algorithm
works and what the complexity is (number of operations).
hint try to develop a generalization of the square-and-multiply algorithm which
processes more than one bit at a time. the basic idea is to handle k (e.g., k  3)
exponent bit per iteration rather than one bit in the original square-and-multiply
algorithm.
7.16. let us now investigate side-channel attacks against rsa. in a simple implementation of rsa without any countermeasures against side-channel leakage, the
analysis of the current consumption of the microcontroller in the decryption part
directly yields the private exponent. figure 7.5 shows the power consumption of an
implementation of the square-and-multiply algorithm. if the microcontroller computes a squaring or a multiplication, the power consumption increases. due to the
small intervals in between the loops, every iteration can be identified. furthermore,
for each round we can identify whether a single squaring (short duration) or a squaring followed by a multiplication (long duration) is being computed.
1. identify the respective rounds in the figure and mark these with s for squaring or
sm for squaring and multiplication.
2. assume the square-and-multiply algorithm has been implemented such that the
exponent is being scanned from left to right. furthermore, assume that the starting values have been initialized. what is the private exponent d
3. this key belongs to the rsa setup with the primes p  67 and q  103 and
e  257. verify your result. (note that in practice an attacker wouldnt know the
values of p and q.)

204

fig. 7.5 power consumption of an rsa decryption

7 the rsa cryptosystem

chapter 8

public-key cryptosystems based on the discrete
logarithm problem

in the previous chapter we learned about the rsa public-key scheme. as we have
seen, rsa is based on the hardness of factoring large integers. the integer factorization problem is said to be the one-way function of rsa. as we saw earlier, roughly
speaking a function is one-way if it is computationally easy to compute the function f (x)  y, but computationally infeasible to invert the function f 1 (y)  x. the
question is whether we can find other one-way functions for building asymmetric
crypto schemes. it turns out that most non-rsa public-key algorithms with practical
relevance are based on another one-way function, the discrete logarithm problem.
in this chapter you will learn





the diffiehellman key exchange
cyclic groups which are important for a deeper understanding of diffiehellman
key exchange
the discrete logarithm problem, which is of fundamental importance for many
practical public-key algorithms
encryption using the elgamal scheme

the security of many cryptographic schemes relies on the computational intractability of finding solutions to the discrete logarithm problem (dlp). wellknown examples of such schemes are the diffiehellman key exchange and the
elgamal encryption scheme, both of which will be introduced in this chapter. also,
the elgamal digital signature scheme (cf. section 8.5.1) and the digital signature
algorithm (cf. section 10.2) are based on the dlp, as are cryptosystems based on
elliptic curves (section 9.3).
we start with the basic diffiehellman protocol, which is surprisingly simple
and powerful. the discrete logarithm problem is defined in what are called cyclic
groups. the concept of this algebraic structure is introduced in section 8.2. a formal
definition of the dlp as well as some illustrating examples are provided, followed
by a brief description of attack algorithms for the dlp. with this knowledge we will
revisit the diffiehellman protocol and more formally talk about its security. we
will then develop a method for encrypting data using the dlp that is known as the
elgamal cryptosystem.
c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 8, 

205

206

8 public-key cryptosystems based on the discrete logarithm problem

8.1 diffiehellman key exchange
the diffiehellman key exchange (dhke), proposed by whitfield diffie and martin hellman in 1976 [58], was the first asymmetric scheme published in the open
literature. the two inventors were also influenced by the work of ralph merkle.
it provides a practical solution to the key distribution problem, i.e., it enables two
parties to derive a common secret key by communicating over an insecure channel1 . the dhke is a very impressive application of the discrete logarithm problem
that well study in the subsequent sections. this fundamental key agreement technique is implemented in many open and commercial cryptographic protocols like
secure shell (ssh), transport layer security (tls), and internet protocol security
(ipsec).the basic idea behind the dhke is that exponentiation in zp , p prime, is a
one-way function and that exponentiation is commutative, i.e.,
k  ( x )y  ( y )x mod p
the value k  ( x )y  ( y )x mod p is the joint secret which can be used as the
session key between the two parties.
let us now consider how the diffiehellman key exchange protocol over zp
works. in this protocol we have two parties, alice and bob, who would like to
establish a shared secret key. there is possibly a trusted third party that properly
chooses the public parameters which are needed for the key exchange. however, it is
also possible that alice or bob generate the public parameters. strictly speaking, the
dhke consists of two protocols, the set-up protocol and the main protocol, which
performs the actual key exchange. the set-up protocol consists of the following
steps
diffiehellman set-up
1. choose a large prime p.
2. choose an integer   {2, 3, . . . , p  2}.
3. publish p and  .
these two values are sometimes referred to as domain parameters. if alice and
bob both know the public parameters p and  computed in the set-up phase, they
can generate a joint secret key k with the following key-exchange protocol

1

the channel needs to be authenticated, but that will be discussed later in this book.

8.1 diffiehellman key exchange

207

diffiehellman key exchange
alice
choose a  k pr,a  {2, . . . , p  2}
compute a  k pub,a   a mod p

bob
choose b  k pr,b  {2, . . . , p  2}
compute b  k pub,b   b mod p
k pub,a a


k pub,b b


k

k

pr,b
kab  k pub,a
 ab mod p

pr,a
 ba mod p
kab  k pub,b

here is the proof that this surprisingly simple protocol is correct, i.e., that alice
and bob in fact compute the same session key kab .
proof. alice computes
while bob computes

ba  ( b )a   ab mod p
ab  ( a )b   ab mod p

and thus alice and bob both share the session key kab   ab mod p. the key can
now be used to establish a secure communication between alice and bob, e.g., by

using kab as key for a symmetric algorithm like aes or 3des. 
well look now at a simple example with small numbers.
example 8.1. the diffiehellman domain parameters are p  29 and   2. the
protocol proceeds as follows
alice
choose a  k pr,a  5
a  k pub,a  25  3 mod 29

bob
choose b  k pr,b  12
b  k pub,b  212  7 mod 29
a3


b7


kab 

ba

 75

 16 mod 29

kab  ab  312  16 mod 29

as one can see, both parties compute the value kab  16, which can be used as a
joint secret, e.g., as a session key for symmetric encryption.

the computational aspects of the dhke are quite similar to those of rsa. during the set-up phase, we generate p using the probabilistic prime-finding algorithms
discussed in section 7.6. as shown in table 6.1, p should have a similar length as
the rsa modulus n, i.e., 1024 or beyond, in order to provide strong security. the
integer  needs to have a special property it should be a primitive element, a topic
which we discuss in the following sections. the session key kab that is being computed in the protocol has the same bit length as p. if we want to use it as a symmetric
key for algorithms such as aes, we can simply take the 128 most significant bits.
alternatively, a hash function is sometimes applied to kab and the output is then
used as a symmetric key.

208

8 public-key cryptosystems based on the discrete logarithm problem

during the actual protocol, we first have to choose the private keys a and b.
they should stem from a true random generator in order to prevent an attacker from
guessing them. for computing the public keys a and b as well as for computing the
session key, both parties can make use of the square-and-multiply algorithm. the
public keys are typically precomputed. the main computation that needs to be done
for a key exchange is thus the exponentiation for the session key. in general, since
the bit lengths and the computations of rsa and the dhke are very similar, they
require a similar effort. however, the trick of using short public exponents that was
shown in section 7.5 is not applicable to the dhke.
what we showed so far is the classic diffiehellman key exchange protocol in
the group zp , where p is a prime. the protocol can be generalized, in particular to
groups of elliptic curves. this gives rise to elliptic curve cryptography, which has
become a very popular asymmetric scheme in practice. in order to better understand
elliptic curves and schemes such as elgamal encryption, which are also closely related to the dhke, we introduce the discrete logarithm problem in the following
sections. this problem is the mathematical basis for the dhke. after we have introduced the discrete logarithm problem, we will revisit the dhke and discuss its
security.

8.2 some algebra
this section introduces some fundamentals of abstract algebra, in particular the notion of groups, subgroups, finite groups and cyclic groups, which are essential for
understanding discrete logarithm public-key algorithms.

8.2.1 groups
for convenience, we restate here the definition of groups which was introduced in
the chapter 4

8.2 some algebra

209

definition 8.2.1 group
a group is a set of elements g together with an operation  which
combines two elements of g. a group has the following properties.
1. the group operation  is closed. that is, for all a, b,  g, it holds
that a  b  c  g.
2. the group operation is associative. that is, a(bc)  (ab)c
for all a, b, c  g.
3. there is an element 1  g, called the neutral element (or identity
element), such that a  1  1  a  a for all a  g.
4. for each a  g there exists an element a1  g, called the inverse of a, such that a  a1  a1  a  1.
5. a group g is abelian (or commutative) if, furthermore, a  b 
b  a for all a, b  g.
note that in cryptography we use both multiplicative groups, i.e., the operation
 denotes multiplication, and additive groups where  denotes addition. the
latter notation is used for elliptic curves as well see later.
example 8.2. to illustrate the definition of groups we consider the following examples.






(z, +) is a group, i.e., the set of integers z  {. . . , 2, 1, 0, 1, 2, . . . } together
with the usual addition forms an abelian group, where e  0 is the identity element and a is the inverse of an element a  z.
(z without 0, ) is not a group, i.e., the set of integers z (without the element
0) and the usual multiplication does not form a group since there exists no inverse
a1 for an element a  z with the exception of the elements 1 and 1.
(c, ) is a group, i.e., the set of complex numbers u + iv with u, v  r and i2  1
together with the complex multiplication defined by
(u1 + iv1 )  (u2 + iv2 )  (u1 u2  v1 v2 ) + i(u1 v2 + v1 u2 )
forms an abelian group. the identity element of this group is e  1, and the
inverse a1 of an element a  u + iv  c is given by a1  (u  i)/(u2 + v2 ).


however, all of these groups do not play a significant role in cryptography because we need groups with a finite number of elements. let us now consider the
group zn which is very important for many cryptographic schemes such as dhke,
elgamal encryption, digital signature algorithm and many others.

210

8 public-key cryptosystems based on the discrete logarithm problem

theorem 8.2.1
the set zn which consists of all integers i  0, 1, . . . , n  1 for which
gcd(i, n)  1 forms an abelian group under multiplication modulo
n. the identity element is e  1.
let us verify the validity of the theorem by considering the following example
example 8.3. if we choose n  9, zn consists of the elements {1, 2, 4, 5, 7, 8}.
table 8.1 multiplication table for z9
 mod 9
1
2
4
5
7
8

1
1
2
4
5
7
8

2
2
4
8
1
5
7

4
4
8
7
2
1
5

5
5
1
2
7
8
4

7
7
5
1
8
4
2

8
8
7
5
4
2
1

by computing the multiplication table for z9 , depicted in table 8.1, we can easily check most conditions from definition 8.2.1. condition 1 (closure) is satisfied
since the table only consists of integers which are elements of z9 . for this group
conditions 3 (identity) and 4 (inverse) also hold since each row and each column
of the table is a permutation of the elements of z9 . from the symmetry along the
main diagonal, i.e., the element at row i and column j equals the element at row j
and column i, we can see that condition 5 (commutativity) is satisfied. condition
2 (associativity) cannot be directly derived from the shape of the table but follows
immediately from the associativity of the usual multiplication in zn .

finally, the reader should remember from section 6.3.1 that the inverse a1 of
each element a  zn can be computed by using the extended euclidean algorithm.

8.2.2 cyclic groups
in cryptography we are almost always concerned with finite structures. for instance,
for aes we needed a finite field. we provide now the straightforward definition of
a finite group

8.2 some algebra

211

definition 8.2.2 finite group
a group (g, ) is finite if it has a finite number of elements. we
denote the cardinality or order of the group g by g.
example 8.4. examples of finite groups are



(zn , +) the cardinality of zn is zn   n since zn  {0, 1, 2, . . . , n  1}.
(zn , ) remember that zn is defined as the set of positive integers smaller than
n which are relatively prime to n. thus, the cardinality of zn equals eulers phi
function evaluated for n, i.e., zn    (n). for instance, the group z9 has a cardinality of  (9)  32  31  6. this can be verified by the earlier example where
we saw that the group consist of the six elements {1, 2, 4, 5, 7, 8}.


the remainder of this section deals with a special type of groups, namely cyclic
groups, which are the basis for discrete logarithm-based cryptosystems. we start
with the following definition
definition 8.2.3 order of an element
the order ord(a) of an element a of a group (g, ) is the smallest
positive integer k such that
ak  a  a  . . .  a  1,
k

times

where 1 is the identity element of g.
well examine this definition by looking at an example.
example 8.5. we try to determine the order of a  3 in the group z11 . for this, we
keep computing powers of a until we obtain the identity element 1.
a1
a2
a3
a4
a5

3
 aa  33  9
 a2  a  9  3  27  5 mod 11
 a3  a  5  3  15  4 mod 11
 a4  a  4  3  12  1 mod 11

from the last line it follows that ord(3)  5.

it is very interesting to look at what happens if we keep multiplying the result by
a

212

8 public-key cryptosystems based on the discrete logarithm problem

a6
a7
a8
a9
a10
a11

 a5  a
 a5  a2
 a5  a3
 a5  a4
 a5  a5
 a10  a
..
.

 1a
 1  a2
 1  a3
 1  a4
 11
 1a

 3 mod 11
 9 mod 11
 5 mod 11
 4 mod 11
 1 mod 11
 3 mod 11

we see that from this point on, the powers of a run through the sequence {3, 9, 5, 4, 1}
indefinitely. this cyclic behavior gives rise to following definition
definition 8.2.4 cyclic group
a group g which contains an element  with maximum order
ord( )  g is said to be cyclic. elements with maximum order
are called primitive elements or generators.
an element  of a group g with maximum order is called a generator since
every element a of g can be written as a power  i  a of this element for some i,
i.e.,  generates the entire group. let us verify these properties by considering the
following example.
example 8.6. we want to check whether a  2 happens to be a primitive element of
z11  {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}. note that the cardinality of the group is z11   10.
lets look at all the elements that are generated by powers of the element a  2
a
a2
a3
a4
a5

a6
a7
a8
a9
a10

2
4
8
 5 mod 11
 10 mod 11

 9 mod 11
 7 mod 11
 3 mod 11
 6 mod 11
 1 mod 11

from the last result it follows that
ord(a)  10  z11 .
this implies that (i) a  2 is a primitive element and (ii) z11  is cyclic.
we now want to verify whether the powers of a  2 actually generate all elements
of the group z11 . lets look again at all the elements that are generated by powers
of two.
i 1
ai 2

2
4

3
8

4
5

5 6
10 9

7
7

8
3

9
6

10
1

by looking at the bottom row, we see that that the powers 2i in fact generate all
elements of the group z11 . we note that the order in which they are generated looks
quite arbitrary. this seemingly random relationship between the exponent i and the

8.2 some algebra

213

group elements is the basis for cryptosystems such as the diffiehellman key exchange.

from this example we see that the group z11 has the element 2 as a generator. it
is important to stress that the number 2 is not necessarily a generator in other cyclic
groups zn . for instance, in z7 , ord(2)  3, and the element 2 is thus not a generator
in that group.
cyclic groups have interesting properties. the most important ones for cryptographic applications are given in the following theorems.
theorem 8.2.2 for every prime p, (zp , ) is an abelian finite cyclic
group.
this theorem states that the multiplicative group of every prime field is cyclic.
this has far reaching consequences in cryptography, where these groups are the
most popular ones for building discrete logarithm cryptosystems. in order to underline the practical relevance of these somewhat esoteric looking theorem, consider
that almost every web browser has a cryptosystem over zp built in.
theorem 8.2.3
let g be a finite group. then for every a  g it holds that
1. ag  1
2. ord(a) divides g
the first property is a generalization of fermats little theorem for all cyclic
groups. the second property is very useful in practice. it says that in a cyclic group
only element orders which divide the group cardinality exist.
example 8.7. we consider again the group z11 which has a cardinality of z11   10.
the only element orders in this group are 1, 2, 5, and 10, since these are the only
integers that divide 10. we verify this property by looking at the order of all elements
in the group
ord(1)  1
ord(6)  10
ord(2)  10
ord(7)  10
ord(3)  5
ord(8)  10
ord(4)  5
ord(9)  5
ord(5)  5
ord(10)  2
indeed, only orders that divide 10 occur.


214

8 public-key cryptosystems based on the discrete logarithm problem

theorem 8.2.4 let g be a finite cyclic group. then it holds that
1. the number of primitive elements of g is  (g).
2. if g is prime, then all elements a  1  g are primitive.
the first property can be verified by the example above. since  (10)  (5 
1)(2  1)  4, the number of primitive elements is four, which are the elements 2,
6, 7 and 8. the second property follows from the previous theorem. if the group
cardinality is prime, the only possible element orders are 1 and the cardinality itself.
since only the element 1 can have an order of one, all other elements have order p.

8.2.3 subgroups
in this section we consider subsets of (cyclic) groups which are groups themselves.
such sets are referred to as subgroups. in order to check whether a subset h of a
group g is a subgroup, one can verify if all the properties of our group definition in
section 8.2.1 also hold for h. in the case of cyclic groups, there is an easy way to
generate subgroups which follows from this theorem
theorem 8.2.5 cyclic subgroup theorem
let (g, ) be a cyclic group. then every element a  g with
ord(a)  s is the primitive element of a cyclic subgroup with s elements.
this theorem tells us that any element of a cyclic group is the generator of a subgroup which in turn is also cyclic.
example 8.8. let us verify the above theorem by considering a subgroup of g 
z11 . in an earlier example we saw that ord(3)  5, and the powers of 3 generate the
subset h  {1, 3, 4, 5, 9} according to theorem 8.2.5. we verify now whether this
set is actually a group by having a look at its multiplication table
table 8.2 multiplication table for the subgroup h  {1, 3, 4, 5, 9}
 mod 11
1
3
4
5
9

1
1
3
4
5
9

3
3
9
1
4
5

4
4
1
5
9
3

5
5
4
9
3
1

9
9
5
3
1
4

h is closed under multiplication modulo 11 (condition 1) since the table only
consists of integers which are elements of h. the group operation is obviously as-

8.2 some algebra

215

sociative and commutative since it follows regular multiplication rules (conditions
2 and 5, respectively). the neutral element is 1 (condition 3), and for every element
a  h there exists an inverse a1  h which is also an element of h (condition 4).
this can be seen from the fact that every row and every column of the table contains
the identity element. thus, h is a subgroup of z11 (depicted in figure 8.1).





















fig. 8.1 subgroup h of the cyclic group g  z11

more precisely, it is a subgroup of prime order 5. it should also be noted that 3 is
not the only generator of h but also 4, 5 and 9, which follows from theorem 8.2.4.

an important special case are subgroups of prime order. if this group cardinality
is denoted by q, all non-one elements have order q according to theorem 8.2.4.
from the cyclic subgroup theorem we know that each element a  g of a group
g generates some subgroup h. by using theorem 8.2.3, the following theorem
follows.
theorem 8.2.6 lagranges theorem
let h be a subgroup of g. then h divides g.
let us now consider an application of lagranges theorem
example 8.9. the cyclic group z11 has cardinality z11   10  1  2  5. thus, it
follows that the subgroups of z11 have cardinalities 1, 2, 5 and 10 since these are
all possible divisors of 10. all subgroups h of z11 and their generators  are given
below
subgroup
elements
primitive elements
h1
{1}
 1
{1, 10}
  10
h2
{1, 3, 4, 5, 9}
  3, 4, 5, 9
h3

the following final theorem of this section fully characterizes the subgroups of
a finite cyclic group

216

8 public-key cryptosystems based on the discrete logarithm problem

theorem 8.2.7
let g be a finite cyclic group of order n and let  be a generator
of g. then for every integer k that divides n there exists exactly one
cyclic subgroup h of g of order k. this subgroup is generated by
 n/k . h consists exactly of the elements a  g which satisfy the
condition ak  1. there are no other subgroups.
this theorem gives us immediately a construction method for a subgroup from a
given cyclic group. the only thing we need is a primitive element and the group
cardinality n. one can now simple compute  n/k and obtains a generator of the
subgroup with k elements.
example 8.10. we again consider the cyclic group z11 . we saw earlier that   8 is
a primitive element in the group. if we want to have a generator  for the subgroup
of order 2, we compute

   n/k  810/2  85  32768  10 mod 11.
we can now verify that the element 10 in fact generates the subgroup with two
elements  1  10,  2  100  1 mod 11,  3  10 mod 11, etc.
remark of course, there are smarter ways of computing 85 mod 11, e.g., through
5
8  82 82 8  (2)(2)8  32  10 mod 11.


8.3 the discrete logarithm problem
after the somewhat lengthy introduction to cyclic groups one might wonder how
they are related to the rather straightforward dhke protocol. it turns out that the
underlying one-way function of the dhke, the discrete logarithm problem (dlp),
can directly be explained using cyclic groups.

8.3.1 the discrete logarithm problem in prime fields
we start with the dlp over zp , where p is a prime.

8.3 the discrete logarithm problem

217

definition 8.3.1 discrete logarithm problem (dlp) in zp
given is the finite cyclic group zp of order p  1 and a primitive element   zp and another element   zp . the dlp is the problem
of determining the integer 1  x  p  1 such that

x  

mod p

remember from section 8.2.2 that such an integer x must exist since  is a primitive element and each group element can be expressed as a power of any primitive
element. this integer x is called the discrete logarithm of  to the base  , and we
can formally write
x  log  mod p.
computing discrete logarithms modulo a prime is a very hard problem if the parameters are sufficiently large. since exponentiation  x   mod p is computationally
easy, this forms a one-way function.
example 8.11. we consider a discrete logarithm in the group z47 , in which   5 is
a primitive element. for   41 the discrete logarithm problem is find the positive
integer x such that
5x  41 mod 47
even for such small numbers, determining x is not entirely straightforward. by using
a brute-force attack, i.e., systematically trying all possible values for x, we obtain
the solution x  15.

in practice, it is often desirable to have a dlp in groups with prime cardinality in
order to prevent the pohlighellman attack (cf. section 8.3.3). since groups zp have
cardinality p  1, which is obviously not prime, one often uses dlps in subgroups
of zp with prime order, rather than using the group zp itself. we illustrate this with
an example.
example 8.12. we consider the group z47 which has order 46. the subgroups in
z47 have thus a cardinality of 23, 2 and 1.   2 is an element in the subgroup
with 23 elements, and since 23 is a prime,  is a primitive element in the subgroup.
a possible discrete logarithm problem is given for   36 (which is also in the
subgroup) find the positive integer x, 1  x  23, such that
2x  36 mod 47
by using a brute-force attack, we obtain a solution for x  17.


218

8 public-key cryptosystems based on the discrete logarithm problem

8.3.2 the generalized discrete logarithm problem
the feature that makes the dlp particularly useful in cryptography is that it is not
restricted to the multiplicative group zp , p prime, but can be defined over any cyclic
groups. this is called the generalized discrete logarithm problem (gdlp) and can
be stated as follows.
definition 8.3.2 generalized discrete logarithm problem
given is a finite cyclic group g with the group operation  and
cardinality n. we consider a primitive element   g and another
element   g. the discrete logarithm problem is finding the integer x, where 1  x  n, such that

      . . .    x
x times

as in the case of the dlp in zp , such an integer x must exist since  is a primitive element, and thus each element of the group g can be generated by repeated
application of the group operation on  .
it is important to realize that there are cyclic groups in which the dlp is not
difficult. such groups cannot be used for a public-key cryptosystem since the dlp
is not a one-way function. consider the following example.
example 8.13. this time we consider the additive group of integers modulo a prime.
for instance, if we choose the prime p  11, g  (z11 , +) is a finite cyclic group
with the primitive element   2. here is how  generates the group
i 1
i 2

2
4

3
6

4
8

5
10

6
1

7
3

8
5

9
7

10
9

11
0

we try now to solve the dlp for the element   3, i.e., we have to compute the
integer 1  x  11 such that
x  2  2 + 2 + . . . + 2  3 mod 11
x

times

here is how an attack against this dlp works. even though the group operation
is addition, we can express the relationship between  ,  and the discrete logarithm
x in terms of multiplication
x  2  3 mod 11.
in order to solve for x, we simply have to invert the primitive element  
x  21 3 mod 11

8.3 the discrete logarithm problem

219

using, e.g., the extended euclidean algorithm, we can compute 21  6 mod 11
from which the discrete logarithm follows as
x  21 3  7 mod 11
the discrete logarithm can be verified by looking at the small table provided above.
we can generalize the above trick to any group (zn , +) for arbitrary n and elements  ,   zn . hence, we conclude that the generalized dlp is computationally
easy over zn . the reason why the dlp can be solved here easily is that we have
mathematical operations which are not in the additive group, namely multiplication
and inversion.

after this counterexample we now list discrete logarithm problems that have been
proposed for use in cryptography
1. the multiplicative group of the prime field z p or a subgroup of it. for instance,
the classical dhke uses this group, but also elgamal encryption or the digital
signature algorithm (dsa). these are the oldest and most widely used types of
discrete logarithm systems.
2. the cyclic group formed by an elliptic curve. elliptic curve cryptosystems are
introduced in chapter 9. they have become popular in practice over the last
decade.
3. the multiplicative group of a galois field gf(2m ) or a subgroup of it. these
groups can be used completely analogous to multiplicative groups of prime fields,
and schemes such as the dhke can be realized with them. they are not as popular in practice because the attacks against them are somewhat more powerful
than those against the dlp in z p . hence dlps over gf(2m ) require somewhat
higher bit lengths for providing the same level of security than those over z p .
4. hyperelliptic curves or algebraic varieties, which can be viewed as generalization
as elliptic curves. they are currently rarely used in practice, but in particular
hyperelliptic curves have some advantages such as short operand lengths.
there have been proposals for other dlp-based cryptosystems over the years,
but none of them have really been of interest in practice. often it was found that the
underlying dl problem was not difficult enough.

8.3.3 attacks against the discrete logarithm problem
this section introduce methods for solving discrete logarithm problems. readers
only interested in the constructive use of dl schemes can skip this section.
as we have seen, the security of many asymmetric primitives is based on the
difficulty of computing the dlp in cyclic groups, i.e., to compute x for a given 
and  in g such that

220

8 public-key cryptosystems based on the discrete logarithm problem

      . . .    x
times
holds. we still do not know the exact difficulty of computing the discrete logarithm
x in any given actual group. what we mean by this is that even though some attacks are known, one does not know whether there are any better, more powerful
algorithms for solving the dlp. this situation is similar to the hardness of integer
factorization, which is the one-way function underlying rsa. nobody really knows
what the best possible factorization method is. for the dlp some interesting general results exist regarding its computational hardness. this section gives a brief
overview of algorithms for computing discrete logarithms which can be classified
into generic algorithms and nongeneric algorithms and which will be discussed in
a little more detail.
x

generic algorithms
generic dl algorithms are methods which only use the group operation and no
other algebraic structure of the group under consideration. since they do not exploit
special properties of the group, they work in any cyclic group. generic algorithms
for the discrete logarithm problem can be subdivided into two classes. the first
class encompasses algorithms whose running time depends on the size of the cyclic
group, like the brute-force search, the baby-step giant-step algorithm and pollards
rho method. the second class are algorithms whose running time depends on the
size of the prime factors of the group order, like the pohlighellman algorithm.

brute-force search
a brute-force search is the most nave and computationally costly way for computing the discrete logarithm log  . we simply compute powers of the generator 
successively until the result equals  


1  


2  
..
.
x 
 

8.3 the discrete logarithm problem

221

for a random logarithm x, we do expect to find the correct solution after checking
half of all possible x. this gives us a complexity of o(g) steps2 , where g is the
cardinality of the group.
to avoid brute-force attacks on dl-based cryptosystems in practice, the cardinality g of the underlying group must thus be sufficiently large. for instance, in
the case of the group zp , p prime, which is the basis for the dhke, (p  1)/2 tests
are required on average to compute a discrete logarithm. thus, g  p  1 should
be at least in the order of 280 to make a brute-force search infeasible using todays
computer technology. of course, this consideration only holds if a brute-force attack
is the only feasible attack which is never the case. there exist much more powerful
algorithms to solve discrete logarithms as we will see below.

shanks baby-step giant-step method
shanks algorithm is a time-memory tradeoff method, which reduces the time of
a brute-force search at the cost of extra storage. the idea is based on rewriting the
discrete logarithm x  log  in a two-digit representation
x  xg m + xb

for 0  xg , xb  m.

(8.1)

the value m is chosen to be of the size of the square root of the group order, i.e.,
m   g. we can now write the discrete logarithm as    x   xg m+xb which
leads to
  ( m )xg   xb .
(8.2)
the idea of the algorithm is to find a solution (xg , xb ) for eq. (8.2), from which the
discrete logarithm then follows directly according to eq. (8.1). the core idea for the
algorithm is that eq. (8.2) can be solved by searching for xg and xb separatedly, i.e.,
using a divide-and-conquer approach. in the first phase of the algorithm we compute
and store all values  xb , where 0  xb  m. this is the baby-step phase that requires
m  g steps (group operations) and needs to store m  g group elements.
in the giant-step phase, the algorithm checks for all xg in the range 0  xg  m
whether the following condition is fulfilled

  ( m )xg   xb


for some stored entry  xb that was computed during the baby-step phase. in case of
a match, i.e.,   ( m )xg,0   xb,0 for some pair (xg,0 , xb,0 ), the discrete logarithm is
given by
x  xg,0 m + xb,0 .
the baby-step giant-step method requires o( g) computational steps and an
equal amount of memory. in a group of order 280 , an attacker would only need
2

we use the popular big-oh notation here. a complexity function f (x) has big-oh notation
o(g(x)) if f (x)  c  g(x) for some constant c and for input values x greater than some value x0 .

222

8 public-key cryptosystems based on the discrete logarithm problem


approximately 240  280 computations and memory locations, which is easily
achievable with todays pcs and hard disks. thus, in order to obtain an attack complexity of 280 , a group must have a cardinality of at least g  2160 . in the case of
groups g  zp , the prime p should thus have at least a length of 160 bit. however,
as we see below, there are more powerful attacks against dlps in zp which forces
even larger bit lengths of p.

pollards rho method
pollards rho method has the same expected run time o( g) as the baby-step
giant-step algorithm but only negligible space requirements. the method is a probabilistic algorithm which is based on the birthday paradox (cf. section 11.2.3). we
will only sketch the algorithm here. the basic idea is to pseudorandomly generate
group elements of the form  i   j . for every element we keep track of the values i
and j. we continue until we obtain a collision of two elements, i.e., until we have

 i1   j1   i2   j2 .

(8.3)

if we substitute    x and compare the exponents on both sides of the equation,
the collision leads to the relation i1 + x j1  i2 + x j2 mod g. (note that we are in
a cyclic group with g elements and have to take the exponent modulo g.) from
here the discrete logarithm can easily computed as
x

i 2  i1
mod g
j1  j2

an important detail, which we omit here, is the exact way to find the collision (8.3).
in any case, the pseudorandom generation of the elements is a random walk through
the group. this can be illustrated by the shape of the greek letter rho, hence the
name of this attack.
pollards rho method is of great practical importance because it is currently the
best known algorithm for computing discrete logarithms in elliptic curve groups.
since the method has an attack complexity of o( g) computations, elliptic curve
groups should have a size of at least 2160 . in fact, elliptic curve cryptosystems with
160-bit operands are very popular in practice.
there are still much more powerful attacks known for the dlp in zp , as we will
see below.

pohlighellman algorithm
the pohlighellman method is an algorithm which is based on the chinese remainder theorem (not introduced in this book) it exploits a possible factorization
of the order of a group. it is typically not used by itself but in conjunction with any
of the other dlp attack algorithms in this section. let

8.3 the discrete logarithm problem

223
e

g  pe11  pe22  . . .  pl l
be the prime factorization of the group order g. again, we attempt to compute
a discrete logarithm x  log  in g. this is also a divide-and-conquer algorithm.
the basic idea is that rather than dealing with the large group g, one computes
smaller discrete logarithms xi  x mod pei i in the subgroups of order pei i . the desired
discrete logarithm x can then be computed from all xi , i  1, . . . , l, by using the
chinese remainder theorem. each individual small dlp xi can be computed using
pollards rho method or the baby-step giant-step algorithm.
the run time of the algorithm clearly depends on the prime factors of the group
order. to prevent the attack, the group order must have its largest prime factor in the
range of 2160 . an important practical consequence of the pohlighellman algorithm
is that one needs to know the prime factorization of the group order. especially in
the case of elliptic curve cryptosystems, computing the order of the cyclic group is
not always easy.

nongeneric algorithms the index-calculus method
all algorithms introduced so far are completely independent of the group being
attacked, i.e., they work for discrete logarithms defined over any cyclic group. nongeneric algorithms efficiently exploit special properties, i.e., the inherent structure,
of certain groups. this can lead to much more powerful dl algorithms. the most
important nongeneric algorithm is the index-calculus method.
both the baby-step giant-step algorithm and pollards rho method have a run time
which is exponential in the bit length of the group order, namely of about 2n/2 steps,
where n is the bit length of g. this greatly favors the crypto designer over the
cryptanalyst. for instance, increasing the group order by a mere 20 bit increases the
attack effort by a factor of 1024  210 . this is a major reason why elliptic curves
have better long-term security behavior than rsa or cryptosystems based on the
dlp in zp . the question is whether there are more powerful algorithms for dlps
in certain specific groups. the answer is yes.
the index-calculus method is a very efficient algorithm for computing discrete
logarithms in the cyclic groups zp and gf(2m ) . it has a subexponential running
time. we will not introduce the method here but just provide a very brief description.
the index-calculus method depends on the property that a significant fraction of
elements of g can be efficiently expressed as products of elements of a small subset
of g. for the group zp this means that many elements should be expressable as a
product of small primes. this property is satisfied by the groups zp and gf(2m ) .
however, one has not found a way to do the same for elliptic curve groups. the
index calculus is so powerful that in order to provide a security of 80 bit, i.e., an
attacker has to perform 280 steps, the prime p of a dlp in zp should be at least
1024 bit long. table 8.3 gives an overview on the dlp records achieved since the
early 1990s. the index-calculus method is somewhat more powerful for solving
the dlp in gf(2m ) . hence the bit lengths have to be chosen somewhat longer to

224

8 public-key cryptosystems based on the discrete logarithm problem

achieve the same level of security. for that reason, dlp schems in gf(2m ) are not
as widely used in practice.
table 8.3 summary of records for computing discrete logarithms in zp
decimal digits bit length
58
193
65
216
85
282
100
332
120
399
135
448
160
532

date
1991
1996
1998
1999
2001
2006
2007

8.4 security of the diffiehellman key exchange

225

8.4 security of the diffiehellman key exchange
after the introduction of the discrete logarithm problem, we are now well prepared
to discuss the security of the dhke from section 8.1. first, it should be noted that a
protocol that uses the basic version of the dhke is not secure against active attacks.
this means if an attacker oscar can either modify messages or generate false messages, oscar can defeat the protocol. this is called man-in-the-middle attack and is
described in section 13.3.
lets now consider the possibilities of a passive adversary, i.e., oscar can only
listen but not alter messages. his goal is to compute the session key kab shared
by alice and bob. which information does oscar get from observing the protocol certainly, oscar knows  and p because these are public parameters chosen
during the set-up protocol. in addition, oscar can obtain the values a  k pub,a and
b  k pub,b by eavesdropping on the channel during an execution of the key-exchange
protocol. thus, the question is whether he is capable of computing k   ab from
 , p, a   a mod p and b   b mod p. this problem is called the diffiehellman
problem (dhp). like the discrete logarithm problem it can be generalized to arbitrary finite cyclic groups. here is a more formal statement of the dhp
definition 8.4.1 generalized diffiehellman problem (dhp)
given is a finite cyclic group g of order n, a primitive element
  g and two elements a   a and b   b in g. the diffie
hellman problem is to find the group element  ab .
one general approach to solving the diffiehellman problem is as follows. for illustration purposes we consider the dhp in the multiplicative group zp . suppose
and thats a big supposeoscar knows an efficient method for computing discrete
logarithms in zp . then he could also solve the diffiehellman problem and obtain
the key kab via the following two steps
1. compute alices private key a  k pr,a by solving the discrete logarithm problem
a  log a mod p.
2. compute the session key kab  ba mod p.
but as we know from section 8.3.3, even though this looks easy, computing the
discrete logarithm problem is infeasible if p is sufficiently large.
at this point it is important to note that it is not known whether solving the dlp
is the only way to solve the dhp. in theory, it is possible that there exists another
method for solving the dhp without computing the discrete logarithm. we note that
the situation is analogous to rsa, where it is also not known whether factoring is the
best way of breaking rsa. however, even though it is not proven in a mathematical
sense, it is often assumed that solving the dlp efficiently is the only way for solving
the dhp efficiently.
hence, in order to assure the security of the dhke in practice, we have to ascertain that the corresponding dlp cannot be solved. this is achieved by choosing p

226

8 public-key cryptosystems based on the discrete logarithm problem

large enough so that the index-calculus method cannot compute the dlp. by consulting table 6.1 we see that a security level of 80 bit is achieved by primes of
lengths 1024 bit, and for 128 bit security we need about 3072 bit. an additional
requirement is that in order to prevent the pohlighellman attack, the order p  1 of
the cyclic group must not factor in only small prime factors. each of the subgroups
formed by the factors of p 1 can be attacked using the baby-step giant-step method
or pollardss rho method, but not by the index-calculus method. hence, the smallest
prime factor of p  1 must be at least 160 bit long for an 80-bit security level, and
at least 256 bit long for a security level of 128 bit.

8.5 the elgamal encryption scheme
the elgamal encryption scheme was proposed by taher elgamal in 1985 [73]. it is
also often referred to as elgamal encryption. it can be viewed as an extension of the
dhke protocol. not surprisingly, its security is also based on the intractability of
the discrete logarithm problem and the diffiehellman problem. we consider the
elgamal encryption scheme over the group zp , where p is a prime. however, it can
be applied to other cyclic groups too in which the dl and dh problem is intractable,
for instance, in the multiplicative group of a galois field gf(2m ).

8.5.1 from diffiehellman key exhange to elgamal encryption
in order to understand the elgamal scheme, it is very helpful to see how it follows
almost immediately from the dhke. we consider two parties, alice and bob. if
alice wants to send an encrypted message x to bob, both parties first perform a
diffiehellman key exchange to derive a shared key km . for this we assume that a
large prime p and a primitive element  have been generated. now, the new idea is
that alice uses this key as a multiplicative mask to encrypt x as y  x  km mod p.
this process is depicted below.

8.5 the elgamal encryption scheme

227

principle of elgamal encryption
alice


bob
(a) choose d  k pr,b  {2, . . . , p  2}
(b) compute   k pub,b   d mod p


(c) choose i  k pr,a  {2, . . . , p  2}
(d) compute ke  k pub,a   i mod p
k

e
(e) compute km   mod p
(g) encrypt message x  zp
y  x  km mod p

(f) compute km  ked mod p

i

y


1
(h) decrypt x  y  km
mod p

the protocol consists of two phases, the classical dhke (steps af) which is
followed by the message encryption and decryption (steps g and h, respectively).
bob computes his private key d and public key  . this key pair does not change,
i.e., it can be used for encrypting many messages. alice, however, has to generate
a new publicprivate key pair for the encryption of every message. her private key
is denoted by i and her public key by ke . the latter is an ephemeral (existing only
temporarily) key, hence the index e. the joint key is denoted by km because it is
used for masking the plaintext.
for the actual encryption, alice simply multiplies the plaintext message x by
the masking key km in zp . on the receiving side, bob reverses the encryption by
multipliying with the inverse mask. note that one property of cyclic groups is that,
given any key km  zp , every messages x maps to another ciphertext if the two
values are multiplied. moreover, if the key km is randomly drawn from zp , every
ciphertext y  {1, 2, . . . , p  1} is equally likely.

8.5.2 the elgamal protocol
we provide now a somewhat more formal description of the scheme. we distinguish
three phases. the set-up phase is executed once by the party who issues the public
key and who will receive the message. the encryption phase and the decryption
phase are executed every time a message is being sent. in contrast to the dhke, no
trusted third party is needed to choose a prime and primitive element. bob generates
them and makes them public, by placing them in a database or on his website.

228

8 public-key cryptosystems based on the discrete logarithm problem

elgamal encryption protocol
alice

k pub (p, , )

bob
choose large prime p
choose primitive element   zp
or in a subgroup of zp
choose k pr  d  {2, . . . , p  2}
compute k pub     d mod p


choose i  {2, . . . , p  2}
compute ephemeral key
ke   i mod p
compute masking key
km   i mod p
encrypt message x  zp
y  x  km mod p
(k ,y)

e



compute masking key
km  ked mod p
1
decrypt x  y  km
mod p

the actual elgamal encryption protocol rearranges the sequence of operations
from the nave diffiehellman inspired approach we saw before. the reason for
this is that alice has to send only one message to bob, as opposed to two messages
in the earlier protocol.
the ciphertext consists of two parts, the ephemeral key, ke , and the masked plaintext, y. since in general all parameters have a bit length of log2 p, the ciphertext
(ke , y) is twice as long as the message. thus, the message expansion factor of elgamal encryption is two.
we prove now the correctness of the elgamal protocol.
proof. we have to show that dk pr (ke , y) actually yields the original message x.
dk pr (ke , y)  y  (km )1 mod p
 [x  km ]  (ked )1 mod p
 [x  ( d )i ][( i )d ]1 mod p
 x   didi  x mod p


lets look at an example with small numbers.
example 8.14. in this example, bob generates the elgamal keys and alice encrypts
the message x  26.

8.5 the elgamal encryption scheme

229

alice
message x  26
k pub,b (p, , )

bob
generate p  29 and   2
choose k pr,b  d  12
compute    d  7 mod 29


choose i  5
compute ke   i  3 mod 29
compute km   i  16 mod 29
encrypt y  x  km  10 mod 29
y,k

e



compute km  ked  16 mod 29
decrypt
1
x  y  km
 10  20  26 mod 29


it is important to note that, unlike the schoolbook version of the rsa scheme,
elgamal is a probabilistic encryption scheme, i.e., encrypting two identical messages x1 and x2 , where x1 , x2  zp using the same public key results (with extremely
high likelihood) in two different ciphertexts y1  y2 . this is because i is chosen at
random from {2, 3,    , p  2} for each encryption, and thus also the session key
km   i used for encryption is chosen at random for each encryption. in this way a
brute-force search for x is avoided a priori.

8.5.3 computational aspects
key generation during the key generation by the receiver (bob in our example), a
prime p must be generated, and the public and private have to be computed. since
the security of elgamal also depends on the discrete logarithm problem, p needs
to have the properties discussed in section 8.3.3. in particular, it should have a
length of at least 1024 bits. to generate such a prime, the prime-finding algorithms
discussed in section 7.6 can be used. the private key should be generated by a true
random number generater. the public key requires one exponentiation for which the
square-and-multiply algorithm is used.
encryption within the encryption procedure, two modular exponentiations and one
modular multiplication are required for computing the ephemeral and the masking
key, as well as for the message encryption. all operands involved have a bit length
of log2 p. for efficient exponentiation, one should apply the square-and-multiply
algorithm that was introduced in section 7.4. it is important to note that the two exponentiations, which constitute almost all computations necessary, are independent
of the plaintext. hence, in some applications they can be precomputed at times of
low computational load, stored and used when the actual encryption is needed. this
can be a major advantage in practice.
decryption the main steps of the decryption are first an exponentiation km 
kd mod p, using the square-and-multiply algorithm, followed by an inversion of km

230

8 public-key cryptosystems based on the discrete logarithm problem

that is performed with the extended euclidean algorithm. however, there is a shortcut based on fermats little theorem that combines these two steps in a single one.
from the theorem, which was introduced in section 6.3.4, follows that
kep1  1 mod p
for all ke  zp . we can now merge step 1 and 2 of the decryption as follows
1
km
 (ked )1 mod p

 (ked )1 kep1 mod p
 kepd1 mod p

(8.4)

the equivalence relation (8.4) allows us to compute the inverse of the masking key
using a single exponentiation with the exponent (p  d  1). after that, one mod1
ular multiplication is required to recover x  y  km
mod p. as a consequence, decryption essentially requires one execution of the square-and-multiply algorithm
followed by a single modular multiplication for recovering the plaintext.

8.5.4 security
if we want to assess the security of the elgamal encryption scheme it is important to
distinguish between passive, i.e., listen-only, and active attacks, which allow oscar
to generate and alter messages.

passive attacks
the security of the elgamal encryption scheme against passive attacks, i.e., recovering x from the information p,  ,    d , ke   i and y  x   i obtained by eavesdropping, relies on the hardness of the diffiehellman problem (cf. section 8.4).
currently there is no other method known for solving the dhp than computing
discrete logarithms. if we assume oscar has supernatural powers and can in fact
compute dlps, he would have two ways of attacking the elgamal scheme.


recover x by finding bobs secret key d
d  log  mod p.
this step solves the dlp, which is computationally infeasible if the parameters are chosen correctly. however, if oscar succeeds with it, he can decrypt the
plaintext by performing the same steps as the receiver, bob
x  y  (ked )1 mod p.

8.5 the elgamal encryption scheme


231

alternatively, instead of computing bobs secret exponent d, oscar could attempt
to recover alices random exponent i
i  log k mod p.
again, this step is solving the discrete logarithm problem. should oscar succeed
with it, he can compute the plaintext as
x  y  ( i )1 mod p.

in both cases oscar has to solve the dl problem in the finite cyclic group zp . in
contrast to elliptic curves, the more powerful index-calculus method (section 8.3.3)
can be applied here. thus, in order to guarantee the security of the elgamal scheme
over zp today, p should at least have a length of 1024 bits.
just as in the dhke protocol, we have to be careful that we do not fall vicitim to
what is a called a small subgroup attack. in order to counter this attack, in practice
primitive elements  are used which generate a subgroup of prime order. in such
groups, all elements are primitive and small subgroups do not exist. one of the
problems illustrates the pitfalls of a small subgroup attack with an example.

active attacks
like in every other asymmetric scheme, it must be assured that the public keys are
authentic. this means that the encrypting party, alice in our example, in fact has
the public key that belongs to bob. if oscar manages to convince alice that his key
is bobs, he can easily attack the scheme. in order to prevent the attack, certificates
can be used, a topic that is discussed in chapter 13.
another weakness, if not necessarily an attack that requires any direct action by
oscar, of the elgamal encryption is that the secret exponent i should not be reused.
assume alice used the value i for encrypting two subsequent messages, x1 and x2 .
in this case, the two masking keys would be the same, namely km   i . also, the
two ephemeral keys would be identical. she would send the two ciphertexts (y1 , ke )
and (y1 , ke ) over the channel. if oscar knows or can guess the first message, he can
compute the masking key as km  y1 x11 mod p. with this, he can decrypt x2 
1
mod p
x2  y2 km

any other message encrypted with the same i value can also be recovered this way.
as a consequence of this attack, one has to take care that the secret exponent i
does not repeat. for instance, if one would use a cryptographically secure prng,
as introduced in section 2.2.1, but with the same seed value every time a session
is initiated, the same sequence of i values would be used for every encryption, a
fact that could be exploited by oscar. note that oscar can detect the re-use of secret
exponents because they lead to identical ephemeral keys.

232

8 public-key cryptosystems based on the discrete logarithm problem

another active attack against elgamal exploits its malleability. if oscar observes
the ciphertext (ke , y), he can replace it by
(ke , s y),
where s is some integer. the receiver would compute
1
dk pr (ke , s y)  s y  km
mod p
1
mod p
 s (x  km )  km

 s x mod p
thus, the decrypted text is also a multiple of s. the situation is exactly the same
as for the attack that exploited the malleability of rsa, which was introduced in
section 7.7. oscar is not able to decrypt the ciphertext, but he can manipulated it
in a specific way. for instance, he could double or triple the integer value of the
decryption result by choosing s equal to 2 or 3, respectively. as it was the case
for rsa, schoolbook elgamal encryption is often not used in practice, but some
padding is introduced to prevent these types of attacks.

8.6 discussion and further reading
diffiehellman key exchange and elgamal encryption the dhke was introduced in the landmark paper [58], which also described the concept of public-key
cryptography. due to the independent discovery of asymmetric cryptography by
ralph merkle, hellman suggested in 2003 that the algorithm should be named
diffiehellmanmerkle key exchange. in chapter 13 of this book, a more detailed treatment of key exchanges based on the dhke is provided. the scheme is
standardized in ansi x9.42 [5] and is used in numerous security protocols such
as tls. one of the attractive features of dhke is that it can be generalized to any
cyclic group, not only to the multiplicative group of a prime field that was shown in
this chapter. in practice, the most popular group in addition to zp is the dhke over
an elliptic curve that is presented in section 9.3.
the dhke is a two-party protocol. it can be extended to a group key agreement
in which more than two parties establish a joint diffiehellman key, see, e.g., [38].
the elgamal encryption as proposed in 1985 by tahar elgamal [73] is widely
used. for example, elgamal is part of the free gnu privacy guard (gnupg),
openssl, pretty good privacy (pgp) and other crypto software. active attacks
against the elgamal encryption scheme such as those discussed in section 8.5.4
have quite strong requirements that have to be fulfilled, which is quite difficult in
reality. there exist schemes which are related to elgamal but have stronger security
properties. these include, e.g., the cramershoup system [49] and the dhaes [1]
scheme proposed by abdalla, bellare and rogaway these are secure against chosen
ciphertext attacks under certain assumptions.

8.7 lessons learned

233

discrete logarithm problem this chapter sketched the most important attack algorithms for solving discrete logarithm problems. a good overview on these, including further references, are given in [168, p. 164 ff.]. we also discussed the relationship between the diffiehellman problem (dhp) and the discrete logarithm
problem (dlp). this relationship is a matter of great importance for the foundations
of cryptography. key contributions which study this are [31, 118].
the idea of using the dlp in groups other than zp is exploited in elliptic curve
cryptography, a topic that is treated in chapter 9. other cryptoystems based on the
generalized dlp include hyperelliptic curves, a comprehensive treatment of which
can be found in [44]. rather than using the prime field zp it is also possible to use
certain extension fields which offer computational advantages. two of the betterstudied dl systems over extension fields are lucas-based cryptosystems [26] and
efficient and compact subgroup trace representation (xtr) [109].

8.7 lessons learned










the diffiehellman protocol is a widely used method for key exchange. it is
based on cyclic groups.
the discrete logarithm problem is one of the most important one-way functions
in modern asymmetric cryptography. many public-key algorithms are based on
it.
in practice, the multiplicative group of the prime field z p or the group of an
elliptic curve are used most often.
for the diffiehellman protocol in zp , the prime p should be at least 1024 bits
long. this provides a security roughly equivalent to an 80-bit symmetric cipher.
for a better long-term security, a prime of length 2048 bits should be chosen.
the elgamal scheme is an extension of the dhke where the derived session key
is used as a multiplicative masked to encrypt a message.
elgamal is a probabilistic encryption scheme, i.e., encrypting two identical messages does not yield two identical ciphertexts.
for the elgamal encryption scheme over zp , the prime p should be at least 1024
bits long, i.e., p  21000 .

234

8 public-key cryptosystems based on the discrete logarithm problem

problems
8.1. understanding the functionality of groups, cyclic groups and subgroups is important for the use of public-key cryptosystems based on the discrete logarithm
problem. thats why we are going to practice some arithmetic in such structures
in this set of problems.
lets start with an easy one. determine the order of all elements of the multiplicative groups of
1. z5
2. z7
3. z13
create a list with two columns for every group, where each row contains an element
a and the order ord(a).
(hint in order to get familiar with cyclic groups and their properties, it is a good
idea to compute all orders by hand, i.e., use only a pocket calculator. if you want to
refresh your mental arithmetic skills, try not to use a calculator whenever possible,
in particular for the first two groups.)
8.2. we consider the group z53 . what are the possible element orders how many
elements exist for each order
8.3. we now study the groups from problem 8.2.
1. how many elements does each of the multiplicative groups have
2. do all orders from above divide the number of elements in the corresponding
multiplicative group
3. which of the elements from problem 8.1 are primitive elements
4. verify for the groups that the number of primitive elements is given by  (zp ).
8.4. in this exercise we want to identify primitive elements (generators) of a multiplicative group since they play a big role in the dhke and and many other publickey schemes based on the dl problem. you are given a prime p  4969 and the
corresponding multiplicative group z4969 .
1. determine how many generators exist in z4969 .
2. what is the probability of a randomly chosen element a  z4969 being a generator
3. determine the smallest generator a  z4969 with a  1000.
hint the identification can be done navely through testing all possible factors
of the group cardinality p  1, or more efficiently by checking the premise that
a(p1)/qi  1 mod p for all prime factors qi with p  1   qei i . you can simply
start with a  1001 and repeat these steps until you find a respective generator of
z4969 .
4. what measures can be taken in order to simplify the search for generators for
arbitrary groups zp 

problems

235

8.5. compute the two public keys and the common key for the dhke scheme with
the parameters p  467,   2, and
1. a  3, b  5
2. a  400, b  134
3. a  228, b  57
in all cases, perform the computation of the common key for alice and bob. this is
also a perfect check of your results.
8.6. we now design another dhke scheme with the same prime p  467 as in
problem 8.5. this time, however, we use the element   4. the element 4 has
order 233 and generates thus a subgroup with 233 elements. compute kab for
1. a  400, b  134
2. a  167, b  134
why are the session keys identical
8.7. in the dhke protocol, the private keys are chosen from the set
{2, . . . , p  2}.
why are the values 1 and p  1 excluded describe the weakness of these two
values.
8.8. given is a dhke algorithm. the modulus p has 1024 bit and  is a generator
of a subgroup where ord( )  2160 .
1. what is the maximum value that the private keys should have
2. how long does the computation of the session key take on average if one modular
multiplication takes 700  s, and one modular squaring 400  s assume that the
public keys have already been computed.
3. one well-known acceleration technique for discrete logarithm systems uses short
primitive elements. we assume now that  is such a short element (e.g., a 16-bit
integer). assume that modular multiplication with  takes now only 30  s. how
long does the computation of the public key take now why is the time for one
modular squaring still the same as above if we apply the square-and-multiply
algorithm
8.9. we now want to consider the importance of the proper choice of generators in
multiplicative groups.
1. show that the order of an element a  z p with a  p  1 is always 2.
2. what subgroup is generated by a
3. briefly describe a simple attack on the dhke which exploits this property.
8.10. we consider a dhke protocol over a galois fields gf(2m ). all arithmetic
is done in gf(25 ) with p(x)  x5 + x2 + 1 as an irreducible field polynomial. the
primitive element for the diffiehellman scheme is   x2 . the private keys are
a  3 and b  12. what is the session key kab 

236

8 public-key cryptosystems based on the discrete logarithm problem

8.11. in this chapter, we saw that the diffiehellman protocol is as secure as the
diffiehellman problem which is probably as hard as the dl problem in the group
zp . however, this only holds for passive attacks, i.e., if oscar is only capable
of eavesdropping. if oscar can manipulate messages between alice and bob, the
key agreement protocol can easily be broken develop an active attack against the
diffiehellman key agreement protocol with oscar being the man in the middle.
8.12. write a program which computes the discrete logarithm in zp by exhaustive
search. the input parameters for your program are p,  ,  . the program computes
x where    x mod p.
compute the solution to log106 12375 in z24691 .
8.13. encrypt the following messages with the elgamal scheme (p  467 and  
2)
1.
2.
3.
4.

k pr  d  105, i  213, x  33
k pr  d  105, i  123, x  33
k pr  d  300, i  45, x  248
k pr  d  300, i  47, x  248

now decrypt every ciphertext and show all steps.
8.14. assume bob sends an elgamal encrypted message to alice. wrongly, bob
uses the same parameter i for all messages. moreover, we know that each of bobs
cleartexts start with the number x1  21 (bobs id). we now obtain the following
ciphertexts
(ke,1  6, y1  17),
(ke,2  6, y2  25).
the elgamal parameters are p  31,   3,   18. determine the second plaintext
x2 .
8.15. given is an elgamal crypto system. bob tries to be especially smart and
chooses the following pseudorandom generator to compute new i values
i j  i j1 + f ( j) , 1  j

(8.5)

where f ( j) is a complicated but known pseudorandom function (for instance, f ( j)
could be a cryptographic hash function such as sha or ripe-md160). i0 is a true
random number that is not known to oscar.
bob encrypts n messages x j as follows
ke j   i j mod p,
y j  x j   i j mod p,

problems

237

where 1  j  n. assume that the last cleartext xn is known to oscar and all ciphertext.
provide a formula with which oscar can compute any of the messages x j , 1 
j  n  1. of course, following kerckhoffs principle, oscar knows the construction
method shown above, including the function f ().
8.16. given an elgamal encryption scheme with public parameters k pub  (p,  ,  )
and an unknown private key k pr  d. due to an erroneous implementation of the
random number generator of the encrypting party, the following relation holds for
two temporary keys
2
km, j+1  km,
j

mod p.

given n consecutive ciphertexts
(ke1 , y1 ), (ke2 , y2 ), ..., (ken , yn )
to the plaintexts
x1 , x2 , ..., xn .
furthermore, the first plaintext x1 is known (e.g., header information).
1. describe how an attacker can compute the plaintexts x1 , x2 , ..., xn from the given
quantities.
2. can an attacker compute the private key d from the given information give
reasons for your answer.
8.17. considering the four examples from problem 8.13, we see that the elgamal
scheme is nondeterministic a given plaintext x has many valid ciphertexts, e.g.,
both x  33 and x  248 have the same ciphertext in the problem above.
1. why is the elgamal signature scheme nondeterministic
2. how many valid ciphertexts exist for each message x (general expression)
how many are there for the system in problem 8.13 (numerical answer)
3. is the rsa crypto system nondeterministic once the public key has been chosen
8.18. we investigate the weaknesses that arise in elgamal encryption if a public key
of small order is used. we look at the following example. assume bob uses the
group z29 with the primitive element   2. his public key is   28.
1. what is the order of the public key
2. which masking keys km are possible
3. alice encrypts a text message. every character is encoded according to the simple
rule a  0,. . ., z  25. there are three additional ciphertext symbols a  26,
o  27, u  28. she transmits the following 11 ciphertexts (ke , y)

238

8 public-key cryptosystems based on the discrete logarithm problem

(3, 15), (19, 14), (6, 15), (1, 24), (22, 13), (4, 7),
(13, 24), (3, 21), (18, 12), (26, 5), (7, 12)
decrypt the message without computing bobs private key. just look at the ciphertext and use the fact that there are only very few masking keys and a bit of
guesswork.

chapter 9

elliptic curve cryptosystems

elliptic curve cryptography (ecc) is the newest member of the three families of
established public-key algorithms of practical relevance introduced in sect. 6.2.3.
however, ecc has been around since the mid-1980s.
ecc provides the same level of security as rsa or discrete logarithm systems
with considerably shorter operands (approximately 160256 bit vs. 10243072 bit).
ecc is based on the generalized discrete logarithm problem, and thus dl-protocols
such as the diffiehellman key exchange can also be realized using elliptic curves.
in many cases, ecc has performance advantages (fewer computations) and bandwidth advantages (shorter signatures and keys) over rsa and discrete logarithm
(dl) schemes. however, rsa operations which involve short public keys as introduced in sect. 7.5.1 are still much faster than ecc operations.
the mathematics of elliptic curves are considerably more involved than those
of rsa and dl schemes. some topics, e.g., counting points on elliptic curves, go
far beyond the scope of this book. thus, the focus of this chapter is to explain the
basics of ecc in a clear fashion without too much mathematical overhead, so that
the reader gains an understanding of the most important functions of cryptosystems
based on elliptic curves.
in this chapter, you will learn






the basic pros and cons of ecc vs. rsa and dl schemes.
what an elliptic curve is and how to compute with it.
how to build a dl problem with an elliptic curve.
protocols that can be realized with elliptic curves.
current security estimations of cryptosystems based on elliptic curves.

9.1 how to compute with elliptic curves
we start by giving a short introduction to the mathematical concept of elliptic
curves, independent of their cryptographic applications. ecc is based on the generalized discrete logarithm problem. hence, what we try to do first is to find a cyclic
c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 9, 

239

240

9 elliptic curve cryptosystems

group on which we can build our cryptosystem. of course, the mere existence of a
cyclic group is not sufficient. the dl problem in this group must also be computationally hard, which means that it must have good one-way properties.
we start by considering certain polynomials (e.g., functions with sums of exponents of x and y), and we plot them over the real numbers.
example 9.1. lets look at the polynomial equation x2 + y2  r2 over the real numbers r. if we plot all the pairs (x, y) which fulfill this equation in a coordinate sysy

x

fig. 9.1 plot of all points (x, y) which fulfill the equation x2 + y2  r2 over r

tem, we obtain a circle as shown in fig. 9.1.

we now look at other polynomial equations over the real numbers.
example 9.2. a slight generalization of the circle equation is to introduce coefficients to the two terms x2 and y2 , i.e., we look at the set of solutions to the equation
a  x2 + b  y2  c over the real numbers. it turns out that we obtain an ellipse, as
y

x

fig. 9.2 plot of all points (x, y) which fulfill the equation a  x2 + b  y2  c over r

shown in figure 9.2.


9.1.1 definition of elliptic curves
from the two examples above, we conclude that we can form certain types of curves
from polynomial equations. by curves, we mean the set of points (x, y) which are

9.1 how to compute with elliptic curves

241

solutions of the equations. for example, the point (x  r, y  0) fulfills the equation
of a circle and is, thus, in the set. the point (x  r/2, y  r/2) is not a solution to the
polynomial x2 + y2  r2 and is, thus, not a set member. an elliptic curve is a special
type of polynomial equation. for cryptographic use, we need to consider the curve
not over the real numbers but over a finite field. the most popular choice is prime
fields gf(p) (cf. sect. 4.2), where all arithmetic is performed modulo a prime p.
definition 9.1.1 elliptic curve
the elliptic curve over z p , p  3, is the set of all pairs (x, y)  z p
which fulfill
(9.1)
y2  x3 + a  x + b mod p
together with an imaginary point of infinity o, where
a, b  z p
and the condition 4  a3 + 27  b2  0 mod p.
the definition of elliptic curve requires that the curve is nonsingular. geometrically speaking, this means that the plot has no self-intersections or vertices, which
is achieved if the discriminant of the curve 16(4a3 + 27b2 ) is nonzero.
for cryptographic use we are interested in studying the curve over a prime field
as in the definition. however, if we plot such an elliptic curve over z p , we do not get
anything remotely resembling a curve. however, nothing prevents us from taking an
elliptic curve equation and plotting it over the set of real numbers.
example 9.3. in figure 9.3 the elliptic curve y2  x3  3x + 3 is shown over the real
numbers.
y

x

fig. 9.3 y2  x3  3x + 3 over r



242

9 elliptic curve cryptosystems

we notice several things from this elliptic curve plot.1 first, the elliptic curve
is symmetric with respect to the x-axis. this follows directly
 from the fact that for

all values xi which are on the elliptic curve, both yi  xi3 + a  xi + b and yi 

 xi3 + a  xi + b are solutions. second, there is one intersection with the x-axis.
this follows from the fact that it is a cubic equation if we solve for y  0 which has
one real solution (the intersection with the x-axis) and two complex solutions (which
do not show up in the plot). there are also elliptic curves with three intersections
with the x-axis.
we now return to our original goal of finding a curve with a large cyclic group,
which is needed for constructing a discrete logarithm problem. the first task for
finding a group is done, namely identifying a set of elements. in the elliptic curve
case, the group elements are the points that fulfill eq. (9.1). the next question at
hand is how do we define a group operation with those points of course, we have
to make sure that the group laws from definition 4.3.1 in sect. 4.2 hold for the
operation.

9.1.2 group operations on elliptic curves
lets denote the group operation with the addition symbol2 +. addition means
that given two points and their coordinates, say p  (x1 , y1 ) and q  (x2 , y2 ), we
have to compute the coordinates of a third point r such that
p+q  r
(x1 , y1 ) + (x2 , y2 )  (x3 , y3 )
as we will see below, it turns out that this addition operation looks quite arbitrary. luckily, there is a nice geometric interpretation of the addition operation if we
consider a curve defined over the real numbers. for this geometric interpretation,
we have to distinguish two cases the addition of two distinct points (named point
addition) and the addition of one point to itself (named point doubling).
point addition p + q this is the case where we compute r  p + q and p 
q. the construction works as follows draw a line through p and q and obtain a
third point of intersection between the elliptic curve and the line. mirror this third
intersection point along the x-axis. this mirrored point is, by definition, the point r.
figure 9.4 shows the point addition on an elliptic curve over the real numbers.
point doubling p + p this is the case where we compute p + q but p  q. hence,
we can write r  p + p  2p. we need a slightly different construction here. we
1 note that elliptic curves are not ellipses. they play a role in determining the circumference of
ellipses, hence the name.
2 note that the choice of naming the operation addition is completely arbitrary we could have
also called it multiplication.

9.1 how to compute with elliptic curves
y

243

 p+q

p


x


q

fig. 9.4 point addition on an elliptic curve over the real numbers

draw the tangent line through p and obtain a second point of intersection between
this line and the elliptic curve. we mirror the point of the second intersection along
the x-axis. this mirrored point is the result r of the doubling. figure 9.5 shows the
y

p


x

 2p

fig. 9.5 point doubling on an elliptic curve over the real numbers

doubling of a point on an elliptic curve over the real numbers.
you might wonder why the group operations have such an arbitrary looking form.
historically, this tangent-and-chord method was used to construct a third point if
two points were already known, while only using the four standard algebraic operations add, subtract, multiply and divide. it turns out that if points on the elliptic
curve are added in this very way, the set of points also fulfill most conditions necessary for a group, that is, closure, associativity, existence of an identity element and
existence of an inverse.
of course, in a cryptosystem we cannot perform geometric constructions. however, by applying simple coordinate geometry, we can express both of the geomet-

244

9 elliptic curve cryptosystems

ric constructions from above through analytic expressions, i.e., formulae. as stated
above, these formulae only involve the four basic algebraic operations. these operations can be performed in any field, not only over the field of the real numbers
(cf. sect. 4.2). in particular, we can take the curve equation from above, but we now
consider it over prime fields gf(p) rather than over the real numbers. this yields
the following analytical expressions for the group operation.
elliptic curve point addition and point doubling
x3  s2  x1  x2 mod p
y3  s(x1  x3 )  y1 mod p
where
 y2 y1
s

x2 x1
3x12 +a
2y1

mod p  if p  q (point addition)
mod p  if p  q (point doubling)

note that the parameter s is the slope of the line through p and q in the case of
point addition, or the slope of the tangent through p in the case of point doubling.
even though we made major headway towards the establishment of a finite group,
we are not there yet. one thing that is still missing is an identity (or neutral) element
o such that
p+o  p
for all points p on the elliptic curve. it turns out that there isnt any point (x, y) that
fulfills the condition. instead we define an abstract point at infinity as the neutral
element o. this point at infinity can be visualized as a point that is located towards
plus infinity along the y-axis or towards minus infinity along the y-axis.
according the group definition, we can now also define the inverse p of any
group element p as
p + (p)  o.
the question is how do we find p if we apply the tangent-and-chord method
from above, it turns out that the inverse of the point p  (x p , y p ) is the point p 
(x p , y p ), i.e., the point that is reflected along the x-axis. figure 9.6 shows the point
p together with its inverse. note that finding the inverse of a point p  (x p , y p ) is
now trivial. we simply take the negative of its y coordinate. in the case of elliptic
curves over a prime field gf(p) (the most interesting case in cryptography), this is
easily achieved since y p  p  y p mod p, hence
p  (x p , p  y p ).
now that we have defined all group properties for elliptic curves, we now look at
an example for the group operation.
example 9.4. we consider a curve over the small field z17 

9.2 building a discrete logarithm problem with elliptic curves
y

245

p


x

p

fig. 9.6 the inverse of a point p on an elliptic curve

e  y2  x3 + 2x + 2 mod 17.
we want to double the point p  (5, 1).
2p  p + p  (5, 1) + (5, 1)  (x3 , y3 )
s

3x12 + a
 (2  1)1 (3  52 + 2)  21  9  9  9  13 mod 17
2y1

x3  s2  x1  x2  132  5  5  159  6 mod 17
y3  s(x1  x3 )  y1  13(5  6)  1  14  3 mod 17
2p  (5, 1) + (5, 1)  (6, 3)
for illustrative purposes we check whether the result 2p  (6, 3) is actually a point
on the curve by inserting the coordinates into the curve equation
y2  x3 + 2  x + 2 mod 17
32  63 + 2  6 + 2 mod 17
9  230  9 mod 17


9.2 building a discrete logarithm problem with elliptic curves
what we have done so far is to establish the group operations (point addition and
doubling), we have provided an identity element, and we have shown a way of
finding the inverse for any point on the curve. thus, we now have all necessary
requirements in place to motivate the following theorem

246

9 elliptic curve cryptosystems

theorem 9.2.1 the points on an elliptic curve together with o
have cyclic subgroups. under certain conditions all points on an
elliptic curve form a cyclic group.
please note that we have not proved the theorem. this theorem is extremely useful because we have a good understanding of the properties of cyclic groups. in
particular, we know that by definition a primitive element must exist such that its
powers generate the entire group. moreover, we know quite well how to build cryptosystems from cyclic groups. here is an example for the cyclic group of an elliptic
curve.
example 9.5. we want to find all points on the curve
e  y2  x3 + 2  x + 2 mod 17.
it happens that all points on the curve form a cyclic group and that the order is
e  19. for this specific curve the group order is a prime and, according to theorem 8.2.4, every element is primitive.
as in the previous example we start with the primitive element p  (5, 1). we
compute now all powers of p. more precisely, since the group operation is addition, we compute p, 2p, . . . , (e) p. here is a list of the elements that we obtain
2p
3p
4p
5p
6p
7p
8p
9p
10p

 (5, 1) + (5, 1)  (6, 3)
 2p + p  (10, 6)
 (3, 1)
 (9, 16)
 (16, 13)
 (0, 6)
 (13, 7)
 (7, 6)
 (7, 11)

11p
12p
13p
14p
15p
16p
17p
18p
19p

 (13, 10)
 (0, 11)
 (16, 4)
 (9, 1)
 (3, 16)
 (10, 11)
 (6, 14)
 (5, 16)
o

from now on, the cyclic structure becomes visible since
20p  19p + p  o + p  p
21p  2p
..
.
it is also instructive to look at the last computation above, which yielded
18p + p  o.
this means that p  (5, 1) is the inverse of 18p  (5, 16), and vice versa. this is
easy to verify. we have to check whether the two x coordinates are identical and
that the two y coordinates are each others additive inverse modulo 17. the first

9.2 building a discrete logarithm problem with elliptic curves

247

condition obviously hold and the second one too, since
1  16 mod 17.

to set up dl cryptosystems it is important to know the order of the group. even
though knowing the exact number of points on a curve is an elaborate task, we know
the approximate number due to hasses theorem.
theorem 9.2.2 hasses theorem
given an elliptic curve e modulo p, the number of points on the
curve is denoted by e and is bounded by


p + 1  2 p  e  p + 1 + 2 p.
hasses theorem, which is also known as hasses bound, states that the number of
points is roughly in the range of the prime p. this has major practical implications.
for instance, if we need an elliptic curve with 2160 elements, we have to use a prime
of length of about 160 bit.
lets now turn our attention to the details of setting up the discrete logarithm
problem. for this, we can strictly proceed as described in chapter 8.
definition 9.2.1 elliptic curved discrete logarithm problem
(ecdlp)
given is an elliptic curve e. we consider a primitive element p
and another element t . the dl problem is finding the integer d,
where 1  d  e, such that
p + p +    + p  d p  t.

(9.2)

d times

in cryptosystems, d is the private key which is an integer, while the public key
t is a point on the curve with coordinates t  (xt , yt ). in contrast, in the case of
the dl problem in zp , both keys were integers. the operation in eq. (9.2) is called
point multiplication, since we can formally write t  d p. this terminology can be
misleading, however, since we cannot directly multiply the integer d with a curve
point p. instead, d p is merely a convenient notation for the repeated application of
the group operation in equation (9.2).3 lets now look at an example for an ecdlp.
example 9.6. we perform a point multiplication on the curve y2  x3 + 2x + 2 mod
17 that was also used in the previous example. we want to compute
3

note that the symbol + was chosen arbitrarily to denote the group operation. if we had chosen
a multiplicative notation instead, the ecdlp would have had the form pd  t , which would have
been more consistent with the conventional dl problem in zp .

248

9 elliptic curve cryptosystems

13p  p + p + . . . + p
where p  (5, 1). in this case, we can simply use the table that was compiled earlier
13p  (16, 4).

point multiplication is analog to exponentiation in multiplicative groups. in order to do it efficiently, we can directly adopt the square-and-multiply algorithm.
the only difference is that squaring becomes doubling and multiplication becomes
addition of p. here is the algorithm
double-and-add algorithm for point multiplication
input elliptic curve e together with an elliptic curve point p
a scalar d  ti0 di 2i with di  0, 1 and dt  1
output t  d p
initialization
t p
algorithm
1
for i  t  1 downto 0
1.1
t  t + t mod n
if di  1
1.2
t  t + p mod n
2
return (t )
for a random scalar of length of t + 1 bit, the algorithm requires on average
1.5t point doubles and additions. verbally expressed, the algorithm scans the bit
representation of the scalar d from left to right. it performs a doubling in every
iteration, and only if the current bit has the value 1 does it perform an addition of p.
lets look at an example.
example 9.7. we consider the scalar multiplication 26 p, which has the following
binary representation
26 p  (110102 ) p  (d4 d3 d2 d1 d0 )2 p.
the algorithm scans the scalar bits starting on the left with d4 and ending with the
rightmost bit d0 .

9.3 diffiehellman key exchange with elliptic curves

249

step
0 p  12 p

inital setting, bit processed d4  1

1a p + p  2p  102 p
1b 2p + p  3p  102 p + 12 p  112 p

double, bit processed d3
add, since d3  1

2a 3p + 3p  6p  2(112 p)  1102 p
2b

double, bit processed d2
no add, since d2  0

3a 6p + 6p  12p  2(1102 p)  11002 p
3b 12p + p  13p  11002 p + 12 p  11012 p

double, bit processed d1
add, since d1  1

4a 13p + 13p  26p  2(11012 p)  110102 p
4b

double, bit processed d0
no add, since d0  0

it is instructive to observe how the binary representation of the exponent evolves.
we see that doubling results in a left shift of the scalar, with a 0 put in the rightmost
position. by performing addition with p, a 1 is inserted into the rightmost position of the scalar. compare how the highlighted exponents change from iteration to
iteration.

if we go back to elliptic curves over the real numbers, there is a nice geometric
interpretation for the ecdlp given a starting point p, we compute 2p, 3p, . . .,
d p  t , effectively hopping back and forth on the elliptic curve. we then publish
the starting point p (a public parameter) and the final point t (the public key). in
order to break the cryptosystem, an attacker has to figure out how often we jumped
on the elliptic curve. the number of hops is the secret d, the private key.

9.3 diffiehellman key exchange with elliptic curves
in complete analogy to the conventional diffiehellman key exchange (dhke) introduced in sect. 8.1, we can now realize a key exchange using elliptic curves. this
is referred to as elliptic curve diffiehellman key exchange, or ecdh. first we
have to agree on domain parameters, that is, a suitable elliptic curve over which we
can work and a primitive element on this curve.

250

9 elliptic curve cryptosystems

ecdh domain parameters
1. choose a prime p and the elliptic curve
e  y2  x3 + a  x + b mod p
2. choose a primitive element p  (xp , yp )
the prime p, the curve given by its coefficients a, b, and the primitive element p are the domain parameters.
note that in practice finding a suitable elliptic curve is a relatively difficult task.
the curves have to show certain properties in order to be secure. more about this
is said below. the actual key exchange is done the same way it was done for the
conventional diffiehellman protocol.
elliptic curve diffiehellman key exchange (ecdh)
alice
choose k pra  a  {2, 3, . . . , e  1}
compute k puba  a p  a  (xa , ya )

bob
choose k prb  b  {2, 3, . . . , e  1}
compute k pubb  b p  b  (xb , yb )
a


b


compute a b  tab
joint secret between alice and bob tab  (xab , yab ).

compute b a  tab

the correctness of the protocol is easy to prove.
proof. alice computes
a b  a (b p)
while bob computes
b a  b (a p).
since point addition is associative (remember that associativity is one of the group
properties), both parties compute the same result, namely the point tab  a b p. 

as can be seen in the protocol, alice and bob choose the private keys a and
b, respectively, which are two large integers. with the private keys both generate
their respective public keys a and b, which are points on the curve. the public
keys are computed by point multiplication. the two parties exchange these public
parameters with each other. the joint secret tab is then computed by both alice
and bob by performing a second point multiplication involving the public key they
received and their own secret parameter. the joint secret tab can be used to derive
a session key, e.g., as input for the aes algorithm. note that the two coordinates
(xab , yab ) are not independent of each other given xab , the other coordinate can be
computed by simply inserting the x value in the elliptic curve equation. thus, only
one of the two coordinates should be used for the derivation of a session key. lets
look at an example with small numbers

9.4 security

251

example 9.8. we consider the ecdh with the following domain parameters. the
elliptic curve is y2  x3 + 2x + 2 mod 17, which forms a cyclic group of order e 
19. the base point is p  (5, 1). the protocol proceeds as follows
alice
choose a  k pr,a  3
a  k pub,a  3 p  (10, 6)

bob
choose b  k pr,b  10
b  k pub,b  10 p  (7, 11)
a


b


tab  a b  3 (7, 11)  (13, 10)

tab  b a  10 (10, 6)  (13, 10)

the two scalar multiplications that each alice and bob perform require the doubleand-add algorithm.

one of the coordinates of the joint secret tab can now be used as session key. in
practice, often the x-coordinate is hashed and then used as a symmetric key. typically, not all bits are needed. for instance, in a 160-bit ecc scheme, hashing the
x-coordinate with sha-1 results in a 160-bit output of which only 128 would be
used as an aes key.
please note that elliptic curves are not restricted to the dhke. in fact, almost all
other discrete logarithm protocols, in particular digital signatures and encryption,
e.g., variants of elgamal, can also be realized. the widely used elliptic curve digital
signature algorithms (ecdsa) will be introduced in sect. 10.5.1.

9.4 security
the reason we use elliptic curves is that the ecdlp has very good one-way characteristics. if an attacker oscar wants to break the ecdh, he has the following
information e, p, p, a, and b. he wants to compute the joint secret between alice
and bob tab  a  b  p. this is called the elliptic curve diffiehellman problem
(ecdhp). there appears to be only one way to compute the ecdhp, namely to
solve either of the discrete logarithm problems
a  logp a
or
b  logp b
if the elliptic curve is chosen with care, the best known attacks against the
ecdlp are considerably weaker than the best algorithms for solving the dl problem modulo p, and the best factoring algorithms which are used for rsa attacks.
in particular, the index-calculus algorithms, which are powerful attacks against the
dlp modulo p, are not applicable against elliptic curves. for carefully selected elliptic curves, the only remaining attacks are generic dl algorithms, that is shanks
baby-step giant-step method and pollards rho method, which were described in
sect. 8.3.3. since the number of steps required for such an attack is roughly equal

252

9 elliptic curve cryptosystems

to the square root of the group cardinality, a group order of at least 2160 should be
used. according to hasses theorem, this requires that the prime p used for the elliptic curve must be roughly160-bit long. if we attack such a group with generic
algorithms, we need around 2160  280 steps. a security level of 80 bit provides
medium-term security. in practice, elliptic curve bit lengths up to 256 bit are commonly used, which provide security levels of up to 128 bit.
it should be stressed that this security is only achieved if cryptographically strong
elliptic curves are used. there are several families of curves that possess cryptographic weaknesses, e.g., supersingular curves. they are relatively easy to spot,
however. in practice, often standardized curves such as ones proposed by the national institute of standards and technology (nist) are being used.

9.5 implementation in software and hardware
before using ecc, a curve with good cryptographic properties needs to be identified. in practice, a core requirement is that the cyclic group (or subgroup) formed
by the curve points has prime order. moreover, certain mathematical properties that
lead to cryptographic weaknesses must be ruled out. since assuring all these properties is a nontrivial and computationally demanding task, often standardized curves
are used in practice.
when implementing elliptic curves it is useful to view an ecc scheme as a structure with four layers. on the bottom layer modular arithmetic, i.e., arithmetic in the
prime field gf(p), is performed. we need all four field operations addition, subtraction, multiplication and inversion. on the next layer, the two group operations,
point doubling and point addition, are realized. they make use of the arithmetic provided in the bottom layer. on the third layer, scalar multiplication is realized, which
uses the group operations of the previous layer. the top layer implements the actual
protocol, e.g., ecdh or ecdsa. it is important to note that two entirely different
finite algebraic structures are involved in an elliptic curve cryptosystem. there is
a finite field gf(p) over which the curve is defined, and there is the cyclic group
which is formed by the points on the curve.
in software, a highly optimized 256-bit ecc implementation on a 3-ghz, 64-bit
cpu can take approximately 2 ms for one point multiplication. slower throughputs due to smaller microprocessors or less optimized algorithms are common with
performances in the range of 10 ms. for high-performance applications, e.g., for
internet servers that have to perform a large number of elliptic curve signatures per
second, hardware implementations are desirable. the fastest implementations can
compute a point multiplication in the range of 40  s, while speeds of several 100
 s are more common.
on the other side of the performance spectrum, ecc is the most attractive publickey algorithm for lightweight applications such as rfid tags. highly compact ecc
engines are possible which need as little as 10,000 gate equivalences and run at a
speed of several tens of milliseconds. even though ecc engines are much larger

9.6 discussion and further reading

253

than implementations of symmetric ciphers such as 3des, they are considerably
smaller than rsa implementations.
the computational complexity of ecc is cubic in the bit length of the prime
used. this is due to the fact that modular multiplication, which is the main operation
on the bottom layer, is quadratic in the bit length, and scalar multiplication (i.e.,
with the double-and-add algorithm) contributes another linear dimension, so that
we have, in total, a cubic complexity. this implies that doubling the bit length of
an ecc implementation results in performance degradation by a factor of roughly
23  8. rsa and dl systems show the same cubic runtime behavior. the advantage
of ecc over the other two popular public-key families is that the parameters have to
be increased much more slowly to enhance the security level. for instance, doubling
the effort of an attacker for a given ecc system requires an increase in the length
of the parameter by 2 bits, whereas rsa or dl schemes require an increase of 20
30 bits. this behavior is due to the fact that only generic attacks (cf. sect. 8.3.3)
are known ecc cryptosystems, whereas more powerful algorithms are available for
attacking rsa and dl schemes.

9.6 discussion and further reading
history and general remarks ecc was independently invented in 1987 by neal
koblitz and in 1986 by victor miller. during the 1990s there was much speculation
about the security and practicality of ecc, especially if compared to rsa. after a
period of intensive research, they appear nowadays very secure, just like rsa and
dl schemes. an important step for building confidence in ecc was the issuing of
two ansi banking standards for elliptic curve digital signature and key establishment in 1999 and 2001, respectively [6, 7]. interestingly, in suite ba collection
of crypto algorithms selected by the nsa for use in us government systemsonly
ecc schemes are allowed as asymmetric algorithms [130]. elliptic curves are also
widely used in commercial standards such as ipsec or transport layer security
(tls).
at the time of writing, there still exist far more fielded rsa and dl applications
than elliptic curve ones. this is mainly due to historical reasons and due to the quite
complex patent situation of some ecc variants. nevertheless, in many new applications with security needs, especially in embedded systems such as mobile devices,
ecc is often the preferred public-key scheme. for instance, ecc is used in the most
popular business handheld devices. most likely, ecc will become more widespread
in the years to come. reference [100] describes the historical development of ecc
with respect to scientific and commercial aspects, and makes excellent reading.
for readers interested in a deeper understanding of ecc, the books [25, 24, 90,
44] are recommended. the overview article [103], even though a bit dated now,
provides a good state-of-the-art summary as of the year 2000. for more recent developments, the annual workshop on elliptic curve cryptography (ecc) is recommended as an excellent resource [166]. the workshop includes both theoretical and

254

9 elliptic curve cryptosystems

applied topics related to ecc and related crypto schemes. there is also a rich literature that deals with the mathematics of elliptic curves [154, 101, 155], regardless
of their use in cryptography.
implementation and variants in the first few years after the invention of ecc,
these algorithms were believed to be computationally more complex than existing
public-key schemes, especially rsa. this assumption is somewhat ironic in hindsight, given that ecc tends to be often faster than most other public-key schemes.
during the 1990s, fast implementation techniques for ecc was intensively researched, which resulted in considerable performance improvements.
in this chapter, elliptic curves over prime fields gf(p) were introduced. these
are currently in practice somewhat more widely used than over other finite fields, but
curves over binary galois fields gf(2m ) are also popular. for efficient implementations, improvements are possible at the finite field arithmetic layer, at the group
operation layer and at the point multiplication layer. there is a wealth of techniques
and in the following is a summary of the most common acceleration techniques in
practice. for curves over gf(p), generalized mersenne primes are often used at the
arithmetic level. these are primes such as p  2192  264  1. their major advantage
is that modulo reduction is extremely simple. if general primes are used, methods
similar to those described in sect. 7.10 are applicable. with respect to ecc over
fields gf(2m ), efficient arithmetic algorithms are described in [90]. on the group
operation layer, several optimizations are possible. a popular one is to switch from
the affine coordinates that were introduced here to projective coordinates, in which
each point is represented as a triple (x, y, z). their advantage is that no inversion
is required within the group operation. the number of multiplications increases,
however. on the next layer, fast scalar multiplication techniques are applicable. improved versions of the double-and-add algorithm which make use of the fact that
adding or subtracting a point come at almost identical costs are commonly being
applied. an excellent compilation of efficient computation techniques for ecc is
the book [90].
a special type of elliptic curve that allows for particularly fast point multiplication is the koblitz curve [158]. these are curves over gf(2m ) where the coefficients
have the values 0 or 1. there have also been numerous other suggestions for elliptic curves with good implementation properties. one such proposal involves elliptic
curves over optimum extension fields, i.e., fields of the form gf(pm ), p  2 [10].
as mentioned in sect. 9.5, standardized curves are often being used in practice.
a widely used set of curves is provided in the fips standard [126, appendix d].
alternatives are curves specified by the ecc brainpool consortium or the standards
for efficient cryptography group (secg) [34, 9] .
elliptic curves also allow for many variants and generalization. they are a special
case of hyperelliptic curves, which can also be used to build discrete logarithm cryptosystems [44]. a summary of implementation techniques for hyperelliptic curves is
given in [175]. a completely different type of public-key scheme which also makes
use of elliptic curves is identity-based cryptosystems [30], which have drawn much
attention over the last few years.

9.7 lessons learned

255

9.7 lessons learned








elliptic curve cryptography (ecc) is based on the discrete logarithm problem.
it requires arithmetic modulo a prime or in a galois field gf(2m ).
ecc can be used for key exchange, for digital signatures and for encryption.
ecc provides the same level of security as rsa or discrete logarithm systems over zp with considerably shorter operands (approximately 160256 bit
vs. 10243072 bit), which results in shorter ciphertexts and signatures.
in many cases ecc has performance advantages over other public-key algorithms. however, signature verification with short rsa keys is still considerably
faster than ecc.
ecc is slowly gaining popularity in applications, compared to other public-key
schemes, i.e., many new applications, especially on embedded platforms, make
use of elliptic curve cryptography.

256

9 elliptic curve cryptosystems

problems
9.1. show that the condition 4a3 + 27b2  0 mod p is fulfilled for the curve
y2  x3 + 2x + 2 mod 17

(9.3)

9.2. perform the additions
1. (2, 7) + (5, 2)
2. (3, 6) + (3, 6)
in the group of the curve y2  x3 + 2x + 2 mod 17. use only a pocket calculator.
9.3. in this chapter the elliptic curve y2  x3 + 2x + 2 mod 17 is given with e  19.
verify hasses theorem for this curve.
9.4. let us again consider the elliptic curve y2  x3 + 2x + 2 mod 17. why are all
points primitive elements
note in general it is not true that all elements of an elliptic curve are primitive.
9.5. let e be an elliptic curve defined over z7 
e  y2  x3 + 3x + 2.
1. compute all points on e over z7 .
2. what is the order of the group (hint do not miss the neutral element o.)
3. given the element   (0, 3), determine the order of  . is  a primitive element
9.6. in practice, a and k are both in the range p  2150    2250 , and computing t  a
p and y0  k  p is done using the double-and-add algorithm as shown in sect. 9.2.
1. illustrate how the algorithm works for a  19 and for a  160. do not perform
elliptic curve operations, but keep p a variable.
2. how many (i) point additions and (ii) point doublings are required on average for
one multiplication assume that all integers have n  log2 p bit.
3. assume that all integers have n  160 bit, i.e., p is a 160-bit prime. assume one
group operation (addition or doubling) requires 20  sec. what is the time for one
double-and-add operation
9.7. given an elliptic curve e over z29 and the base point p  (8, 10)
e  y2  x3 + 4x + 20 mod 29.
calculate the following point multiplication k  p using the double-and-add algorithm. provide the intermediate results after each step.
1. k  9
2. k  20

problems

257

9.8. given is the same curve as in 9.7. the order of this curve is known to be e 
37. furthermore, an additional point q  15  p  (14, 23) on this curve is given.
determine the result of the following point multiplications by using as few group
operations as possible, i.e., make smart use of the known point q. specify how you
simplified the calculation each time.
hint in addition to using q, use the fact that it is easy to compute p.
1.
2.
3.
4.
5.

16  p
38  p
53  p
14  p + 4  q
23  p + 11  q

you should be able to perform the scalar multiplications with considerably fewer
steps than a straightforward application of the double-and-add algorithm would allow.
9.9. your task is to compute a session key in a dhke protocol based on elliptic
curves. your private key is a  6. you receive bobs public key b  (5, 9). the
elliptic curve being used is defined by
y2  x3 + x + 6 mod 11.
9.10. an example for an elliptic curve dhke is given in sect. 9.3. verify the two
scalar multiplications that alice performs. show the intermediate results within the
group operation.
9.11. after the dhke, alice and bob possess a mutual secret point r  (x, y). the
modulus of the used elliptic curve is a 64-bit prime. now, we want to derive a session
key for a 128-bit block cipher. the session key is calculated as follows
kab  h(xy)
describe an efficient brute-force attack against the symmetric cipher. how many
of the key bits are truly random in this case (hint you do not need to describe
the mathematical details. provide a list of the necessary steps. assume you have a
function that computes square roots modulo p.)
9.12. derive the formula for addition on elliptic curves. that is, given the coordinates for p and q, find the coordinates for r  (x3 , y3 ).
hint first, find the equation of a line through the two points. insert this equation
in the elliptic curve equation. at some point you have to find the roots of a cubic
polynomial x3 + a2 x2 + a1 x + a0 . if the three roots are denoted by x0 , x1 , x2 , you can
use the fact that x0 + x1 + x2  a2 .

chapter 10

digital signatures

digital signatures are one of the most important cryptographic tools they and are
widely used today. applications for digital signatures range from digital certificates
for secure e-commerce to legal signing of contracts to secure software updates. together with key establishment over insecure channels, they form the most important
instance for public-key cryptography.
digital signatures share some functionality with handwritten signatures. in particular, they provide a method to assure that a message is authentic to one user, i.e., it
in fact originates from the person who claims to have generated the message. however, they actually provide much more functionality, as well learn in this chapter.
in this chapter you will learn





the principle of digital signatures
security services, that is, the specific objectives that can be achieved by a security
system
the rsa digital signature scheme
the elgamal digital signature scheme and two extensions of it, the digital signature algorithm (dsa) and the elliptic curve digital signature algorithm (ecdsa)

c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 10, 

259

260

10 digital signatures

10.1 introduction
in this section, we first provide a motivating example why digital signatures are
needed and why they must be based on asymmetric cryptography. we then develop
the principles of digital signatures. actual signature algorithms are introduced in
subsequent sections.

10.1.1 odd colors for cars, or why symmetric cryptography is
not sufficient
the crypto schemes that we have encountered so far had two main goals either to
encrypt data (e.g., with aes, 3des or rsa encryption) or to establish a shared
key (e.g., with the diffiehellman or elliptic curve key exchange). one might be
tempted to think that we are now in a position to satisfy any security needs that
arise in practice. however, there are many other security needs besides encryption
and key exchange, which are in fact termed security services these are discussed in
detail in sect. 10.1.3. we now discuss a setting in which symmetric cryptography
fails to provide a desirable security function.
assume we have two communicating parties, alice and bob, who share a secret
key. furthermore, the secret key is used for encryption with a block cipher. when
alice receives and decrypts a message which makes semantic sense, e.g., the decrypted message is an actual (english) text, she can in many cases conclude that the
message was in fact generated by a person with whom he shares the secret key1 . if
only alice and bob know the key, they can be reasonably sure that an attacking third
party has not changed the message in transit. so far weve always assumed that the
bad guy is an external party that we often named oscar. however, in practice it is
often the case that alice and bob do want to communicate securely with each other,
but at the same time they might be interested in cheating each other. it turns out that
symmetric-key schemes do not protect the two parties against each other. consider
the following scenario
suppose that alice owns a dealership for new cars where you can select and
order cars online. we assume that bob, the customer, and alice, the dealer, have
established a shared secret kab , e.g., by using the diffiehellman key exchange.
bob now specifies the car that he likes, which includes a color choice of pink for the
interior and an external color of orange  choices most people would not make. he
sends the order form aes-encrypted to alice. she decrypts the order and is happy
to have sold another model for 25,000. upon delivery of the car three weeks later,
bob has second thoughts about his choice, in part because his spouse is threatening
1 one has to be a bit careful with such a conclusion, though. for instance, if alice and bob use
a stream cipher an attacker can flip individual bits of the ciphertext, which results in bit flips in
the received plaintext. depending on the application, the attacker might be able to manipulate the
message in a way that is semantically still correct. however, using block ciphers, especially in a
chaining mode, makes it quite likely that ciphertext manipulations can be detected after decryption.

10.1 introduction

261

him with divorce after seeing the car. unfortunately for bob (and his family), alice
has a no return policy. given that she is an experienced car dealer, she knows
too well that it will not be easy to sell a pink and orange car, and she is thus set
on not making any exceptions. since bob now claims that he never ordered the
car, she has no other choice but to sue him. in front of the judge, alices lawyer
presents bobs digital car order together with the encrypted version of it. obviously,
the lawyer argues, bob must have generated the order since he is in possession of
kab with which the ciphertext was generated. however, if bobs lawyer is worth his
money, he will patiently explain to the judge that the car dealer, alice, also knows
kab and that alice has, in fact, a high incentive to generate faked car orders. the
judge, it turns out, has no way of knowing whether the plaintextciphertext pair was
generated by bob or alice given the laws in most countries, bob probably gets
away with his dishonesty.
this might sound like a rather specific and somewhat artificially constructed scenario, but in fact it is not. there are many, many situations where it is important
to prove to a neutral third party, i.e., a person acting as a judge, that one of two (or
more) parties generated a message. by proving we mean that the judge can conclude
without doubt who has generated the message, even if all parties are potentially dishonest. why cant we use some (complicated) symmetric-key scheme to achieve
this goal the high-level explanation is simple exactly because we have a symmetric set-up, alice and bob have the same knowledge (namely of keys) and thus
the same capabilities. everything that alice can do can be done by bob, too. thus,
a neutral third party cannot distinguish whether a certain cryptographic operation
was performed by alice or by bob or by both. generally speaking, the solution to
this problem lies in public-key cryptography. the asymmetric set-up that is inherent
in public-key algorithms might potentially enable a judge to distinguish between
actions that only one person can perform (namely the person in possession of the
private key), and those that can be done by both (namely computations involving
the public key). it turns out that digital signatures are public-key algorithms which
have the properties that are needed to resolve a situation of cheating participants. in
the e-commerce car scenario above, bob would have been required to digitally sign
his order using his private key.

10.1.2 principles of digital signatures
the property of proving that a certain person generated a message is obviously
also very important outside the digital domain. in the real, analog world, this is
achieved by handwritten signatures on paper. for instance, if we sign a contract or
sign a check, the receiver can prove to a judge that we actually signed the message.
(of course, one can try to forge signatures, but there are legal and social barriers that
prevent most people from even attempting to do so.) as with conventional handwritten signatures, only the person who creates a digital message must be capable
of generating a valid signature. in order to achieve this with cryptographic primi-

262

10 digital signatures

tives, we have to apply public-key cryptography. the basic idea is that the person
who signs the message uses a private key, and the receiving party uses the matching
public key. the principle of a digital signature scheme is shown in fig. 10.1.
alice

bob
kpub

x
sig

kpr

s
( x, s )
x, s
kpub

ver

true / false

fig. 10.1 principle of digital signatures which involves signing and verifying a message

the process starts with bob signing the message x. the signature algorithm is a
function of bobs private key, k pr . hence, assuming he in fact keeps his private key
private, only bob can sign a message x on his behalf. in order to relate a signature to
the message, x is also an input to the signature algorithm. after signing the message,
the signature s is appended to the message x and the pair (x, s) is sent to alice. it
is important to note that a digital signature by itself is of no use unless it is accompanied by the message. a digital signature without the message is the equivalent of
a handwritten signature on a strip of paper without the contract or a check that is
supposed to be signed.
the digital signature itself is merely a (large) integer value, for instance, a string
of 2048 bits. the signature is only useful to alice if she has means to verify whether
the signature is valid or not. for this, a verification function is needed which takes
both x and the signature s as inputs. in order to link the signature to bob, the function
also requires his public key. even though the verification function has long inputs,
its only output is the binary statement true or false. if x was actually signed
with the private key that belongs to the public verification key, the output is true,
otherwise it is false.
from these general observations we can easily develop a generic digital signature
protocol

10.1 introduction

263

basic digital signature protocol
alice

bob
generate k pr,b , k pub,b
k pub,b



publish public key
sign message
s  sigk pr (x)

(x,s)



send message + signature

verify signature
verk pr,b (x, s)  true/false

from this set-up, the core property of digital signatures follows a signed message can unambiguously be traced back to its originator since a valid signature can
only be computed with the unique signers private key. only the signer has the ability to generate a signature on his behalf. hence, we can prove that the signing party
has actually generated the message. such a proof can even have legal meaning, for
instance, as in the electronic signatures in global and national commerce act (esign) in the usa or in the signaturgesetz, or signature law, in germany. we note
that the basic protocol above does not provide any confidentiality of the message
since the message x is being sent in the clear. of course, the message can be kept
confidential by also encrypting it, e.g., with aes or 3des.
each of the three popular public-key algorithm families, namely integer factorization, discrete logarithms and elliptic curves, allows us to construct digital signatures. in the remainder of this chapter we learn about most signature schemes that
are of practical relevance.

10.1.3 security services
it is very instructive to discuss in more detail the security functions we can achieve
with digital signatures. in fact, at this point we will step for a moment away from
digital signature and ask ourselves in general what are possible security objectives
that a security system might possess more accurately the objectives of a security
systems are called security services. there exist many security services, but the most
important ones which are desirable in many applications are as follows
1. confidentiality information is kept secret from all but authorized parties.
2. integrity messages have not been modified in transit.
3. message authentication the sender of a message is authentic. an alternative
term is data origin authentication.
4. nonrepudiation the sender of a message can not deny the creation of the message.
different applications call for different sets of security services. for instance, for
private e-mail the first three functions are desirable, whereas a corporate e-mail sys-

264

10 digital signatures

tem might also require nonrepudiation. as another example, if we want to secure
software updates for a cell phone, the chief objectives might be integrity and message authentication because the manufacturer primarily wants to assure that only
original updates are loaded into the handheld device. we note that message authentication always implies data integrity the opposite is not true.
the four security services can be achieved in a more or less straightforward manner with the schemes introduced in this book for confidentiality one uses primarily
symmetric ciphers and less frequently asymmetric encryption. integrity and message authentication are provided by digital signatures and message authentication
codes which, are introduced in chap. 12. nonrepudiation can be achieved with digital signatures as discussed above.
in addition to the four core security services there are several other ones
5. identification/entity authentication establish and verify the identity of an entity, e.g., a person, a computer or a credit card.
6. access control restrict access to the resources to privileged entities.
7. availability assures that the electronic system is reliably available.
8. auditing provide evidence about security-relevant activities, e.g., by keeping
logs about certain events.
9. physical security provide protection against physical tampering and/or responses to physical tampering attempts.
10. anonymity provide protection against discovery and misuse of identity.
which security services are desired in a given system is heavily applicationspecific. for instance, anonymity might make no sense for an e-mail system since
e-mails are supposed to have a clearly identifiable sender. on the other hand, carto-car communication systems for collision avoidance (one of the many exciting
new applications for cryptography we will see in the next ten years or so) have a
strong need to keep cars and drivers anonymous in order to avoid tracking. as a further example, in order to secure an operating system, access control to certain parts
of a computer system is often of paramount importance. most but not all of these
advanced services can be achieved with the crypto algorithms from this book. however, in some cases noncryptographic approaches need to be taken. for instance,
availability is often achieved by using redundancy, e.g., running redundant computing or storage systems in parallel. such solutions are only indirectly, if at all, related
to cryptography.

10.2 the rsa signature scheme
the rsa signature scheme is based on rsa encryption introduced in chap. 7. its
security relies on the difficulty of factoring a product of two large primes (the integer
factorization problem). since its first description in 1978 in [143], the rsa signature
scheme has emerged as the most widely used digital signatures scheme in practice.

10.2 the rsa signature scheme

265

10.2.1 schoolbook rsa digital signature
suppose bob wants to send a signed message x to alice. he generates the same
rsa keys that were used for rsa encryption as shown in chap. 7. at the end of the
set-up he has the following parameters
rsa keys
 bobs private key k pr  (d)
 bobs public key k pub  (n, e)
the actual signature protocol is shown in the following. the message x that is
being signed is in the range (1, 2, . . . , n  1).
basic rsa digital signature protocol
alice

bob
k pr  d, k pub  (n, e)
(n,e)


compute signature
s  sigk pr (x)  xd mod n
(x,s)


verify verk pub (x, s)
x
 se mod n
 x mod n  valid signature
x
 x mod n  invalid signature

as can be seen from the protocol, bob computes the signature s for a message
x by rsa-encrypting x with his private key k pr . bob is the only party who can
apply k pr , and hence the ownership of k pr authenticates him as the author of the
signed message. bob appends the signature s to the message x and sends both to
alice. alice receives the signed message and rsa-decrypts s using bobs public
key k pub , yielding x. if x and x match, alice knows two important things first, the
author of the message was in possession of bobs secret key, and if only bob has
had access to the key, it was in fact bob who signed the message. this is called
message authentication. second, the message has not been changed in transit, so
that message integrity is given. we recall from the previous section that these are
two of the fundamental security services which are often needed in practice.
proof. we now prove that the scheme is correct, i.e., that the verification process
yields a true statement if the message and signature have not been altered during
transmission. we start from the verification operation se mod n
se  (xd )e  xde  x mod n

266

10 digital signatures

due to the mathematical relationship between the private and the public key, namely
that
d e  1 mod  (n),
raising any integer x  zn to the (d e)th power yields the integer itself again. the
proof for this was given in sect. 7.3. 

the role of the public and the private keys are swapped compared to the rsa
encryption scheme. whereas rsa encryption applies the public key to the message
x, the signature scheme applies the private key k pr . on the other side of the communication channel, rsa encryption requires the use of the private key by the receiver,
while the digital signature scheme applies the public key for verification.
lets look at an example with small numbers.
example 10.1. suppose bob wants to send a signed message (x  4) to alice. the
first steps are exactly the same as it is done for an rsa encryption bob computes
his rsa parameters and sends the public key to alice. in contrast to the encryption
scheme, now the private key is used for signing while the public key is needed to
verify the signature.
alice

bob
1. choose p  3 and q  11
2. n  p  q  33
3.  (n)  (3  1)(11  1)  20
4. choose e  3
5. d  e1  7 mod 20
(n,e)(33,3)


compute signature for message
x  4
s  xd  47  16 mod 33
(x,s)(4,16)


verify
x  se  163  4 mod 33
x  x mod 33  valid signature

alice can conclude from the valid signature that bob generated the message and
that it was not altered in transit, i.e., message authentication and message integrity
are given.

it should be noted that we introduced a digital signature scheme only. in particular, the message itself is not encrypted and, thus, there is not confidentiality. if
this security service is required, the message together with the signature should be
encrypted, e.g., using a symmetric algorithm like aes.

10.2 the rsa signature scheme

267

10.2.2 computational aspects
first, we note that the signature is as long as the modulus n, i.e., roughly log2 n
bit. as discussed earlier, n is typically in the range from 1024 to 3072 bit. even
though such a signature length is not a problem in most internet applications, it can
be undesirable in systems that are bandwidth and/or energy constrained, e.g., mobile
phones.
the key generation process is identical to the one we used for rsa encryption,
which was discussed in detail in chap. 7. to compute and verify the signature,
the square-and-multiply algorithm introduced in sect. 7.4 is used. the acceleration
techniques for rsa introduced in sect. 7.5 are also applicable to the digital signature scheme. particularly interesting are short public keys e, for instance, the choice
e  216 + 1. this makes verification a very fast operation. since in many practical
scenarios a message is signed only once but verified many times, the fact that verification is very fast is helpful. this is, e.g., the case in public-key infrastructures
which use certificates. certificates are signed only once but are verified over and
over again every time a user uses his asymmetric keys (cf. sect. 13.3.3).

10.2.3 security
like in every other asymmetric scheme, it must be assured that the public keys
are authentic. this means that the verifying party in fact has the public key that
is associated with the private signature key. if an attacker succeeds in providing
the verifier with an incorrect public key that supposedly belongs to the signer, the
attacker can obviously sign messages. in order to prevent the attack, certificates can
be used, a topic which is discussed in chap. 13.

algorithmic attacks
the first group of attacks attempts to break the underlying rsa scheme by computing the private key d. the most general of these attacks tries to factor the modulus n
into the primes p and q. if an attacker succeeds with this, she can compute the private
key d from e. in order to prevent factoring attacks the modulus must be sufficiently
large, as discussed in sect. 7.8. in practice, 1024 bit or more are recommended.

existential forgery
another attack against the schoolbook rsa signature scheme allows an attacker to
generate a valid signature for a random message x. the attack works as follows

268

10 digital signatures

existential forgery attack against rsa digital signature
alice

oscar

(n,e)



bob
k pr  d
k pub  (n, e)
(n,e)



1. choose signature
s  zn
2. compute message
x  se mod n
(x,s)


verification
se  x mod n
since x  x
 valid signature

the attacker impersonates bob, i.e., oscar claims to alice that he is in fact bob.
because alice performs exactly the same computations as oscar, she will verify
the signature as correct. however, by closely looking at steps 1 and 2 that oscar
performs, one sees that the attack is somewhat odd. the attacker chooses the signature first and then computes the message. as a consequence, he cannot control the
semantics of the message x. for instance, oscar cannot generate a message such as
transfer 1000 into oscars account. nevertheless, the fact that
an automated verification process does not recognize the forgery is certainly not a
desirable feature. for this reason, schoolbook rsa signature is rarely used in practice, and padding schemes are applied in order to prevent this and other attacks.

rsa padding the probabilistic signature standard (pss)
the attack above can be prevented by allowing only certain message formats.
roughly speaking, formatting imposes a rule which allows the verifier, alice in our
examples, to distinguish between valid and invalid messages this is called padding.
for example, a simple formatting rule could specify that all messages x have 100
trailing bits with the value zero (or any other specific bit pattern). if oscar chooses
signature values s and computes the message x  se mod n, it is extremely unlikely that x has this specific format. if we require a certain value for the 100 trailing
bits, the chance that x has this format is 2100 , which is considerably lower than
winning any lottery.
we now look at a padding scheme which is widely used in practice. note that a
padding scheme for rsa encryption was already discussed in sect. 7.7. the probabilistic signature scheme (rsa-pss) is a signature scheme based on the rsa
cryptosystem. it combines signature and verification with an encoding of the message.

10.2 the rsa signature scheme

269

lets have a closer look at rsa-pss. almost always in practice, the message itself is not signed directly but rather the hashed version of it. hash functions compute
a digital fingerprint of messages. the fingerprint has a fixed length, say 160 or 256
bit, but accepts messages as inputs of arbitrary lengths. more about hash functions
and the role the play in digital signatures is found in chap. 11.
in order to be consistent with the terminology used in standards, we denote the
message with m rather than with x. figure 10.2 depicts the encoding procedure
which is known as encoding method for signature with appendix (emsa) probabilistic signature scheme (pss).
encoding for the emsa probabilistic signature scheme
let n be the size of the rsa modulus in bits. the encoded message em
has a length (n  1)/8 bytes such that the bit length of em is at most
n  1 bit.
1. generate a random value salt.
2. form a string m by concatenating a fixed padding padding1 , the hash
value mhash  h(m) and salt.
3. compute a hash value h of the string m .
4. concatenate a fixed padding padding2 and the value salt to form a data
block db.
5. apply a mask generation function mgf to the string m to compute the
mask value dbmask. in practice, a hash function such as sha-1 is often
used as mgf.
6. xor the mask value dbmask and the data block db to compute
maskeddb.
7. the encoded message em is obtained by concatenating maskeddb, the
hash value h and the fixed padding bc.
after the encoding, the actual signing operation is applied to the encoded message em, e.g.,
s  sigk pr (x)  em d mod n
the verification operation then proceeds in a similar way recovery of the salt value
and checking whether the emsa-pss encoding of the message is correct. note that
the receiver knows the values of padding1 and padding2 from the standard.
the value h in em is in essence the hashed version of the message. by adding
a random value salt prior to the second hashing, the encoded value becomes probabilistic. as a consequence, if we encode and sign the same message twice, we obtain
different signatures, which is a desirable feature.

270

10 digital signatures

























 



fig. 10.2 principle of emsa-pss encoding

10.3 the elgamal digital signature scheme
the elgamal signature scheme, which was published in 1985, is based on the difficulty of computing discrete logarithms (cf. chap. 8). unlike rsa, where encryption
and digital signature are almost identical operations, the elgamal digital signature
is quite different from the encryption scheme with the same name.

10.3.1 schoolbook elgamal digital signature
key generation
as with every public-key scheme, there is a set-up phase during which the keys are
computed. we start by finding a large prime p and constructing a discrete logarithm
problem as follows

10.3 the elgamal digital signature scheme

271

key generation for elgamal digital signature
1.
2.
3.
4.

choose a large prime p.
choose a primitive element  of zp or a subgroup of zp .
choose a random integer d  {2, 3, . . . , p  2}.
compute    d mod p .

the public key is now formed by k pub  (p,  ,  ), and the private key by k pr  d.

signature and verification
using the private key and the parameters of the public key, the signature
sigk pr (x, ke )  (r, s)
for a message x is computed during the signing process. note that the signature
consists of two integers r and s. the signing consists of two main steps choosing a
random value ke , which forms an ephemeral private key, and computing the actual
signature of x.
elgamal signature generation
1. choose a random ephemeral key ke  {0, 1, 2, . . . , p  2} such that
gcd(ke , p  1)  1.
2. compute the signature parameters
r   ke mod p,
s  (x  d  r) ke1 mod p  1.
on the receiving side, the signature is verified as verk pub (x, (r, s)) using the public
key, the signature and the message.
elgamal signature verification
1. compute the value

t   r  rs mod p

2. the verification follows from

  x mod p  valid signature
t
  x mod p  invalid signature

272

10 digital signatures

in short, the verifier accepts a signature (r, s) only if the relation  r  rs   x mod
p is satisfied. otherwise, the verification fails. in order to make sense of the rather
arbitrary looking rules for computing the signature parameters r and s as well as the
verification, it is helpful to study the following proof.
proof. well prove the correctness of the elgamal signature scheme. more specifically, we show that the verification process yields a true statement if the verifier
uses the correct public key and the correct message, and if the signature parameters
(r, s) were chosen as specified. we start with the verification equation

 r  rs  ( d )r ( ke )s mod p
  d r+ke s mod p.
we require that the signature is considered valid if this expression is identical to  x 

 x   d r+ke s mod p.

(10.1)

according to fermats little theorem, the relationship (10.1) holds if the exponents
on both sides of the expression are identical modulo p  1
x  d r + ke s mod p  1
from which the construction rule of the signature parameters s follows
s  (x  d  r)ke1 mod p  1.


the condition that gcd(ke , p  1)  1 is required since we have to invert the
ephemeral key modulo p  1 when computing s.
lets look at an example with small numbers.
example 10.2. again, bob wants to send a message to alice. this time, it should
be signed with the elgamal digital signature scheme. the signature and verification
process is as follows

10.3 the elgamal digital signature scheme
alice

(p, , )(29,2,7)

273
bob
1. choose p  29
2. choose   2
3. choose d  12
4.    d  7 mod 29


compute signature for message
x  26
choose ke  5, note that
gcd(5, 28)  1
r   ke  25  3 mod 29
s  (x  d r) ke1  (10)  17 
26 mod 28
(x,(r,s))(26,(3,26))


verify
t   r  rs  73  326  22 mod 29
 x  226  22 mod 29
t   x mod 29  valid signature



10.3.2 computational aspects
the key generation phase is identical to the set-up phase of elgamal encryption,
which we introduced in sect. 8.5.2. because the security of the signature scheme
relies on the discrete logarithm problem, p needs to have the properties discussed
in sect. 8.3.3. in particular, it should have a length of at least 1024 bits. the prime
can be generated using the prime-finding algorithms introduced in sect 7.6. the
private key should be generated by a true random number generator. the public key
requires one exponentiation using the square-and-multiply algorithm.
the signature consists of the pair (r, s). both have roughly the same bit length
as p, so that the total length of the package (x, (r, s)) is about three times as long
as only the message x. computing r requires an exponentiation modulo p, which
can be achieved with the square-and-multiply algorithm. the main operation when
computing s is the inversion of ke . this can be done using the extended euclidean
algorithm. a speed-up is possible through precomputing. the signer can generate
the ephemeral key ke and r in advance and store both values. when a message is to
be signed, they can be retrieved and used to compute s. the verifier performs two
exponentiations that are again computed with the square-and-multiply algorithm,
and one multiplication.

274

10 digital signatures

10.3.3 security
first, we must make sure that the verifier has the correct public key. otherwise,
the attack sketched in sect. 10.2.3 is applicable. other attacks are described in the
following.

computing discrete logarithms
the security of the signature scheme relies on the discrete logarithm problem (dlp).
if oscar is capable of computing discrete logarithms, he can compute the private key
d from  as well as the ephemeral key ke from r. with this knowledge, he can sign
arbitrary messages on behalf of the signer. hence the elgamal parameters must be
chosen such that the dlp is intractable. we refer to sect. 8.3.3 for a discussion of
possible discrete logarithm attacks. one of the key requirements is that the prime p
should be at least 1024-bit long. we have also make sure that small subgroup attacks
are not possible. in order to counter this attack, in practice primitive elements 
are used to generate a subgroup of prime order. in such groups, all elements are
primitive and small subgroups do not exist.

reuse of the ephemeral key
if the signer reuses the ephemeral key ke , an attacker can easily compute the private
key a. this constitutes a complete break of the system. here is how the attack works.
oscar observes two digital signatures and messages of the form (x, (r, s)). if the
two messages x1 and x2 have the same ephemeral key ke , oscar can detect this since
the two r values are the same because they were constructed as r1  r2   ke . the
two s values are different, and oscar obtains the following two expressions
s1  (x1  d r)ke1 mod p  1

(10.2)

s2 

(10.3)

(x2  d r)ke1

mod p  1

this is an equation system with the two unknowns d, which is bobs private key ()
and the ephemeral key ke . by multiplying both equations by ke it becomes a linear
system of equations which can be solved easily. oscar simply subtracts the second
equation from the first one, yielding
s1  s2  (x1  x2 )ke1 mod p  1
from which the ephemeral key follows as
ke 

x1  x2
mod p  1.
s1  s2

10.3 the elgamal digital signature scheme

275

if gcd(s1  s2 , p  1)  1, the equation has multiple solutions for ke , and oscar has
to verify which is the correct one. in any case, using ke , oscar can now also compute
the private key through either eq. (10.2) or eq. (10.3)
d

x1  s1 ke
mod p  1.
r

with the knowledge of the private key d and the public key parameters, oscar can
now freely sign any documents on bobs behalf. in order to avoid the attack, fresh
ephemeral keys stemming from a random number generator should be used for every
digital signature.
an attack with small numbers is given in the next example.
example 10.3. lets assume the situation where oscar eavesdrops on the following
two messages that were previously signed with bobs private key and that use the
same ephemeral key ke 
1. (x1 , (r, s1 ))  (26, (3, 26)),
2. (x2 , (r, s2 ))  (13, (3, 1)).
additionally, oscar knows bobs public key, which is given as
(p,  ,  )  (29, 2, 7).
with this information, oscar is now able to compute the ephemeral key
x1  x2
mod p  1
s1  s2
26  13
 13  9

26  1
 5 mod 28

ke 

and finally reveal bobs private key d
x1  s1  ke
mod p  1
r
26  26  5

 8  19
3
 12 mod 28.

d



existential forgery attack
similar to the case of rsa digital signatures, it is also possible that an attacker generates a valid signature for a random message x. the attacker, oscar, impersonates
bob, i.e., oscar claims to alice that he is in fact bob. the attack works as follows

276

10 digital signatures

existential forgery attack against elgamal digital signature
alice

oscar
(p, , )

(p, , )



bob
k pr  d
k pub  (p,  ,  )



1. select integers i, j
where gcd( j, p  1)  1
2. compute signature
r   i  j mod p
s  r j1 mod p 
1
3. compute message
x  s i mod p  1
(x,(r,s))


verification
t   r  rs mod p
since t   x mod p
valid signature

the verification yields a true statement because the following holds
t   r  rs mod p
  d r  rs mod p
  d r   (i+d j)s mod p
  d r   (i+d j)(r j
r i j1



si
  mod p
d rd r

1 )

mod p

mod p

since the message was constructed as x  s i mod p  1, the last expression is equal
to
 s i   x mod p
which is exactly alices condition for accepting the signature as valid.
the attacker computes in step 3 the message x, the semantics of which he cannot
control. thus, oscar can only compute valid signatures for pseudorandom messages.
the attack is not possible if the message is hashed, which is, in practice, very
often the case. rather than using the message directly for computing the signature,
one applies a hash function to the message prior to signing, i.e., the signing equation
becomes
s  (h(x)  d  r)ke1 mod p  1.

10.4 the digital signature algorithm (dsa)

277

10.4 the digital signature algorithm (dsa)
the native elgamal signature algorithm described in this section is rarely used in
practice. instead, a much more popular variant is used, known as the digital signature algorithm (dsa). it is a federal us government standard for digital signatures
(dss) and was proposed by the national institute of standards and technology
(nist). its main advantages over the elgamal signature scheme are that the signature is only 320-bit long and that some of the attacks that can threaten the elgamal
scheme are not applicable.

10.4.1 the dsa algorithm
we introduce here the dsa standard with a bit length of 1024 bit. note that longer
bit lengths are also possible in the standard.

key generation
the keys for dsa are computed as follows
key generation for dsa
1. generate a prime p with 21023  p  21024 .
2. find a prime divisor q of p  1 with 2159  q  2160 .
3. find an element  with ord( )  q, i.e.,  generates the subgroup with
q elements.
4. choose a random integer d with 0  d  q.
5. compute    d mod p.
the keys are now
k pub  (p, q,  ,  )
k pr  (d)
the central idea of dsa is that there are two cyclic groups involved. one is the
large cyclic group zp , the order of which has bit length of 1024 bit. the second one
is in the 160-bit subgroup of zp . this set-up yields shorter signatures, as we see in
the following.
in addition to the 1024-bit prime p and a 160-bit prime q, there are two other bit
length combinations possible for the primes p and q. according to the latest version
of the standard, the combinations shown in table 10.1 are allowed.
if one of the other bit lengths is required, only steps 1 and 2 of the key generation
phase have to be adjusted accordingly. more about the issue of bit length will be said
in sect. 10.4.3 below.

278

10 digital signatures

table 10.1 bit lengths of important parameters of dsa
p
1024
2048
3072

q signature
160
320
224
448
256
512

signature and verification
as in the elgamal signature scheme, the dsa signature consists of a pair of integers
(r, s). since each of the two parameters is only 160-bit long, the total signature
length is 320 bit. using the public and private key, the signature for a message x is
computed as follows
dsa signature generation
1. choose an integer as random ephemeral key ke with 0  ke  q.
2. compute r  ( ke mod p) mod q.
3. compute s  (sha(x) + d  r) ke 1 mod q.
according to the standard, the message x has to be hashed using the hash function
sha-1 in order to compute s. hash functions, including sha-1, are described in
chap. 11. for now it is sufficient to know that sha-1 compresses x and computes a
160-bit fingerprint. this fingerprint can be thought of as a representative of x.
the signature verification process is as follows
dsa signature verification
1.
2.
3.
4.
5.

compute auxiliary value w  s1 mod q.
compute auxiliary value u1  w  sha(x) mod q.
compute auxiliary value u2  w  r mod q.
compute v  ( u1   u2 mod p) mod q.
the verification verk pub (x, (r, s)) follows from

v

 r mod q  valid signature
 r mod q  invalid signature

the verifier accepts a signature (r, s) only if v  r mod q is satisfied. otherwise,
the verification fails. in this case, the message or the signature may have been modified or the verifier is not in possession of the correct public key. in any case, the
signature should be considered invalid.
proof. we show that a signature (r, s) satisfies the verification condition v  r mod
q. well start with the signature parameter s

10.4 the digital signature algorithm (dsa)

279

s  (sha(x) + d r) ke 1 mod q
which is equivalent to
ke  s1 sha(x) + d s1 r mod q.
the right-hand side can be expressed in terms of the auxiliary values u1 and u2 
ke  u1 + d u2 mod q.
we can raise  to either side of the equation if we reduce modulo p

 ke mod p   u1 +d u2 mod p.
since the public key value  was computed as    d mod p, we can write

 ke mod p   u1  u2 mod p.
we now reduce both sides of the equation modulo q
( ke mod p) mod q  ( u1  u2 mod p) mod q.
since r was constructed as r  ( ke mod p) mod q and v  ( u1  u2 mod p) mod q,
this expression is identical to the condition for verifying a signature as valid
r  v mod q.


lets look at an example with small numbers.
example 10.4. bob wants to send a message x to alice which is to be signed with
the dsa algorithm. suppose the hash value of x is h(x)  26. then the signature
and verification process is as follows
alice

(p,q, , )(59,29,3,4)

bob
1. choose p  59
2. choose q  29
3. choose   3
4. choose private key d  7
5.    d  4 mod 59


sign
compute hash of message h(x)  26
1. choose ephemeral key ke  10
2. r  (310 mod 59)  20 mod 29
3. s  (26 + 7  20)  3  5 mod 29
(x,(r,s))(x,(20,5))


verify
1. w  51  6 mod 29
2. u1  6  26  11 mod 29
3. u2  6  20  4 mod 29
4. v  (311  44 mod 59) mod 29  20
5. v  r mod 29  valid signature

280

10 digital signatures

in this example, the subgroup has a prime order of q  29, whereas the large
cyclic group modulo p has 58 elements. we note that 58  2  29. we replaced the
function sha(x) by h(x) since the sha hash function has an output of length 160
bit.


10.4.2 computational aspects
we discuss now the computations involved in the dsa scheme. the most demanding part is the key-generation phase. however, this phase only has to be executed
once at set-up time.

key generation
the challenge in the key-generation phase is to find a cyclic group zp with a bit
length of 1024, and which has a prime subgroup in the range of 2160 . this condition is fulfilled if p  1 has a prime factor q of 160 bit. the general approach to
generating such parameters is to first find the 160-bit prime q and then to construct
the larger prime p from it. below is the prime-generating algorithm. note that the
nist-specified scheme is slightly different.
prime generation for dsa
output two primes (p, q), where 21023  p  21024 and 2159  q  2160 ,
such that p  1 is a multiple of q.
initialization i  1
algorithm
1 find prime q with 2159  q  2160 using the millerrabin algorithm
2 for i  1 to 4096
2.1
generate random integer m with 21023  m  21024
2.2
mr  m mod 2q
(note that p  1 is a multiple of 2q.)
2.3
p  1  m  mr
if p is prime
(use millerrabin primality test)
2.4
return (p, q)
2.5
ii+1
3 goto step 1
the choice of 2q as modulus in step 2.3 assures that the prime candidates generated in step 2.3 are odd numbers. since p  1 is divisible by 2q, it is also divisible
by q. if p is a prime, zp thus has a subgroup of order q.

10.4 the digital signature algorithm (dsa)

281

signing
during signing we compute the parameters r and s. computing r involves first evaluation gke mod p using the square-and-multiply algorithm. since ke has only 160
bit, about 1.5  160  240 squarings and multiplications are required on average,
even though the arithmetic is done with 1024-bit numbers. the result, which has
also a length of 1024 bit, is then reduced to 160 bit by the operation  mod q. computing s involves only 160-bit numbers. the most costly step is the inversion of
ke .
of these operations, the exponentiation is the most costly one in terms of computational complexity. since the parameter r does not depend on the message, it can
be precomputed so that the actual signing can be a relatively fast operation.

verification
computing the auxiliary parameters w, u1 and u2 only involves 160-bit operands,
which makes them relatively fast.

10.4.3 security
an interesting aspect of dsa is that we have to protect against two different discrete
logarithm attacks. if an attacker wants to break dsa, he could attempt to compute
the private key d by solving the discrete logarithm in the large cyclic group modulo
p
d  log  mod p.
the most powerful method for this is the index calculus attack, which was sketched
in sect. 8.3.3. in order to thwart this attack, p must be at least 1024-bit long. it is
estimated that this provides a security level of 80 bit, i.e., an attack would need on
the order of 280 operations (cf. table 6.1 in chap. 6). for higher security levels,
nist allows primes with lengths of 2048 and 3072 bit.
the second discrete logarithm attack on dsa is to exploit the fact that  generates only a small subgroup of order q. hence, it seems promising to attack only
the subgroup, which has a size of about 2160 , rather than the large cyclic group with
about 21024 elements formed by p. however, it turns out that the powerful indexcalculus attack is not applicable if oscar wants to exploit the subgroup property. the
best he can do is to perform one of the generic dlp attacks, i.e., either the babystep giant-step method or pollards rho method (cf. sect. 8.3.3). these are so-called
square root attacks, and given that the subgroup
has an order of approximately 2160 ,

160
these attacks provide a security level of 2  280 . it is not a coincidence that the
index calculus attack and the square root attack have a comparable complexity, in
fact the parameter sizes were deliberately chosen that way. one has to be careful,

282

10 digital signatures

though, if the size of p is increased to 2048 or 3072 bit. this only increases the difficulty of the index-calculus attack, but the small subgroup attack would still have a
complexity of 280 if the subgroup stays the same size. for this reason q also must be
increased if larger p values are chosen. table 10.2 shows the nist-specified lengths
of the primes p and q together with the resulting security levels. the security level of
the hash function must also match the one of the discrete logarithm problem. since
the cryptographic strength of a hash function is mainly determined by the bit length
of the hash output, the minimum hash output is also given in the table. more about
security of hash functions will be said in chap. 11.
table 10.2 standardized parameter bit lengths and security levels for dsa
p
1024
2048
3072

q hash output (min) security levels
160
160
80
224
224
112
256
256
128

it should be stressed that the record for discrete logarithm calculations is 532 bit,
so that the 1024-bit dsa variant is currently secure, and the 2048-bit and 3072-bit
variants seem to provide good long-term security.
in addition to discrete logarithm attacks, dsa becomes vulnerable if the ephemeral key is reused. this attack is completely analogues to the case of elgamal
digital signature. hence, it must be assured that a fresh randomly-genererated key
ke is used in every signing operation.

10.5 the elliptic curve digital signature algorithm (ecdsa)
as discussed in chap. 9, elliptic curves have several advantages over rsa and
over dl schemes like elgamal or dsa. in particular, in absence of strong attacks
against elliptic curve cryptosystems (ecc), bit lengths in the range of 160256 bit
can be chosen which provide security equivalent to 10243072-bit rsa and dl
schemes. the shorter bit length of ecc often results in shorter processing time and
in shorter signatures. for these reasons, the elliptic curve digital signature algorithm (ecdsa) was standardized in the us by the american national standards
institute (ansi) in 1998.

10.5.1 the ecdsa algorithm
the steps in the ecdsa standard are conceptionally closely related to the dsa
scheme. however, its discrete logarithm problem is constructed in the group of

10.5 the elliptic curve digital signature algorithm (ecdsa)

283

an elliptic curve. thus, the arithmetic to be performed for actually computing an
ecdsa signature is entirely different from that used for dsa.
the ecdsa standard is defined for elliptic curves over prime fields z p and galois fields gf(2m ). the former is often preferred in practice, and we will only introduce this one in what follows.

key generation
the keys for the ecdsa are computed as follows
key generation for ecdsa
1. use an elliptic curve e with




modulus p
coefficients a and b
a point a which generates a cyclic group of prime order q

2. choose a random integer d with 0  d  q.
3. compute b  d a.
the keys are now
k pub  (p, a, b, q, a, b)
k pr  (d)
note that we have set up a discrete logarithm problem where the integer d is the
private key and the result of the scalar multiplication, point b, is the public key.
similar to dsa, the cyclic group has an order q which should have a size of at least
160 bit or more for higher security levels.

signature and verification
like dsa, an ecdsa signature consists of a pair of integers (r, s). each value has
the same bit length as q, which makes for fairly compact signatures. using the public
and private key, the signature for a message x is computed as follows
ecdsa signature generation
1.
2.
3.
4.

choose an integer as random ephemeral key ke with 0  ke  q.
compute r  ke a.
let r  xr .
compute s  (h(x) + d  r) ke 1 mod q.

284

10 digital signatures

in step 3 the x-coordinate of the point r is assigned to the variable r. the message x has to be hashed using the function h in order to compute s. the hash function
output length must be at least as long as q. more about the choice of the hash function will be said in chap. 11. however, for now it is sufficient to know that the
hash function compresses x and computes a fingerprint which can be viewed as a
representative of x.
the signature verification process is as follows
ecdsa signature verification
1.
2.
3.
4.
5.

compute auxiliary value w  s1 mod q.
compute auxiliary value u1  w  h(x) mod q.
compute auxiliary value u2  w  r mod q.
compute p  u1 a + u2 b.
the verification verk pub (x, (r, s)) follows from

xp

 r mod q  valid signature
 r mod q  invalid signature

in the last step, the notation xp indicates the x-coordinate of the point p. the verifier
accepts a signature (r, s) only if the xp has the same value as the signature parameter
r modulo q. otherwise, the signature should be considered invalid.
proof. we show that a signature (r, s) satisfies the verification condition r  xp mod
q. well start with the signature parameter s
s  (h(x) + d r) ke 1 mod q
which is equivalent to
ke  s1 h(x) + d s1 r mod q.
the right-hand side can be expressed in terms of the auxiliary values u1 and u2 
ke  u1 + d u2 mod q.
since the point a generates a cyclic group of order q, we can multiply both sides of
the equation with a
ke a  (u1 + d u2 ) a.
since the group operation is associative, we can write
ke a  u1 a + d u2 a
and
ke a  u1 a + u2 b.

10.5 the elliptic curve digital signature algorithm (ecdsa)

285

what we showed so far is that the expression u1 a + u2 b is equal to ke a if the
correct signature and key (and message) have been used. but this is exactly the
condition that we check in the verification process by comparing the x-coordinates
of p  u1 a + u2 b and r  ke a.


using the small elliptic curve from chap. 9, we look at a simple ecdsa example.
example 10.5. bob wants to send a message to alice that is to be signed with the
ecdsa algorithm. the signature and verification process is as follows
alice

bob
choose e with p  17, a  2, b 
2, and
a  (5, 1) with q  19
choose d  7
compute b  d a  7  (5, 1) 
(0, 6)
(p,a,b,q,a,b)


(17,2,2,19,(5,1),(0,6))

sign
compute hash of message h(x) 
26
choose ephemeral key ke  10
r  10  (5, 1)  (7, 11)
r  xr  7
s  (26 + 7  7)  2  17 mod 19
(x,(r,s))(x,(7,17))


verify
w  171  9 mod 19
u1  9  26  6 mod 19
u2  9  7  6 mod 19
p  6  (5, 1) + 6  (0, 6)  (7, 11)
xp  r mod 19  valid signature

note that we chose the elliptic curve
e  y2  x3 + 2x + 2 mod 17
which is discussed in sect. 9.2. because all points of the curve form a cyclic group
of order 19, i.e., a prime, there are no subgroups and hence in this case q  e  19.


10.5.2 computational aspects
we discuss now the computations involved in the three stages of the ecdsa
scheme.

286

10 digital signatures

key generation as discussed earlier, finding an elliptic curve with good cryptographic properties is a nontrivial task. in practice, standardized curves such as the
ones proposed by nist or the brainpool consortium are often used. the remaining
computation in the key generation phase is one point multiplication, which can be
done using the double-and-add algorithm.
signing during signing we first compute the point r, which requires one point
multiplication, and from which r immediately follows. for the parameter s we have
to invert the ephemeral key, which is done with the extended euclidean algorithm.
the other main operations are hashing of the message and one reduction modulo q.
the point multiplication, which is in most cases by the far the most arithmeticintensive operation, can be precomputed by choosing the ephemeral key ahead of
time, e.g., during the idle time of a cpu. thus, in situations where precomputation
is an option, signing becomes a very fast operation.
verification computing the auxiliary parameters w, u1 and u2 involves straightforward modular arithmetic. the main computational load occurs during the evaluation
of pu1 a + u2 b. this can be accomplished by two separate point multiplications.
however, there are specialized methods for simultaneous exponentiations (remember from chap. 9 that point multiplication is closely related to exponentiation) which
are faster than two individual point multiplications.

10.5.3 security
given that the elliptic curve parameters are chosen correctly, the main analytical attack against ecdsa attempts to solve the elliptic curve discrete logarithm problem.
if an attacker were capable of doing this, he could compute the private key d and/or
the ephemeral key. however, the best known ecc attacks have a complexity proportional to the square root of the size of the group in which the dl problem is defined,

i.e., proportional to q. the parameter length of ecdsa and the corresponding
security levels are given in table 10.3. we recall that the prime p is typically only
slightly larger than q, so that all arithmetic for ecdsa is done with operands which
have roughly the bit length of q.
the security level of the hash function must also match that of the discrete logarithm problem. the cryptographic strength of a hash function is mainly determined
by the length of its output. more about security of hash functions will be said in
chap. 11.
the security levels of 128, 192 and 256 were chosen so that they match the
security offered by aes with its three respective key sizes.
more subtle attacks against ecdsa are also possible. for instance, at the beginning of verification it must be checked whether r, s  {1, 2, . . . , q} in order to prevent
a certain attack. also, protocol-based weaknesses, e.g., reusing the ephemeral key,
must be prevented.

10.6 discussion and further reading

287

table 10.3 bit lengths and security levels of ecdsa
q hash output (min) security levels
192
192
96
224
224
112
256
256
128
384
384
192
512
512
256

10.6 discussion and further reading
digital signature algorithms the first practical realization of digital signatures
was introduced in the original paper by rivest, shamir and adleman [143]. rsa
digital signatures have been standardized by several bodies for a long time, see,
e.g., [95]. rsa signatures were, and in many cases still are, the de facto standard
for many applications, especially for certificates on the internet.
the elgamal digital signature was published in 1985 in [73]. many variants of
this scheme are possible and have been proposed over the years. for a compact
summary, see [120, note 11.70].
the dsa algorithm was proposed in 1991 and became a us standard in 1994.
there were two possible motivations for the government to create this standard as an
alternative to rsa. first, rsa was patented at that time and having a free alternative
was attractive for us industry. second, an rsa digital signature implementation
can also be used for encryption. this was not desirable (from the us government
viewpoint) since there were still rather strict export restrictions for cryptography
in the us at that time. in contrast, a dsa implementation can only be used for
signing and not for encryption, and it was easier to export systems that only included
signature functionality. note that dsa refers to the digital signature algorithm, and
the corresponding standard is referred to as dss, the digital signature standard.
today, dss includes not only the dsa algorithm but also ecdsa and rsa digital
signatures [126].
in addition to the algorithms discussed in this chapter, there exist several other
schemes for digital signatures. these include, e.g., the rabin signature [140], the
fiatshamir signature [76], the pointchevalstern signature [134] and the schnorr
signature [150].
using digital signatures with digital signatures, the problem of authentic public
keys is acute how can alice (or bob) assure that they possess the correct public
keys for each other or, phrased differently, how can oscar be prevented from injecting faked public keys in order to perform an attack we discuss this question in
detail in chap. 13, where certificates are introduced. certificates are based on digital
signatures and are one of the main applications of digital signatures. they bind an
identity (e.g., alices e-mail address) to a public key.
one of the more interesting interactions between society and cryptography is
digital signature laws. they basically assure that a cryptographic digital signature
has a legally binding meaning. for instance, an electronic contract that was digitally

288

10 digital signatures

signed can be enforced in the same way as a conventionally signed contract. around
the turn of the millennium, many nations introduced corresponding laws. this was at
a time that the brave new world of the internet had opened up seemingly endless
opportunities for doing business online, and digital signature laws seemed to be
crucial to allow trusted business transactions via the internet. examples of digital
signature laws are the electronic signatures in global and national commerce act
(esign) in the us [138], or the corresponding directive of the european union
[133]. a good online source for more information is the digital law survey [167].
even though much electronic commerce is today conducted without making use of
signature laws, there will be without doubt more and more situations where those
laws are actually needed.
one crucial issue when using digital signatures in the real world is that the private
keys, especially if used in a setting with legal significance, have to be kept strictly
confidential. this requires a secure way to store this delicate key material. one
way to satisfy this requirement is to employ smart cards that can be used as secure
containers for secret keys. a secret key never leaves the smart card, and signatures
are performed within the cpu inside the smart card. for applications with high
security requirements, so called tamper-resistant smart cards are protected against
several types of hardware attacks. reference [141] provides excellent insight into
the various facets of the highly sophisticated smart card technology.

10.7 lessons learned










digital signatures provide message integrity, message authentication and nonrepudiation.
one of the main application areas of digital signatures is certificates.
rsa is currently the most widely used digital signature algorithm. competitors
are the digital signature standard (dsa) and the elliptic curve digital signature
standard (ecdsa).
the elgamal signature scheme is the basis for dsa. in turn, ecdsa is a generalization of dsa to elliptic curves.
rsa verification can be done with short public keys e. hence, in practice, rsa
verification is usually faster than signing.
dsa and ecdsa have the advantage over rsa in that the signatures are much
shorter.
in order to prevent certain attacks, rsa should be used with padding.
the modulus of dsa and the rsa signature schemes should be at least 1024bits long. for true long-term security, a modulus of length 3072 bits should be
chosen. in contrast, ecdsa achieves the same security levels with bit lengths in
the range 160256 bits.

problems

289

problems
10.1. in sect. 10.1.3 we state that sender (or message) authentication always implies
data integrity. why is the opposite true too, i.e., does data integrity imply sender
authentication justify both answers.
10.2. in this exercise, we want to consider some basic aspects of security services.
1. does privacy always guarantee integrity justify your answer.
2. in which order should confidentiality and integrity be assured (should the entire
message be encrypted first or last) give the rationale for your answer.
10.3. design a security service that provides data integrity, data confidentiality and
nonrepudiation using public-key cryptography in a two-party communication system over an insecure channel. give a rationale that data integrity, confidentiality
and nonrepudiation are achieved by your solution. (recommendation consider the
corresponding threats in your argumentation.)
10.4. a painter comes up with a new business idea he wants to offer custom paintings from photos. both the photos and paintings will be transmitted in digital form
via the internet. one concern that he has is discretion towards his customers, since
potentially embarrassing photos, e.g., nude photos, might be sent to him. hence,
the photo data should not be accessible for third parties during transmission. the
painter needs multiple weeks for the creation of a painting, and hence he wants to
assure that he cannot be fooled by someone who sends in a photo assuming a false
name. he also wants to be assured that the painting will definitely be accepted by
the customer and that she cannot deny the order.
1. choose the necessary security services for the transmission of the digitalized
photos from the customers to the painter.
2. which cryptographic elements (e.g., symmetric encryption) can be utilized to
achieve the security services assume that several megabytes of data have to be
transmitted for every photo.
10.5. given an rsa signature scheme with the public key (n  9797, e  131),
which of the following signatures are valid
1. (x  123, sig(x)  6292)
2. (x  4333, sig(x)  4768)
3. (x  4333, sig(x)  1424)
10.6. given an rsa signature scheme with the public key (n  9797, e  131),
show how oscar can perform an existential forgery attack by providing an example
of such for the parameters of the rsa digital signature scheme.
10.7. in an rsa digital signature scheme, bob signs messages xi and sends them
together with the signatures si and her public key to alice. bobs public key is the
pair (n, e) her private key is d.

290

10 digital signatures

oscar can perform man-in-the-middle attacks, i.e., he can replace bobs public
key by his own on the channel. his goal is to alter messages and provide these with
a digital signature which will check out correctly on alices side. show everything
that oscar must do for a successful attack.
10.8. given is an rsa signature scheme with emsa-pss padding as shown in
sect. 10.2.3. describe the verification process step-by-step that has to be performed
by the receiver of a signature that was emsa-pss encoded.
10.9. one important aspect of digital signatures is the computational effort required
to (i) sign a message, and (ii) to verify a signature. we study the computational
complexity of the rsa algorithm used as a digital signature in this problem.
1. how many multiplications do we need, on average, to perform (i) signing of a
message with a general exponent, and (ii) verification of a signature with the
short exponent e  216 + 1 assume that n has l  log2 n bits. assume the
square-and-multiply algorithm is used for both signing and verification. derive
general expressions with l as a variable.
2. which takes longer, signing or verification
3. we now derive estimates for the speed of actual software implementation. use
the following timing model for multiplication the computer operates with 32-bit
data structures. hence, each full-length variable, in particular n and x, is represented by an array with m  l/32 elements (with x being the basis of the exponentiation operation). we assume that one multiplication or squaring of two of
these variables modulo n takes m2 time units (a time unit is the clock period times
some constant larger than one which depends on the implementation). note that
you never multiply with the exponents d and e. that means, the bit length of the
exponent does not influence the time it takes to perform an individual modular
squaring or multiplication.
how long does it take to compute a signature/verify a signature if the time unit
on a certain computer is 100 nsec, and n has 512 bits how long does it take if n
has 1024 bit
4. smart cards are one very important platform for the use of digital signatures.
smart cards with an 8051 microprocessor kernel are popular in practice. the
8051 is an 8-bit processor. what time unit is required in order to perform one
signature generation in 0.5 sec if n has (i) 512 bits and (ii) 1024 bits since these
processors cannot be clocked at more than, say, 10 mhz, is the required time unit
realistic
10.10. we now consider the elgamal signature scheme. you are given bobs private key kpr  (d)  (67) and the corresponding public key kpub  (p,  ,  ) 
(97, 23, 15).
1. calculate the elgamal signature (r, s) and the corresponding verification for a
message from bob to alice with the following messages x and ephemeral keys
ke 
a. x  17 and ke  31

problems

291

b. x  17 and ke  49
c. x  85 and ke  77
2. you receive two alleged messages x1 , x2 with their corresponding signatures
(ri , si ) from bob. verify whether the messages (x1 , r1 , s1 )  (22, 37, 33) and
(x2 , r2 , s2 )  (82, 13, 65) both originate from bob.
3. compare the rsa signature scheme with the elgamal signature scheme. where
are their relative advantages and drawbacks
10.11. given is an elgamal signature scheme with p  31,   3 and   6. you
receive the message x  10 twice with the signatures (r, s)
(i) (17, 5)
(ii) (13, 15)
1. are both signatures valid
2. how many valid signatures are there for each message x and the specific parameters chosen above
10.12. given is an elgamal signature scheme with the public parameters (p 
97,   23,   15). show how oscar can perform an existential forgery attack
by providing an example for a valid signature.
10.13. given is an elgamal signature scheme with the public parameters p,  
zp and an unknown private key d. due to faulty implementation, the following
dependency between two consecutive ephemeral keys is fulfilled
kei+1  kei + 1.
furthermore, two consecutive signatures to the plaintexts x1 and x2
(r1 , s1 )
and

(r2 , s2 )

are given. explain how an attacker is able to calculate the private key with the given
values.
10.14. the parameters of dsa are given by p  59, q  29,   3, and bobs private key is d  23. show the process of signing (bob) and verification (alice) for
following hash values h(x) and ephemeral keys ke 
1. h(x)  17, ke  25
2. h(x)  2, ke  13
3. h(x)  21, ke  8
10.15. show how dsa can be attacked if the same ephemeral key is used to sign
two different messages.

292

10 digital signatures

10.16. the parameters of ecdsa are given by the curve e  y2  x3 + 2x +
2 mod 17, the point a  (5, 1) of order q  19 and bobs private d  10. show
the process of signing (bob) and verification (alice) for following hash values h(x)
and ephemeral keys ke 
1. h(x)  12, ke  11
2. h(x)  4, ke  13
3. h(x)  9, ke  8

chapter 11

hash functions

hash functions are an important cryptographic primitive and are widely used in
protocols. they compute a digest of a message which is a short, fixed-length bitstring. for a particular message, the message digest, or hash value, can be seen as
the fingerprint of a message, i.e., a unique representation of a message. unlike all
other crypto algorithms introduced so far in this book, hash functions do not have
a key. the use of hash functions in cryptography is manifold hash functions are
an essential part of digital signature schemes and message authentication codes, as
discussed in chapter 12. hash functions are also widely used for other cryptographic
applications, e.g., for storing of password hashes or key derivation.
in this chapter you will learn






why hash functions are required in digital signature schemes
important properties of hash functions
a security analysis of hash functions, including an introduction to the birthday
paradox
an overview of different families of hash functions
how the popular hash function sha-1 works

c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 11, 

293

294

11 hash functions

11.1 motivation signing long messages
even though hash functions have many applications in modern cryptography, they
are perhaps best known for the important role they play in the practical use of
digital signatures. in the previous chapter, we have introduced signature schemes
based on the asymmetric algorithms rsa and the discrete logarithm problem. for
all schemes, the length of the plaintext is limited. for instance, in the case of rsa,
the message cannot be larger than the modulus, which is in practice often between
1024 and 3072-bits long. remember this translates into only 128384 bytes most
emails are longer than that. thus far, we have ignored the fact that in practice the
plaintext x will often be (much) larger than those sizes. the question that arises at
this point is simple how are we going to efficiently compute signatures of large
messages an intuitive approach would be similar to the ecb mode for block ciphers divide the message x into blocks xi of size less than the allowed input size of
the signature algorithm, and sign each block separately, as depicted in figure 11.1.

x1
k pr

sig
s1

x2
k pr

sig
s2

x3
k pr

...

sig
s3

xn
k pr

...

sig
sn

fig. 11.1 insecure approach to signing of long messages

however, this approach yields three serious problems
problem 1 high computational load digital signatures are based on computationally intensive asymmetric operations such as modular exponentiations of large
integers. even if a single operation consumes a small amount of time (and energy,
which is relevant in mobile applications), the signatures of large messages, e.g.,
email attachments or multimedia files, would take too long on current computers.
furthermore, not only does the signer have to compute the signature, but the verifier
also has to spend a similar amount of time and energy to verify the signature.
problem 2 message overhead obviously, this nave approach doubles the message overhead because not only must the message be sent but also the signature,
which is of the same length in this case. for instance, a 1-mb file must yield an
rsa signature of length 1 mb, so that a total of 2 mb must be transmitted.
problem 3 security limitations this is the most serious problem if we attempt
to sign a long message by signing a sequence of message blocks individually. the
approach shown in fig. 11.1 leads immediately to new attacks for instance, oscar
could remove individual messages and the corresponding signatures, or he could reorder messages and signatures, or he could reassemble new messages and signatures
out of fragments of previous messages and signatures, etc. even though an attacker

11.1 motivation signing long messages

295

cannot perform manipulations within an individual block, we do not have protection
for the whole message.
hence, for performance as well as for security reasons we would like to have one
short signature for a message of arbitrary length. the solution to this problem is
hash functions. if we had a hash function that somehow computes a fingerprint of
the message x, we could perform the signature operation as shown in figure 11.2
x2

x1

x3

...

xn

h
kpr

sig
s

fig. 11.2 signing of long messages with a hash function

assuming we possess such a hash function, we now describe a basic protocol for
a digital signature scheme with a hash function. bob wants to send a digitally signed
message to alice.
basic protocol for digital signatures with a hash function

alice

bob
k pub,b


z  h(x)
s  sigk pr,b (z)
(x,s)


z  h(x)
verk pub,b (s, z )  true/false
bob computes the hash of the message x and signs the hash value z with his
private key k pr,b . on the receiving side, alice computes the hash value z of the
received message x. she verifies the signature s with bobs public key k pub,b . we
note that both the signature generation and the verification operate on the hash value
z rather than on the message itself. hence, the hash value represents the message.
the hash is sometimes referred to as the message digest or the fingerprint of the
message.
before we discuss the security properties of hash functions in the next section,
we can now get a rough feeling for a desirable inputoutput behavior of hash functions we want to be able to apply a hash function to messages x of any size, and

296

11 hash functions

it is thus desirable that the function h is computationally efficient. even if we hash
large messages in the range of, say, hundreds of megabytes, it should be relatively
fast to compute. another desirable property is that the output of a hash function is
of fixed length and independent of the input length. practical hash functions have
output lengths between 128512 bits. finally, the computed fingerprint should be
highly sensitive to all input bits. that means even if we make minor modifications
to the input x, the fingerprint should look very different. this behavior is similar
to that of block ciphers. the properties which we just described are symbolized in
figure 11.3.




         
         
      





  



 "

  





fig. 11.3 principal inputoutput behavior of hash functions

11.2 security requirements of hash functions
as mentioned in the introduction, unlike all other crypto algorithms we have dealt
with so far, hash functions do not have keys. the question is now whether there are
any special properties needed for a hash function to be secure. in fact, we have
to ask ourselves whether hash functions have any impact on the security of an application at all since they do not encrypt and they dont have keys. as is often the
case in cryptography, things can be tricky and there are attacks which use weaknesses of hash functions. it turns out that there are three central properties which
hash functions need to possess in order to be secure
1. preimage resistance (or one-wayness)
2. second preimage resistance (or weak collision resistance)
3. collision resistance (or strong collision resistance)
these three properties are visualized in figure 11.4. they are derived in the following.

11.2 security requirements of hash functions

297







 













  



 
 

    

fig. 11.4 the three security properties of hash functions

11.2.1 preimage resistance or one-wayness
hash functions need to be one-way given a hash output z it must be computationally infeasible to find an input message x such that z  h(x). in other words, given a
fingerprint, we cannot derive a matching message. we demonstrate now why preimage resistance is important by means of a fictive protocol in which bob is encrypting
the message but not the signature, i.e., he transmits the pair
(ek (x), sigk pr,b (z)).
here, ek () is a symmetric cipher, e.g., aes, with some symmetric key shared by
alice and bob. lets assume bob uses an rsa digital signature, where the signature
is computed as
s  sigk pr,b (z)  zd mod n
the attacker oscar can use bobs public key to compute
se  z mod n.
if the hash function is not one-way, oscar can now compute the message x from
h1 (z)  x. thus, the symmetric encryption of x is circumvented by the signature,
which leaks the plaintext. for this reason, h(x) should be a one-way function.
in many other applications which make use of hash functions, for instance in key
derivation, it is even more crucial that they are preimage resistant.

11.2.2 second preimage resistance or weak collision resistance
for digital signatures with hash it is essential that two different messages do not
hash to the same value. this means it should be computationally infeasible to create
two different messages x1  x2 with equal hash values z1  h(x1 )  h(x2 )  z2 .
we differentiate between two different types of such collisions. in the first case, x1

298

11 hash functions

is given and we try to find x2 . this is called second preimage resistance or weak
collision resistance. the second case is given if an attacker is free to choose both
x1 and x2 . this is referred to as strong collision resistance and is dealt with in the
subsequent section.
it is easy to see why second preimage resistance is important for the basic
signature with hash scheme that we introduced above. assume bob hashes and
signs a message x1 . if oscar is capable of finding a second message x2 such that
h(x1 )  h(x2 ), he can run the following substitution attack
alice

oscar

bob
k pub,b


z  h(x1 )
s  sigk pr,b (z)
(x2 ,s)



 substitute

(x1 ,s)



z  h(x2 )
verk pub,b (s, z)  true
as we can see, alice would accept x2 as a correct message since the verification
gives her the statement true. how can this happen from a more abstract viewpoint, this attack is possible because both signing (by bob) and verifying (by alice)
do not happen with the actual message itself, but rather with the hashed version of
it. hence, if an attacker manages to find a second message with the same fingerprint
(i.e., hash output), signing and verifying are the same for this second message.
the question now is how we can prevent oscar from finding x2 . ideally, we would
like to have a hash function for which weak collisions do not exist. this is, unfortunately, impossible due to the pigeonhole principle, a more impressive term for
which is dirichlets drawer principle. the pigeonhole principle uses a counting argument in situations like the following if you are the owner of 100 pigeons but in
your pigeon loop are only 99 holes, at least one pigeonhole will be occupied by 2
birds. since the output of every hash function has a fixed bit length, say n bit, there
are only 2n possible output values. at the same time, the number of inputs to the
hash functions is infinite so that multiple inputs must hash to the same output value.
in practice, each output value is equally likely for a random input, so that weak
collisions exist for all output values.
since weak collisions exist in theory, the next best thing we can do is to assure
that they cannot be found in practice. a strong hash function should be designed
such that given x1 and h(x1 ) it is impossible to construct x2 such that h(x1 )  h(x2 ).
this means there is no analytical attack. however, oscar can always randomly pick
x2 values, compute their hash values and check whether they are equal to h(x1 ). this
is similar to an exhaustive key search for a symmetric cipher. in order to prevent this
attack given todays computers, an output length of n  80 bit is sufficient. however,
we see in the next section that more powerful attacks exist which force us to use even
longer output bit lengths.

11.2 security requirements of hash functions

299

11.2.3 collision resistance and the birthday attack
we call a hash function collision resistant or strong collision resistant if it is computationally infeasible to find two different inputs x1  x2 with h(x1 )  h(x2 ). this
property is harder to achieve than weak collision resistance since an attacker has two
degrees of freedom both messages can be altered to achieve similar hash values.
we show now how oscar could turn his ability to find collisions into an attack. he
starts with two messages, for instance
x1  transfer 10 into oscars account
x2  transfer 10,000 into oscars account
he now alters x1 and x2 at nonvisible locations, e.g., he replaces spaces by tabs,
adds spaces or return signs at the end of the message, etc. this way, the semantics
of the message is unchanged (e.g., for a bank), but the hash value changes for every
version of the message. oscar continues until the condition h(x1 )  h(x2 ) is fulfilled.
note that if an attacker has, e.g., 64 locations that he can alter or not, this yields 264
versions of the same message with 264 different hash values. with the two messages,
he can launch the following attack
alice

oscar

bob
k pub,b


x

1



z  h(x1 )
s  sigk pr,b (z)
(x2 ,s)



 substitute

(x1 ,s)



z  h(x2 )
verk pub,b (s, z)  true
this attack assumes that oscar can trick bob into signing the message x1 . this
is, of course, not possible in every situation, but one can imagine scenarios where
oscar can pose as an innocent party, e.g., an e-commerce vendor on the internet,
and x1 is the purchase order that is generated by oscar.
as we saw earlier, due to the pigeonhole principle, collisions always exist. the
question is how difficult it is to find them. our first guess is probably that this is as
difficult as finding second preimages, i.e., if the hash function has an output length of
80 bits, we have to check about 280 messages. however, it turns out that an attacker
needs only about 240 messages this is a quite surprising result which is due to the
birthday attack. this attack is based on the birthday paradox, which is a powerful
tool that is often used in cryptanalysis.
it turns out that the following real-world question is closely related to finding
collisions for hash functions how many people are needed at a party such that
there is a reasonable chance that at least two people have the same birthday by

300

11 hash functions

birthday we mean any of the 365 days of the year. our intuition might lead us to
assume that we need around 183 people (i.e., about half the number of days in a
year) for a collision to occur. however, it turns out that we need far fewer people.
the piecewise approach to solve this problem is to first compute the probability of
two people not having the same birthday, i.e., having no collision of their birthdays.
for one person, the probability of no collision is 1, which is trivial since a single
birthday cannot collide with anyone elses. for the second person, the probability
of no collision is 364 over 365, since there is only one day, the birthday of the first
person, to collide with


1
p(no collision among 2 people)  1 
365
if a third person joins the party, he or she can collide with both of the people already
there, hence
 


2
1
 1
p(no collision among 3 people)  1 
365
365
consequently, the probability for t people having no birthday collision is given by

 
 

1
2
t 1
p(no collision among t people)  1 
 1
 1
365
365
365
for t  366 people we will have a collision with probability 1 since a year has only
365 days. we return now to our initial question how many people are needed to
have a 50% chance of two colliding birthdays surprisinglyfollowing from the
equations aboveit only requires 23 people to obtain a probability of about 0.5 for
a birthday collision since
p(at least one collision)  1  p(no collision)

 

1
23  1
 1 1
 1
365
365
 0.507  50%.
note that for 40 people the probability is about 90%. due to the surprising outcome
of this gedankenexperiment, it is often referred to as the birthday paradox.
collision search for a hash function h() is exactly the same problem as finding
birthday collisions among party attendees. for a hash function there are not 365
values each element can take but 2n , where n is the output width of h(). in fact, it
turns out that n is the crucial security parameter for hash functions. the question is
how many messages (x1 , x2 , . . . , xt ) does oscar need to hash until he has a reasonable
chance that h(xi )  h(x j ) for some xi and x j that he picked. the probability for no
collisions among t hash values is

11.2 security requirements of hash functions


p(no collision) 

1

301



1
2n

1


t1 
i
  1 n
2
i1

2
2n




 1

t 1
2n



we recall from our calculus courses that the approximation
ex  1  x,
holds1 since i/2n  1. we can approximate the probability as
t1

p(no collision)   e 2n
i

i1

 e

1+2+3++t1
2n

the arithmetic series
1 + 2 +    + t  1  t(t  1)/2,
is in the exponent, which allows us to write the probability approximation as
p(no collision)  e

t(t1)
22n

.

recall that our goal is to find out how many messages (x1 , x2 , . . . , xt ) are needed to
find a collision. hence, we solve the equation now for t. if we denote the probability
of at least one collision by   1  p(no collision), then


t(t1)

  1  e 2n+1
t(t  1)
ln (1   )   n+1
2 
t(t  1)  2

n+1


1
ln
.
1

since in practice t  1, it holds that t 2  t(t  1) and thus



1
t  2n+1 ln
1
 

1
(n+1)/2
t2
ln
.
1

1

(11.1)

this follows from the taylor series representation of the exponential function ex  1  x +
for x  1.

x2 /2  x3 /3 +   

302

11 hash functions

equation (11.1) is extremely important it describes the relationship between the
number of hashed messages t needed for a collision as a function of the hash output
length n and the collision probability  . the most important consequence of the
birthday attack is that the number of messages we need to hash to find a collision is roughly
 equal to the square root of the number of possible output values,
i.e., about 2n  2n/2 . hence, for a security level (cf. section 6.2.4) of x bit, the
hash function needs to have an output length of 2x bit. as an example, assume we
want to find a collision for a hypothetical hash function with 80-bit output. for a
success probability of 50%, we expect to hash about
t  281/2

ln (1/(1  0.5))  240.2

input values. computing around 240 hashes and checking for collisions can be done
with current laptops in order to thwart collision attacks based on the birthday paradox, the output length of a hash function must be about twice as long as an output
length which protects merely against a second preimage attack. for this reason,
all hash functions have an output length of at least 128 bit, where most modern
ones are much longer. table 11.1 shows the number of hash computations needed
for a birthday-paradox collision for output lengths found in current hash functions.
interestingly, the desired likelihood of a collision does not influence the attack complexity very much, as is evidenced by the small difference between the success
probabilities   0.5 and   0.9. it should be stressed that the birthday attack is a
table 11.1 number of hash values needed for a collision for different hash function output lengths
and for two different collision likelihoods


0.5
0.9

hash output length
128 bit 160 bit 256 bit 384 bit 512 bit
265
281
2129
2193
2257
67
82
130
194
2
2
2
2
2258

generic attack. this means it is applicable against any hash function. on the other
hand, it is not guaranteed that it is the most powerful attack available for a given
hash function. as we will see in the next section, for some of the most popular hash
functions, in particular md5 and sha-1, mathematical collision attacks exist which
are faster than the birthday attack.
it should be stressed that there are many applications for hash functions, e.g.,
storage of passwords, which only require preimage resistance. thus, a hash function
with a relatively short output, say 80 bit, might be sufficient since collision attacks
do not pose a threat.
at the end of this section we summarize all important properties of hash functions
h(x). note that the first three are practical requirements, whereas the last three relate
to the security of hash functions.

11.3 overview of hash algorithms

303

properties of hash functions
1. arbitrary message size h(x) can be applied to messages x of any size.
2. fixed output length h(x) produces a hash value z of fixed length.
3. efficiency h(x) is relatively easy to compute.
4. preimage resistance for a given output z, it is impossible to find any
input x such that h(x)  z, i.e, h(x) is one-way.
5. second preimage resistance given x1 , and thus h(x1 ), it is computationally infeasible to find any x2 such that h(x1 )  h(x2 ).
6. collision resistance it is computationally infeasible to find any pairs
x1  x2 such that h(x1 )  h(x2 ).

11.3 overview of hash algorithms
so far we only discussed the requirements for hash functions. we now introduce
how to actually built them. there are two general types of hash functions
1. dedicated hash functions these are algorithms that are specifically designed to
serve as hash functions.
2. block cipher-based hash functions it is also possible to use block ciphers such
as aes to construct hash functions.
as we saw in the previous section, hash functions can process an arbitrary-length
message and produce a fixed-length output. in practice, this is achieved by segmenting the input into a series of blocks of equal size. these blocks are processed sequentially by the hash function, which has a compression function at its heart. this
iterated design is known as merkledamgard construction. the hash value of the
input message is then defined as the output of the last iteration of the compression
function (fig. 11.5).
 


 



fig. 11.5 merkledamgard hash function construction

304

11 hash functions

11.3.1 dedicated hash functions the md4 family
dedicated hash functions are algorithms that have been custom designed. a large
number of such constructions have been proposed over the last two decades. in practice, by far the most popular ones have been the hash functions of what is called the
md4 family. md5, the sha family and ripemd are all based on the principles of
md4. md4 is a message digest algorithm developed by ronald rivest. md4 was
an innovative idea because it was especially designed to allow very efficient software implementation. it uses 32-bit variables, and all operations are bitwise boolean
functions such as logical and, or, xor and negation. all subsequent hash functions in the md4 family are based on the same software-friendly principles.
a strengthened version of md4, named md5, was proposed by rivest in 1991.
both hash functions compute a 128-bit output, i.e., they possess a collision resistance of about 264 . md5 became extremely widely used, e.g., in internet security
protocols, for computing checksums of files or for storing of password hashes. there
were, however, early signs of potential weaknesses. thus, the us nist published a
new message digest standard, which was coined the secure hash algorithm (sha),
in 1993. this is the first member of the sha family and is officially called sha,
even though it is nowadays commonly referred to as sha-0. in 1995, sha-0 was
modified to sha-1. the difference between the sha-0 and sha-1 algorithms lies
in the schedule of the compression function to improve its cryptographic security.
both algorithms have an output length of 160 bit. in 1996, a partial attack against
md5 by hans dobbertin led to more and more experts recommending sha-1 as a
replacement for the widely used md5. since then, sha-1 has gained wide adoption
in numerous products and standards.
in the absence of analytical attacks, the maximum collision resistance of sha0 and sha-1 is about 280 , which is not a good fit if they are used in protocols
together with algorithms such as aes, which has a security level of 128256 bits.
similarly, most public-key schemes can offer higher security levels, for instance,
elliptic curves can have security levels of 128 bits if 256 bits curves are used. thus,
in 2001 nist introduced three more variants of sha-1 sha-256, sha-384 and
sha-512, with message digest lengths of 256, 384 and 512 bits, respectively. a
further modification, sha-224, was introduced in 2004 in order to fit the security
level of 3des. these four hash functions are often referred to as sha-2.
in 2004, collision-finding attacks against md5 and sha-0 where announced by
xiaoyun wang. one year later it was claimed that the attack could be extended to
sha-1 and it was claimed that a collision search would take 263 steps, which is
considerably less than the 280 achieved by the birthday attack. table 11.2 gives an
overview of the main parameters of the md4 family.
in section 11.4 we will learn about the internal functioning of sha-1, which is
to datedespite its potential weaknessthe most widely deployed hash function.
at this point we would like to note that finding a collision does not necessarily
mean that the hash function is insecure in every situation. there are many applications for hash functions, e.g., key derivation or storage of passwords, where only

11.3 overview of hash algorithms

305

table 11.2 the md4 family of hash functions
algorithm
md5
sha-1
sha-224
sha-256
sha-2
sha-384
sha-512

output
[bit]
128
160
224
256
384
512

input
[bit]
512
512
512
512
1024
1024

no. of
rounds
64
80
64
64
80
80

collisions
found
yes
not yet
no
no
no
no

preimage and second preimage resistance are required. for such applications, md5
is still sufficient.

11.3.2 hash functions from block ciphers
hash functions can also be constructed using block cipher chaining techniques. as
in the case of dedicated hash functions like sha-1, we divide the message x into
blocks xi of a fixed size. figure 11.6 shows a construction of such a hash function
the message chunks xi are encrypted with a block cipher e of block size b. as m-bit
key input to the cipher, we use a mapping g from the previous output hi1 , which
is a b-to-m-bit mapping. in the case of b  m, which is, for instance, given if aes
with a 128-bit key is being used, the function g can be the identity mapping. after
the encryption of the message block xi , we xor the result to the original message
block. the last output value computed is the hash of the whole message x1 ,x2 ,. . .,xn ,
i.e., hn  h(x).












fig. 11.6 the matyasmeyeroseas hash function construction from block ciphers

the function can be expressed as
hi  eg(hi1 ) (xi )  xi
this construction, which is named after its inventors, is called the matyasmeyer
oseas hash function.

306

11 hash functions

there exist several other variants of block cipher based realizations of hash functions. two popular ones are shown in figure 11.7.

























fig. 11.7 daviesmeyer (left) and miyaguchipreneel hash function constructions from block
ciphers

the expressions for the two hash functions are
hi  hi1  exi (hi1 )
hi  hi1  xi  eg(hi1 ) (xi )

(daviesmeyer)
(miyaguchipreneel)

all three hash functions need to have initial values assigned to h0 . these can
be public values, e.g., the all-zero vector. all schemes have in common that the bit
size of the hash output is equal to the block width of the cipher used. in situations
where only preimage and second preimage resistance is required, block ciphers like
aes with 128-bit block width can be used, because they provide a security level of
128 bit against those attacks. for application which require collision resistance, the
128-bit length provided by most modern block ciphers is not sufficient. the birthday
attack reduces the security level to mere 64 bit, which is a computational complexity
that is within reach of pc clusters and certainly is doable for attackers with large
budgets.
one solution to this problem is to use rijndael with a block width of 192 or
256 bit. these bit lengths provide a security level of 96 and 128 bit, respectively,
against birthday attacks, which is sufficient for most applications. we recall from
section 4.1 that rijndael is the cipher that became aes but allows block sizes of
128, 192 and 256 bit.
another way of obtaining larger message digests is to use constructions which
are composed of several instances of a block cipher and which yield twice the width
of the block length b. figure 11.8 shows such a construction for the case that a
cipher e is being employed whose key length is twice the block length. this is in
particular the case for aes with a 256-bit key. the message digest output are the
2b bit (hn,l hn,r ). if aes is being used, this output is 2b  256 bit long, which
provides a high level of security against collision attacks. as can be seen from the
figure, the previous output of the left cipher hi1,l is fed back as input to both block

11.4 the secure hash algorithm sha-1

307

ciphers. the concatenation of the previous output of the right cipher, hi1,r , with
the next message block xi , forms the key for both ciphers. for security reasons a
constant c has to be xored to the input of the right block cipher. c can have any
value other than the all-zero vector. as in the other three constructions described
above, initial values have to be assigned to the first hash values (h0,l and h0,r ).


















fig. 11.8 hirose construction for a hash function with twice the block width

we introduce here the hirose construction for the case that the key length be
twice the block width. there are many other ciphers that satisfy this condition in
addition to aes, e.g., the block ciphers blowfish, mars, rc6 and serpent. if a hash
function for resource-constrained applications is needed, the lightweight block cipher present (cf. section 3.7) allows an extremely compact hardware implementation. with a key size of 128-bit and a block size of 64 bit, the construction computes a 128-bit hash output. this message digest size resists preimage and second
preimage attacks, but offers only marginal security against birthday attacks.

11.4 the secure hash algorithm sha-1
the secure hash algorithm (sha-1) is the most widely used message digest function of the md4 family. even though new attacks have been proposed against the
algorithm, it is very instructive to look at its details because the stronger versions
in the sha-2 family show a very similar internal structure. sha-1 is based on a
merkledamgard construction, as can be seen in figure 11.9.
an interesting interpretation of the sha-1 algorithm is that the compression
function works like a block cipher, where the input is the previous hash value hi1
and the key is formed by the message block xi . as we will see below, the actual
rounds of sha-1 are in fact quite similar to a feistel block cipher.
sha-1 produces a 160-bit output of a message with a maximum length of 264 bit.
before the hash computation, the algorithm has to preprocess the message. during
the actual computation, the compression function processes the message in 512-bit

308

11 hash functions
 

 



 




fig. 11.9 high-level diagram of sha-1

chunks. the compression function consists of 80 rounds which are divided into four
stages of 20 rounds each.

11.4.1 preprocessing
before the actual hash computation, the message x has to be padded to fit a size of
a multiple of 512 bit. for the internal processing, the padded message must then be
divided into blocks. also, the initial value h0 is set to a predefined constant.
padding assume that we have a message x with a length of l bit. to obtain an
overall message size of a multiple of 512 bits, we append a single 1 followed
by k zero bits and the binary 64-bit representation of l. consequently, the number
of required zeros k is given by
k  512  64  1  l
 448  (l + 1) mod 512.
figure 11.10 illustrates the padding of a message x.
n 512 bits
l bits

k +1 bits

64 bits

message x

100....0

l

padding

fig. 11.10 padding of a message in sha-1

example 11.1. given is the message abc consisting of three 8-bit ascii characters with a total length of l  24 bits

11.4 the secure hash algorithm sha-1

309

01100001

01100010

01100011 .

a

b

c

we append a 1 followed by k  423 zero bits, where k is determined by
k  448  (l + 1)  448  25  423 mod 512.
finally, we append the 64-bit value which contains the binary representation of
the length l  2410  110002 . the padded message is then given by
01100001

01100010

01100011

a

b

c

1

00...0

00...011000 .

423 zeros

l24


dividing the padded message prior to applying the compression function, we
need to divide the message into 512-bit blocks x1 , x2 , ... , xn . each 512-bit block
can be subdivided into 16 words of size of 32 bits. for instance, the ith block of
the message x is split into
(0) (1)
xi

xi  (xi

(15)

... xi

)

(k)

where xi are words of size of 32 bits.
initial value h0 a 160-bit buffer is used to hold the initial hash value for the first
iteration. the five 32-bit words are fixed and given in hexadecimal notation as
(0)

 67452301

(1)
 h0
(2)
 h0
(3)
 h0
(4)
 h0

 efcdab89

a  h0
b
c
d
e

 98badcfe
 10325476
 c3d2e1f0.

11.4.2 hash computation
each message block xi is processed in four stages with 20 rounds each as shown in
figure 11.11. the algorithm uses


a message schedule which computes a 32-bit word w0 ,w1 , ...,w79 for each of the
80 rounds. the words w j are derived from the 512-bit message block as follows

( j)
xi
0 j15
w j  (w
w
w w )
16 j79,
j16

j14

j8

j3  1

where xn indicates a circular left shift of the word x by n bit positions.

310



11 hash functions

five working registers of size of 32 bits a, b,c, d, e
(0)
(1)
(2)
(3)
(4)
a hash value hi consisting of five 32-bit words hi , hi , hi , hi , hi . in the
beginning, the hash value holds the initial value h0 , which is replaced by a new
hash value after the processing of each single message block. the final hash value
hn is equal to the output h(x) of sha-1.

h i1
160

xi
message
schedule
a

b

c

d

e

2560

w0 ... w19

stage 1 (20 rounds)
f 1 , k 1 , w0...19
a

w20 ... w39

40

... w

d

e

b

c

d

e

stage 3 (20 rounds)
f 3 , k 3 , w40...59

59

a
w60 ... w79

c

stage 2 (20 rounds)
f 2 , k 2 , w20...39
a

w

b

b

c

d

e

stage 4 (20 rounds)
f 4 , k 4 , w60...79

addition mod 2 32

160

hi

fig. 11.11 eighty-round compression function of sha-1

the four sha-1 stages have a similar structure but use different internal functions ft and constants kt , where 1  t  4. each stage is composed of 20 rounds,
where parts of the message block are processed by the function ft together with
some stage-dependent constant kt . the output after 80 rounds is added to the input
value hi1 modulo 232 in word-wise fashion.

11.4 the secure hash algorithm sha-1

311

the operation within round j in stage t is given by
a, b,c, d, e  (e + ft (b,c, d) + (a)5 +w j + kt ), a, (b)30 ,c, d
and is depicted in figure 11.12. the internal functions ft and constants kt change
a

b

c

d

e

ft
 5
 30

wj
kt

a

b

c

d

e

fig. 11.12 round j in stage t of sha-1

depending on the stage according to table 11.3, i.e., every 20 rounds a new function
and a new constant are being used. the function only uses bitwise boolean operations, namely logical and (), or (), not (top bar) and xor. these operation
are applied to 32-bit variables and are very fast to implement on modern pcs.
a sha-1 round as shown in figure 11.12 has some resemblance to the round of
a feistel network. such structures are sometimes referred to as generalized feistel
networks. feistel networks are generally characterized by the fact the first part of
the input is copied directly to the output. the second part of the input is encrypted
using the first part, where the first part is sent through some function, e.g., the f function in the case of des. in the sha-1 round, the inputs a, b, c and d are
passed to the output with no change (a, c, d), or only minimal change (rotation of
b). however, the input word e is encrypted by adding values derived from the
other four input words. the message-derived value wi and the round constant play
the role of subkeys.
table 11.3 round functions and round constants for the sha rounds
stage t
1
2
3
4

round j
0 . . . 19
20 . . . 39
40 . . . 59
60 . . . 79

constant kt
function ft
k1  5a827999
f1 (b,c, d)  (b c)  (b  d)
k2  6ed9eba1
f2 (b,c, d)  b c  d
k3  8f1bbcdc f3 (b,c, d)  (b c)  (b  d)  (c  d)
k4  ca62c1d6
f4 (b,c, d)  b c  d

312

11 hash functions

11.4.3 implementation
sha-1 was designed to be especially amenable to software implementations. each
round requires only bitwise boolean operation with 32-bit registers. somewhat
countering this effect is the large number of rounds. nevertheless, optimized implementations on modern 64-bit microprocessors can achieve throughputs of 1 gbit/sec
or beyond. these are highly optimized assembly code software and typical implementations are most likely considerably slower. generally speaking, one drawback
of sha-1 and other md4 family algorithms is that they are difficult to parallelize. it
is hard to execute many of the boolean operations that constitute a round in parallel.
with respect to hardware, sha-1 is certainly not a truly large algorithm but there
are several factors which cause it to be larger than one might expect. recent hardware implementations on conventional fpgas can reach a few gbit/sec which is
not that groundbreaking compared to pc-based implementations. one reason is that
the function ft depends on the stage number t. another reason is the many registers
that are required to store the 512 bit intermediate results. hence, block ciphers like
aes are typically smaller and faster in hardware. also in some applications, hash
functions built from block ciphers as described in section 11.3.2 are sometimes
desirable for hardware implementations.

11.5 discussion and further reading
md4 family and general remarks it is instructive to have a look at the attack
history of the md4 family. a predecessor of md4 was rivests md2 hash function, which did not appear to become widely used. it is doubtful that the algorithm
would withstand todays attacks. the first attacks against reduced versions of md4
(the first or the last rounds were missing) were developed by boer and bosselaers in
1992 [53]. in 1995, dobbertin showed how collisions for the full md4 can be constructed in less than a minute on conventional pcs [61]. later dobbertin showed that
a variant of md4 (a round was not executed) does not have the one-wayness property. in 1994, boer and bosselaer found collisions in md5 [54]. in 1995, dobbertin
was able to find collisions for the compression function of md5 [62]. in order to
construct a collision for the popular sha-1 algorithm, about 263 computations have
to be executed. this is still a formidable task. in 2007, a distributed hash collision
search over the internet was organized by rechberger at the technical university of
graz in austria. at the time of writing, about two years into the search, no collisions
have been found.
ripemd-160 plays a somewhat special role in the md4 family of hash functions. unlike all sha-1 and sha-2 algorithms, it is the only one that was not
designed by nist and nsa, but rather by a team of european researchers. even
though there is no indication that any of the sha algorithms are artificially weakened or contain backdoors (introduced by the us government, that is), ripemd160 might appeal to some people who heavily distrust governments. currently, no

11.6 lessons learned

313

successful attacks against the hash functions are known. on the other hand, due to
its more limited deployment, there has been less scrutiny by the research community
with respect to ripemd-160.
it is important to point out that in addition to the md4 family, numerous other algorithms have been proposed over the years including, for instance, whirlpool [12],
which is related to aes. most of them did not gain widespread adoption, however.
entirely different from the md4 family are hash functions which are based on algebraic structures such as mash-1 and mash-2 [96]. many of these algorithms
were found to be insecure.
sha-3 due to the serious attacks against sha-1, nist held two public workshops
to assess the status of sha and to solicit public input on its cryptographic hash
function policy and standard. as a consequence, nist decided to develop additional
hash functions, to be named sha-3, through a public competition. this approach
is quite similar to the selection process of aes. in the fall of 2008, 64 algorithms
had been submitted to nist. at the time of writing, 33 of those hash functions are
still in the competition. the final decision is expected in 2012. in the meantime the
sha-2 algorithm, against which no attacks are known to date, appears to be the
safest choice when selecting a hash function.
hash functions from block ciphers the four block cipher based hash functions
introduced in the chapter are all provable secure. this means, the best possible
preimage and second preimage attacks have a complexity of 2b , where b is the message digest length, and the best possible collision attack requires 2b/2 steps. the
security proof only holds if the block cipher is being treated as a black box, i.e,
no (possible) specific weaknesses of the cipher are being exploited. in addition to
the four methods of building hash functions from block ciphers introduced in this
chapter, there are several other constructions [136]. in problem 11.3, 12 variants are
treated in more detail.
the hirose construction is relatively new [92]. it can also be realized with aes
with a 192-bit key and message blocks xi of length 64 bit. however, the efficiency is
roughly half of that of the construction presented in this chapter (aes256 with 128bit message blocks). there are also various other methods to build hash functions
with twice the output size of the block ciphers used. a prominent one is mdc2, which was originally designed for des but works with any block cipher [137].
mdc-2 is standardized in iso/iec 10118-2.

11.6 lessons learned




hash functions are keyless. the two most important applications of hash functions are their use in digital signatures and in message authentication codes such
as hmac.
the three security requirements for hash functions are one-wayness, second
preimage resistance and collision resistance.

314





11 hash functions

hash functions should have at least 160-bit output length in order to withstand
collision attacks 256 bit or more is desirable for long-term security.
md5, which was widely used, is insecure. serious security weaknesses have
been found in sha-1, and the hash function should be phased out. the sha2 algorithms all appear to be secure.
the ongoing sha-3 competition will result in new standardized hash functions
in a few years.

problems

315

problems
11.1. compute the output of the first round of stage 1 of sha-1 for a 512-bit input
block of
1. x  {0...00}
2. x  {0...01} (i.e., bit 512 is one).
ignore the initial hash value h0 for this problem (i.e., a0  b0  ...  00000000hex ).
11.2. one of the earlier applications of cryptographic hash functions was the storage of passwords for user authentication in computer systems. with this method, a
password is hashed after its input and is compared to the stored (hashed) reference
password. people realized early that it is sufficient to only store the hashed versions
of the passwords.
1. assume you are a hacker and you got access to the hashed password list. of
course, you would like to recover the passwords from the list in order to impersonate some of the users. discuss which of the three attacks below allow this.
exactly describe the consequences of each of the attacks




attack a you can break the one-way property of h.
attack b you can find second preimages for h.
attack c you can find collisions for h.

2. why is this technique of storing hashed passwords often extended by the use
of a so-called salt (a salt is a random value appended to the password before
hashing. together with the hash, the value of the salt is stored in the list of hashed
passwords.) are the attacks above affected by this technique
3. is a hash function with an output length of 80 bit sufficient for this application
11.3. draw a block digram for the following hash functions built from a block cipher
e()
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.

e(hi1 , xi )  xi
e(hi1 , xi  hi1 )  xi  hi1
e(hi1 , xi )  xi  hi1
e(hi1 , xi  hi1 )  xi
e(xi , hi1 )  hi1
e(xi , xi  hi1 )  xi  hi1
e(xi , hi1 )  xi  hi1
e(xi , xi  hi1 )  hi1
e(xi  hi1 , xi )  xi
e(xi  hi1 , hi1 )  hi1
e(xi  hi1 , xi )  hi1
e(xi  hi1 , hi1 )  xi

316

11 hash functions

11.4. we define the rate of a block cipher-based hash function as follows a block
cipher-based hash function that processes u input bits at a time, produces v output
bits and performs w block cipher encryptions per input block has a rate of
v/(u  w).
what is the rate of the four block cipher constructions introduced in section 11.3.2
11.5. we consider three different hash functions which produce outputs of lengths
64, 128 and 160 bit. after how many random inputs do we have a probability of
  0.5 for a collision after how many random inputs do we have a probability of
  0.1 for a collision
11.6. describe how exactly you would perform a collision search to find a pair x1 ,
x2 , such that h(x1 )  h(x2 ) for a given hash function h. what are the memory requirements for this type of search if the hash function has an output length of n
bits
11.7. assume the block cipher present (block length 64 bits, 128-bit key) is used
in a hirose hash function construction. the algorithm is used to store the hashes of
passwords in a computer system. for each user i with password pwi , the system
stores
h(pwi )  yi
where the passwords (or passphrases) have an arbitrary length. within the computer
system only the values yi are actually used for identifying users and giving them
access.
unfortunately, the password file that contains all hash values falls into your hands
and you are widely known as a very dangerous hacker. this in itself should not pose
a serious problem as it should be impossible to recover the passwords from the
hashes due to the one-wayness of the hash function. however, you discovered a
small but momentous implementation flaw in the software the constant c in the
hash scheme is assigned the value c  0. assume you also know the initial values
(h0,l and h0,r ).
1. what is the size of each entry yi 
2. assume you want to log in as user u (you might be the ceo of the organization).
provide a detailed description that shows that finding a value pwhack for which
pwhack  yu
takes only about 264 steps.
3. which of the three general attacks against hash functions do you perform
4. why is the attack not possible if c  0
11.8. in this problem, we will examine why techniques that work nicely for error
correction codes are not suited as cryptographic hash functions. we look at a hash
function that computes an 8-bit hash value by applying the following equation

problems

317

ci  bi1  bi2  bi3  bi4  bi5  bi6  bi7  bi8

(11.2)

every block of 8 bits constitutes an ascii-encoded character.
1. encode the string crypto to its binary or hexadecimal representation.
2. calculate the (6-bit long) hash value of the character string using the previously
defined equation.
3. break the hash function by pointing out how it is possible to find (meaningful)
character strings which result in the same hash value. provide an appropriate
example.
4. which cruical property of hash functions is missing in this case

chapter 12

message authentication codes (macs)

a message authentication code (mac), also known as a cryptographic checksum
or a keyed hash function, is widely used in practice. in terms of security functionality, macs share some properties with digital signatures, since they also provide
message integrity and message authentication. however, unlike digital signatures,
macs are symmetric-key schemes and they do not provide nonrepudiation. one
advantage of macs is that they are much faster than digital signatures since they
are based on either block ciphers or hash functions.
in this chapter you will learn




the principle behind macs
the security properties that can be achieved with macs
how macs can be realized with hash functions and with block ciphers

c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 12, 

319

320

12 message authentication codes (macs)

12.1 principles of message authentication codes
similar to digital signatures, macs append an authentication tag to a message. the
crucial difference between macs and digital signatures is that macs use a symmetric key k for both generating the authentication tag and verifying it. a mac is a
function of the symmetric key k and the message x. we will use the notation
m  mack (x)
for this in the following. the principle of the mac calculation and verification is
shown in figure 12.1.
alice

bob

x
mac

k

m
( x, m)

x
k

mac
m
verification


m  m

fig. 12.1 principle of message authentication codes (macs)

the motivation for using macs is typically that alice and bob want to be assured
that any manipulations of a message x in transit are detected. for this, bob computes
the mac as a function of the message and the shared secret key k. he sends both
the message and the authentication tag m to alice. upon receiving the message
and m, alice verifies both. since this is a symmetric set-up, she simply repeats the
steps that bob conducted when sending the message she merely recomputes the
authentication tag with the received message and the symmetric key.
the underlying assumption of this system is that the mac computation will yield
an incorrect result if the message x was altered in transit. hence, message integrity is
provided as a security service. furthermore, alice is now assured that bob was the
originator of the message since only the two parties with the same secret key k have
the possibility to compute the mac. if an adversary, oscar, changes the message
during transmission, he cannot simply compute a valid mac since he lacks the
secret key. any malicious or accidental (e.g., due to transmission errors) forgery of
the message will be detected by the receiver due to a failed verification of the mac.

12.2 macs from hash functions hmac

321

that means, from alices perspective, bob must have generated the mac. in terms
of security services, message authentication is provided.
in practice, a messages x is often much larger than the corresponding mac.
hence, similar to hash functions, the output of a mac computation is a fixed-length
authentication tag which is independent of the length of the input.
together with earlier discussed characteristics of macs, we can summarize all
their important properties
properties of message authentication codes
1. cryptographic checksum a mac generates a cryptographically secure
authentication tag for a given message.
2. symmetric macs are based on secret symmetric keys. the signing and
verifying parties must share a secret key.
3. arbitrary message size macs accept messages of arbitrary length.
4. fixed output length macs generate fixed-size authentication tags.
5. message integrity macs provide message integrity any manipulations
of a message during transit will be detected by the receiver.
6. message authentication the receiving party is assured of the origin of
the message.
7. no nonrepudiation since macs are based on symmetric principles,
they do not provide nonrepudiation.
the last point is important to keep in mind macs do not provide nonrepudiation. since the two communicating parties share the same key, there is no possibility
to prove towards a neutral third party, e.g., a judge, whether a message and its mac
originated from alice or bob. thus, macs offer no protection in scenarios where
either alice or bob is dishonest, like the car-buying example we described in section 10.1.1. a symmetric secret key is not tied to a certain person but rather to two
parties, and hence a judge cannot distinguish between alice and bob in case of a
dispute.
in practice, message authentication codes are constructed in essentially two different ways from block ciphers or from hash functions. in the subsequent sections
of this chapter we will introduce both options for realizing macs.

12.2 macs from hash functions hmac
an option for realizing macs is to use cryptographic hash functions such as sha1 as a building block. one possible construction, named hmac, has become very
popular in practice over the last decade. for instance, it is used in both the transport
layer security (tls) protocol (indicated by the little lock symbol in your web
browser) as well as in the ipsec protocol suite. one reason for the widespread use of

322

12 message authentication codes (macs)

the hmac construction is that it can be proven to be secure if certain assumptions
are made.
the basic idea behind all hash-based message authentication codes is that the key
is hashed together with the message. two obvious constructions are possible. the
first one
m  mack (x)  h(kx)
is called secret prefix mac, and the second one
m  mack (x)  h(xk)
is known as secret suffix mac. the symbol  denotes concatenation. intuitively,
due to the one-wayness and the good scrambling properties of modern hash functions, both approaches should result in strong cryptographic checksums. however,
as is often the case in cryptography, assessing the security of a scheme can be trickier
than it seems at first glance. we now demonstrate weaknesses in both constructions.

attacks against secret prefix macs
we consider macs realized as m  h(kx). for the attack we assume that the
cryptographic checksum m is computed using a hash construction as shown in figure 11.5. this iterated approach is used in the majority of todays hash functions.
the message x that bob wants to sign is a sequence of blocks x  (x1 , x2 , . . . , xn ),
where the block length matches the input width of the hash function. bob computes
an authentication tag as
m  mack (x)  h(kx1 , x2 , . . . , xn )
the problem is that the mac for the message x  (x1 , x2 , . . . , xn , xn+1 ), where xn+1
is an arbitrary additional block, can be constructed from m without knowing the
secret key. the attack is shown in the protocol below.

12.2 macs from hash functions hmac

323

attack against secret prefix macs
alice

oscar

bob
x  (x1 , . . . , xn )
m  h(kx1 , . . . , xn )
(x,m)



 intercept

xo
(x1 , . . . , xn , xn+1 )
mo  h(mxn+1 )



(xo ,mo )


m

h(kx1 , . . . , xn , xn+1 )
since m  mo
 valid signature

note that alice will accept the message (x1 , . . . , xn , xn+1 ) as valid, even though
bob only authenticated (x1 , . . . , xn ). the last block xn+1 could, for instance, be an
appendix to an electronic contract, a situation that could have serious consequences.
the attack is possible since the mac of the additional message block only needs
the previous hash output, which is equal to bobs m, and xn+1 as input but not the
key k.

attacks against secret suffix macs
after studying the attack above, it seems to be safe to use the other basic construction method, namely m  h(xk). however, a different weakness occurs here.
assume oscar is capable of constructing a collision in the hash function, i.e., he can
find x and xo such that
h(x)  h(xo ).
the two messages x and xo can be, for instance, two versions of a contract which
are different in some crucial aspect, e.g., the agreed upon payment. if bob signs x
with a message authentication code
m  h(xk)
m is also a valid checksum for xo , i.e.,
m  h(xk)  h(xo k)
the reason for this is again given by the iterative nature of the mac computation.
whether this attack presents oscar with an advantage depends on the parameters
used in the construction. as a practical example, lets consider a secret suffix mac
which uses sha-1 as hash function, which has an output length of 160 bits, and
a 128-bit key. one would expect that this hash offers a security level of 128 bits,

324

12 message authentication codes (macs)

i.e., an attacker cannot do better than brute-forcing the entire key space to forge a
message. however, if an attacker exploits
the birthday paradox (cf. section 11.2.3),

he can forge a signature with about 2160  280 computations. there are indications
that sha-1 collisions can be constructed with even fewer steps, so that an actual
attack might be even easier. in summary, we conclude that the secret suffix method
also does not provide the security one would like to have from a mac construction.

hmac
a hash-based message authentication code which does not show the security weakness described above is the hmac construction proposed by mihir bellare, ran
canetti and hugo krawczyk in 1996. the scheme consists of an inner and outer
hash and is visualized in figure 12.2.
















  













 

fig. 12.2 hmac construction

the mac computation starts with expanding the symmetric key k with zeros on
the left such that the result k+ is b bits in length, where b is the input block width of
the hash function. the expanded key is xored with the inner pad, which consists
of the repetition of the bit pattern

12.3 macs from block ciphers cbc-mac

325

ipad  0011 0110, 0011 0110, . . . , 0011 0110
so that a length of b bit is achieved. the output of the xor forms the first input
block to the hash function. the subsequent input blocks are the message blocks
(x1 , x2 , . . . , xn ).
the second, outer hash is computed with the padded key together with the output
of the first hash. here, the key is again expanded with zeros and then xored with
the outer pad
opad  0101 1100, 0101 1100, . . . , 0101 1100.
the result of the xor operation forms the first input block for the outer hash. the
other input is the output of the inner hash. after the outer hash has been computed,
its output is the message authentication code of x. the hmac construction can be
expressed as



hmack (x)  h (k+  opad)h (k+  ipad)x .
the hash output length l is in practice longer than the width b of an input block.
for instance, sha-1 has an l  160 bit output but accepts b  512 bit inputs. it
does not pose a problem that the inner hash function output does not match the
input size of outer hash because hash functions have preprocessing steps to match
the input string to the block width. as an example, section 11.4.1 described the
preprocessing for sha-1.
in terms of computational efficiency, it should be noted that the message x, which
can be very long, is only hashed once in the inner hash function. the outer hash
consists of merely two blocks, namely the padded key and the inner hash output.
thus, the computational overhead introduced through the hmac construction is
very low.
in addition to its computational efficiency, a major advantage of the hmac construction is that there exists a proof of security. as for all schemes which are provable secure, hmac is not secure per se, but its security is related to the security of
some other building block. in the case of the hmac construction it can be shown
that if an attacker, oscar, can break the hmac, he can also break the hash function
used in the scheme. breaking hmac means that even though oscar does not know
the key, he can construct valid authentication tags for messages. breaking the hash
function means that he can either find collisions or that he can compute a hash function output even though he does not know the initial value iv (which was the value
h0 in the case of sha-1).

12.3 macs from block ciphers cbc-mac
in the preceding section we saw that hash functions can be used to realize macs.
an alternative method is to construct macs from block ciphers. the most popular

326

12 message authentication codes (macs)

approach in practice is to use a block cipher such as aes in cipher block chaining
(cbc) mode, as discussed in section 5.1.2.
figure 12.3 depicts the complete setting for the application of a mac on basis
of a block cipher in cbc mode. the left side shows the sender, the right side the
receiver. this scheme is also referred to as cbc-mac.













 



fig. 12.3 mac built from a block cipher in cbc mode

mac generation
for the generation of a mac, we have to divide the message x into blocks xi , i 
1, ..., n. with the secret key k and an initial value iv, we can compute the first iteration of the mac algorithm as
y1  ek (x1  iv ),
where the iv can be a public but random value. for subsequent message blocks we
use the xor of the block xi and the previous output yi1 as input to the encryption
algorithm
yi  ek (xi  yi1 ).
finally, the mac of the message x  x1 x2 x3 ...xn is the output yn of the last round
m  mack (x)  yn
in contrast to cbc encryption, the values y1 , y2 , y3 , . . . , yn1 are not transmitted.
they are merely internal values which are used for computing the final mac value
m  yn .

mac verification
as with every mac, verification involves simply repeating the operation that were
used for the mac generation. for the actual verification decision we have to com-

12.5 discussion and further reading

327

pare the computed mac m with the received mac value m. in case m  m, the
message is verified as correct. in case m  m, the message and/or the mac value
m have been altered during transmission. we note that the mac verification is different from cbc decryption, which actually reverses the encryption operation.
the output length of the mac is determined by the block size of the cipher used.
historically, des was widely used, e.g., for banking applications. more recently,
aes is often used it yields a mac of length 128 bit.

12.4 galois counter message authentication code (gmac)
gmac is a variant of the galois counter mode (gcm) introduced in section 5.1.6.
gmac is specified in [160] and is a mode of operation for an underlying symmetric key block cipher. in contrast to the gcm mode, gmac does not encrypt data
but only computes a message authentication code. gmac is easily parallelizable,
which is attractive for high-speed applications. the use of gmac in ipsec encapsulating security payload (esp) and authentication header (ah) is described in
the rfc 4543 [119]. the rfc describes how to use aes in gmac to provide data
origin authentication without confidentiality within the ipsec esp and ah. gmac
can be efficiently implemented in hardware and can reach a speed of 10 gbit/sec
and above.

12.5 discussion and further reading
block cipher-based macs historically, block cipher-based macs have been the
dominant method for constructing message authentication codes. as early as in
1977, i.e., only a couple of years after the announcement of the data encryption
standard (des), it was suggested that des could be used to compute cryptographic
checksums [39]. in the following years, block cipher-based macs were standardized in the us and became popular for assuring the integrity of financial transactions, see, e.g., the ansi x9.17 standard [3]. much more recently, the nist recommendation [65] specifies a message authentication code algorithm based on a symmetric key block cipher (cmac), which is similar to cbc-mac. the aes-cmac
algorithm is specified in rfc 4493 [159].
in this chapter the cbc-mac was introduced. in addition to the cbc-mac,
there are the omac and pmac, which are both constructed with block ciphers.
counter with cbc-mac (ccm) is a mode for authenticated encryption and is defined for use with a 128-bit block cipher [173]. it is described in the nist recommendation [64]. the gmac construction is standardized in ipsec [119] and in the
nist recommendation for block cipher modes of operation [66].

328

12 message authentication codes (macs)

hash function-based macs the hmac construction was originally proposed at
the crypto 1996 conference [14]. a very accessible treatment of the scheme can be
found in [15]. hmac was turned into an internet rfc, and was quickly adopted in
many internet security protocols, including tls and ipsec. in both cases it protects
the integrity of a message during transmission. it is widely used with the hash functions sha-1 and md5, and its use with ripemd-160 has also been often discussed.
it seems likely that the switch to more modern hash functions such as sha-2 and
sha-3 will result in more and more hmac constructions with these hash functions.
other mac constructions another type of message authentication code is based
on universal hashing and is called umac. umac is backed by a formal security
analysis, and the only internal cryptographic component is a block cipher used to
generate the pseudorandom pads and internal key material. the universal hash function is used to produce a short hash value of fixed length. this hash is then xored
with a key-derived pseudorandom pad. the universal hash function is designed to be
very fast in software (e.g., as low as one cycle per byte on contemporary processors)
and is mainly based on additions of 32-bit and 64-bit numbers and multiplication
of 32-bit numbers. based on the original idea by wegman and carter [40], numerous schemes have been proposed, e.g., the schemes multilinear-modular-hashing
(mmh) and umac [89, 23].

12.6 lessons learned






macs provide two security services, message integrity and message authentication, using symmetric techniques. macs are widely used in protocols.
both of these services are also provided by digital signatures, but macs are
much faster.
macs do not provide nonrepudiation.
in practice, macs are either based on block ciphers or on hash functions.
hmac is a popular mac used in many practical protocols such as tls.

problems

329

problems
12.1. as we have seen, macs can be used to authenticate messages. with this problem, we want to show the difference between two protocolsone with a mac, one
with a digital signature. in the two protocols, the sending party performs the following operation
1. protocol a
y  ek1 [xh(k2 x)]
where x is the message, h() is a hash function such as sha-1, e is a private-key
encryption algorithm,  denotes simple concatenation, and k1 , k2 are secret
keys which are only known to the sender and the receiver.
2. protocol b
y  ek [xsigk pr (h(x))]
provide a step-by-step description (e.g., with an itemized list) of what the receiver
does upon receipt of y. you may want to draw a block diagram for the process on
the receivers side, but thats optional.
12.2. for hash functions it is crucial to have a sufficiently large number of output
bits, with, e.g., 160 bits, in order to thwart attacks based on the birthday paradox.
why are much shorter output lengths of, e.g., 80 bits, sufficient for macs
for your answer, assume a message x that is sent in clear together with its mac
over the channel (x, mack (x)). exactly clarify what oscar has to do to attack this
system.
12.3. we study two methods for integrity protection with encryption.
1. assume we apply a technique for combined encryption and integrity protection
in which a ciphertext c is computed as
c  ek (xh(x))
where h() is a hash function. this technique is not suited for encryption with
stream ciphers if the attacker knows the whole plaintext x. explain exactly how
an active attacker can now replace x by an arbitrary x of his/her choosing and
compute c such that the receiver will verify the message correctly. assume that
x and x are of equal length. will this attack work too if the encryption is done
with a one-time pad
2. is the attack still applicable if the checksum is computed using a keyed hash
function such as a mac
c  ek1 (xmack2 (x))
assume that e() is a stream cipher as above.
12.4. we will now discuss some issues when constructing an efficient mac.

330

12 message authentication codes (macs)

1. the messages x to be authenticated consists of z independent blocks, so that
x  x1 x2  . . . xz , where every xi consists of xi   8 bits. the input blocks are
consecutively put into the compression function
ci  h(ci1 , xi )  ci1  xi
at the end, the mac value
mack (x)  cz + k mod 28
is calculated, where k is a 64-bit long shared key. describe how exactly the (effective part of the) key k can be calculated with only one known message x.
2. perform this attack for the following parameters and determine the key k
x  hello alice
c0  111111112
mack (x)  100111012
3. what is the effective key length of k
4. although two different operations ([, 28 ] and [+, 28 ]) are utilized in this mac,
this mac-based signature possesses significant weaknesses. to which property
of the design can these be ascribed, and where should one take care when constructing a cryptographic system this essential property also applies for block
ciphers and hash functions
12.5. macs are, in principle, also vulnerable against collision attacks. we discuss
the issue in the following.
1. assume oscar found a collision between two messages, i.e.,
mack (x1 )  mack (x2 )
show a simple protocol with an attack that is based on a collision.
2. even though the birthday paradox can still be used for constructing collisions,
why is it in a practical setting much harder to construct them for macs than for
hash functions since this is the case what security is provided by a mac with
80-bit output compared to a hash function with 80-bit output

chapter 13

key establishment

with the cryptographic mechanisms that we have learned so far, in particular symmetric and asymmetric encryption, digital signatures and message authentication
codes (macs), one can relatively easily achieve the basic security services (cf.
sect. 10.1.3)





confidentiality (with encryption algorithms)
integrity (with macs or digital signatures)
message authentication (with macs or digital signatures)
non-repudiation (with digital signatures)

similarly, identification can be accomplished through protocols which make use of
standard cryptographic primitives.
however, all cryptographic mechanisms that we have introduced so far assume
that keys are properly distributed between the parties involved, e.g., between alice
and bob. the task of key establishment is in practice one of the most important and
often also most difficult parts of a security system. we already learned some ways
of distributing keys, in particular diffiehellman key exchange. in this chapter we
will learn many more methods for establishing keys between remote parties. you
will learn about the following important issues






how keys can be established using symmetric cryptosystems
how keys can be established using public-key cryptosystems
why public-key techniques still have shortcomings for key distribution
what certificates are and how they are used
the role that public-key infrastructures play

c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3 13, 

331

332

13 key establishment

13.1 introduction
in this section we introduce some terminology, some thoughts on key freshness and
a very basic key distribution scheme. the latter is helpful for motivating the more
advanced methods which will follow in this chapter.

13.1.1 some terminology
roughly speaking, key establishment deals with establishing a shared secret between two or more parties. methods for this can be classified into key transport and
key agreement methods, as shown in fig. 13.1. a key transport protocol is a technique where one party securely transfers a secret value to others. in a key agreement
protocol two (or more) parties derive the shared secret where all parties contribute
to the secret. ideally, none of the parties can control what the final joint value will
be.
  





   
   

 
     
 

fig. 13.1 classification of key establishment schemes

key establishment itself is strongly related to identification. for instance, you
may think of attacks by unauthorized users who join the key establishment protocol
with the aim of masquerading as either alice or bob with the goal of establishing a
secret key with the other party. to prevent such attacks, each party must be assured
of the identity of the other entity. all of these issues are addressed in this chapter.

13.1.2 key freshness and key derivation
in many (but not all) security systems it is desirable to use cryptographic keys which
are only valid for a limited time, e.g., for one internet connection. such keys are
called session keys or ephemeral keys. limiting the period in which a cryptographic
key is used has several advantages. a major one is that there is less damage if the

13.1 introduction

333

key is exposed. also, an attacker has less ciphertext available that was generated under one key, which can make cryptographic attacks much more difficult. moreover,
an attacker is forced to recover several keys if he is interested in decrypting larger
parts of plaintext. real-world examples where session keys are frequently generated include voice encryption in gsm cell phones and video encryption in pay-tv
satellite systems in both cases new keys are generated within a matter of minutes
or sometimes even seconds.
the security advantages of key freshness are fairly obvious. however, the question now is, how can key updates be realized the first approach is to simply execute
the key establishment protocols shown in this chapter over and over again. however,
as we see later, there are always certain costs associated with key establishment, typically with respect to additional communication connections and computations. the
latter holds especially in the case of public-key algorithms which are very computationally intensive.
the second approach to key update uses an already established joint secret key
to derive fresh session keys. the principal idea is to use a key derivation function
(kdf) as shown in fig. 13.2. typically, a non-secret parameter r is processed together with the joint secret kab between the users alice and bob.




 
 



fig. 13.2 principle of key derivation

an important characteristic of the key derivation function is that it should be a
one-way function. the one-way property prevents an attacker from deducing kab
should any of the session keys become compromised, which in turn would allow the
attacker to compute all other session keys.
one possible way of realizing the key derivation function is that one party sends
a nonce, i.e., a numerical value that is used only once, to the other party. both users
encrypt the nonce using the shared secret key kab by means of a symmetric cipher
such as aes. the corresponding protocol is shown below.

334

13 key establishment

key derivation with nonces
alice

bob
generate nonce r
r


derive key
kses  ekab (r)

derive key
kses  ekab (r)

an alternative to encrypting the nonce is hashing it together with kab . one way
of achieving this is that both parties perform a hmac computation with the nonce
serving as the message
kses  hmackab (r)
rather than sending a nonce, alice and bob can also simply encrypt a counter
cnt periodically, where the ciphertext again forms the session key
kses  ekab (cnt)
or compute the hmac of the counter
kses  hmackab (cnt)
using a counter can save alice and bob one communication session because, unlike
the case of the nonce-based key derivation, no value needs to be transmitted. however, this holds only if both parties know exactly when the next key derivation needs
to take place. otherwise, a counter synchronization message might be required.

13.1.3 the n2 key distribution problem
until now we mainly assumed that the necessary keys for symmetric algorithms
are distributed via a secure channel, as depicted in the beginning of this book in
fig. 1.5. distributing keys this way is sometimes referred to as key predistribution
or out-of-band transmission since it typically involves a different mode (or band)
of communication, e.g., the key is transmitted via a phone line or in a letter. even
though this seems somewhat clumsy, it can be a useful approach in certain practical
situations, especially if the number of communicating parties is not too large. however, key predistribution quickly reaches its limits even if the number of entities in a
network is only moderately large. this leads to the well-known n2 key distribution
problem.
we assume a network with n users, where every party is capable of communicating with every other one in a secure fashion, i.e., if alice wants to communicate
with bob, these two share a secret key kab which is only known to them but not to

13.1 introduction

335

any of the other n  2 parties. this situation is shown for the case of a network with
n  4 participants in fig. 13.3.




















fig. 13.3 keys in a network with n  4 users

we can extrapolate several features of this simple scheme for the case of n users





each user must store n  1 keys.
there is a total of n(n 1) n2 keys in the network.
a total of n(n  1)/2  n2 symmetric key pairs are in the network.
if a new user joins the network, a secure channel must be established with every
other user in order to upload new keys.

the consequences of these observations are not very favorable if the number
of users increases. the first drawback is that the number of keys in the system is
roughly n2 . even for moderately sized networks, this number becomes quite large.
all these keys must be generated securely at one location, which is typically some
type of trusted authority. the other drawback, which is often more serious in practice, is that adding one new user to the system requires updating the keys at all
existing users. since each update requires a secure channel, this is very burdensome.
example 13.1. a mid-size company with 750 employees wants to set up secure email communication with symmetric keys. for this purpose, 750749/2  280, 875
symmetric key pairs must be generated, and 750  749  561, 750 keys must be distributed via secure channels. moreover, if employee number 751 joins the company,
all 750 other users must receive a key update. this means that 751 secure channels
(to the 750 existing employees and to the new one) must be established.

obviously, this approach does not work for large networks. however, there are
many cases in practice where the number of users is (i) small and (ii) does not
change frequently. an example could be a company with a small number of branches
which all need to communicate with each other securely. adding a new branch does
not happen too often, and if this happens it can be tolerated that one new key is
uploaded to any of the existing branches.

336

13 key establishment

13.2 key establishment using symmetric-key techniques
symmetric ciphers can be used to establish secret (session) keys. this is somewhat
surprising because we assumed for most of the book that symmetric ciphers themselves need a secure channel for establishing their keys. however, it turns out that it
is in many cases sufficient to have a secure channel only when a new user joins the
network. this is in practice often achievable for computer networks because at setup time a (trusted) system administrator might be needed in person anyway who can
install a secret key manually. in the case of embedded devices, such as cell phones,
a secure channel is often given during manufacture, i.e., a secret key can be loaded
into the device in the factory.
the protocols introduced in the following all perform key transport and not key
agreement.

13.2.1 key establishment with a key distribution center
the protocols developed in the following rely on a key distribution center (kdc).
this is a server that is fully trusted by all users and that shares a secret key with each
user. this key, which is named the key encryption key (kek), is used to securely
transmit session keys to users.

basic protocol
a necessary prerequisite is that each user u shares a unique secret key kek ku
with the key distribution center which predistributed through a secure channel. lets
look what happens if one party requests a secure session from the kdc, e.g., alice
wants to communicate with bob. the interesting part of this approach is that the
kdc encrypts the session key that will eventually be used by alice and bob. in
a basic protocol, the kdc generates two messages, ya and yb , for alice and bob,
respectively
ya  eka (kses )
yb  ekb (kses )
each message contains the session key encrypted with one of the two keks. the
protocol looks like this

13.2 key establishment using symmetric-key techniques

337

basic key establishment using a key distribution center
alice
kek ka

kdc
kek ka , kb

bob
kek kb

rqst(ida ,idb )


generate random kses
ya  eka (kses )
yb  ekb (kses )
y
y
a
b
kses  e1
ka (ya )

y  ekses (x)

kses  e1
kb (yb )
y



x  e1
kses (y)

the protocol begins with a request message rqst(ida , idb ), where ida and
idb simply indicate the users involved in the session. the actual key establishment
protocol is executed subsequently in the upper part of the drawing. below the solid
line is, as an example, shown how alice and bob can now communicate with each
other securely using the session key.
it is important to note that two types of keys are involved in the protocol. the
keks ka and kb are long-term keys that do not change. the session key kses is an
ephemeral key that changes frequently, ideally for every communication session.
in order to understand this protocol more intuitively, one can view the predistributed keks as forming a secret channel between the kdc and each user.
with this interpretation, the protocol is straightforward the kdc simply sends a
session key to alice and bob via the two respective secret channels.
since the keks are long-term keys, whereas the session keys have typically a
much shorter lifetime, in practice sometimes different encryption algorithms are
used with both. lets consider the following example. in a pay-tv system aes
might be used with the long-term keks ku for distributing session keys kses . the
session keys might only have a lifetime of, say, one minute. the session keys are
used to encrypt the actual plaintext (the digital tv signal in this example) with a fast
stream cipher. a stream cipher might be required to assure real-time decryption. the
advantage of this arrangement is that even if a session key becomes compromised,
only one minutes worth of multimedia data can be decrypted by an adversary. thus,
the cipher that is used with the session key does not necessarily need to have the
same cryptographic strength as the algorithm which is used for distributing the session keys. on the other hand, if one of the keks becomes compromised, all prior
and future traffic can be decrypted by an eavesdropper.
it is easy to modify the above protocol such that we save one communication
session. this is shown in the following

338

13 key establishment

key establishment using a key distribution center
alice
kek ka

kdc
kek ka , kb

bob
kek kb

rqst(ida ,idb )


generate random kses
ya  eka (kses )
yb  ekb (kses )
y ,yb
a

kses  e1
ka (ya )
y  ekses (x)

y, y

b



kses  e1
kb (yb )
x  e1
kses (y)

alice receives the session key encrypted with both keks, ka and kb . she is able
to compute the session key kses from ya and can use it subsequently to encrypt the
actual message she wants to send to bob. the interesting part of the protocol is that
bob receives both the encrypted message y as well as yb . he needs to decrypt the
latter one in order to recover the session key which is needed for computing x.
both of the kdc-based protocols have the advantage that there are only n longterm symmetric key pairs in the system, unlike the first nave scheme that we encountered, where about n2 /2 key pairs were required. the n long-term keks only
need to be stored by the kdc, while each user only stores his or her own kek. most
importantly, if a new user noah joins the network, a secure channel only needs to
be established once between the kdc and noah to distribute the kek kn .

security
even though the two protocols protect against a passive attacker, i.e, an adversary
that can only eavesdrop, there are attacks if an adversary can actively manipulate
messages and create faked ones.
replay attack one weakness is that a replay attack is possible. this attack makes
use of the fact that neither alice nor bob know whether the encrypted session key
they receive is actually a new one. if an old one is reused, key freshness is violated.
this can be a particularly serious issue if an old session key has become compromised. this could happen if an old key is leaked, e.g., through a hacker, or if the
encryption algorithm used with an old key has become insecure due to cryptanalytical advances.
if oscar gets hold of a previous session key, he can impersonate the kdc and
resend old messages ya and yb to alice and bob. since oscar knows the session
key, he can decipher the plaintext that will be encrypted by alice or bob.

13.2 key establishment using symmetric-key techniques

339

key confirmation attack another weakness of the above protocol is that alice
is not assured that the key material she receives from the kdc is actually for a
session between her and bob. this attack assumes that oscar is also a legitimate
(but malicious) user. by changing the session-request message oscar can trick the
kdc and alice to set up session between him and alice as opposed to between
alice and bob. here is the attack
key confirmation attack
alice
kek ka

oscar
kek ko

kdc
kek ka , kb , ko

bob
kek kb

rqst(ida ,idb )


 substitute
rqst(id ,id )
ao
random kses
ya  eka (kses )
yo  eko (kses )
y ,y

ao
kses  e1
ka (ya )
y  ekses (x)

y, y

o
 intercept
kses  e1
ko (yo )
x  e1
kses (y)

the gist of the attack is that the kdc believes alice requests a key for a session
between alice and oscar, whereas she really wants to communicate with bob. alice
assumes that the encrypted key yo  is yb , i.e., the session key encrypted under
bobs kek kb . (note that if the kdc puts a header ido in front of yo which associates it with oscar, oscar might simply change the header to idb .) in other words,
alice has no way of knowing that the kdc prepared a session with her and oscar
instead she still thinks she is setting up a session with bob. alice continues with the
protocol and encrypts her actual message as y. if oscar intercepts y, he can decrypt
it.
the underlying problem for this attack is that there is no key confirmation. if key
confirmation were given, alice would be assured that bob and no other user knows
the session key.

13.2.2 kerberos
a more advanced protocol that protects against both replay and key confirmation
attacks is kerberos. it is, in fact, more than a mere key distribution protocol its
main purpose is to provide user authentication in computer networks. kerberos was
standardized as an rfc 1510 in 1993 and is in widespread use. it is also based on

340

13 key establishment

a kdc, which is named the authentication sever in kerberos terminology. lets
first look at a simplified version of the protocol.
key establishment using a simplified version of kerberos
alice
kek ka
generate nonce ra

kdc
kek ka , kb

bob
kek kb

rqst(ida ,idb ,ra )


generate random kses
generate lifetime t
ya  eka (kses , ra , t, idb )
yb  ekb (kses , ida , t )
ya ,yb

kses , ra , t, idb  e1
ka (ya )
verify ra  ra
verify idb
verify lifetime t
generate time stamp ts
yab  ekses (ida , ts )

y

,y

ab
b
kses , ida , t  e1
kb (yb )
ida , ts  e1
kses (yab )
verify ida   ida
verify lifetime t
verify time stamp ts
y  ekses (x)

y



x  e1
kses (y)

kerberos assures the timeliness of the protocol through two measures. first, the
kdc specifies a lifetime t for the session key. the lifetime is encrypted with both
session keys, i.e., it is included in ya and yb . hence, both alice and bob are aware
of the period during which they can use the session key. second, alice uses a time
stamp ts , through which bob can be assured that alices messages are recent and
are not the result of a replay attack. for this, alices and bobs system clocks must
be synchronized, but not with a very high accuracy. typical values are in the range
of a few minutes. the usage of the lifetime parameter t and the time stamp ts
prevent replay attacks by oscar.
equally important is that kerberos provides key confirmation and user authentication. in the beginning, alice sends a random nonce ra to the kdc. this can be
considered as a challenge because she challenges the kdc to encrypt it with their
joint kek ka . if the returned challenge ra matches the sent one, alice is assured that
the message ya was actually sent by the kdc. this method to authenticate users is
known as challenge-response protocol and is widely used, e.g., for authentication of
smart cards.
through the inclusion of bobs identity idb in ya alice is assured that the session
key is actually meant for a session between herself and bob. with the inclusion of
alices identity ida in both yb and yab , bob can verify that (i) the kdc included
a session key for a connection between him and alice and (ii) that he is currently
actually talking to alice.

13.2 key establishment using symmetric-key techniques

341

13.2.3 remaining problems with symmetric-key distribution
even though kerberos provides strong assurance that the correct keys are being
used and that users are authenticated, there are still drawbacks to the protocols discussed so far. we now describe remaining general problems that exist for kdcbased schemes.
communication requirements one problem in practice is that the kdc needs to
be contacted if a new secure session is to be initiated between any two parties in the
network. even though this is a performance rather than a security problem, it can be
a serious hindrance in a system with very many users. in kerberos, one can alleviate
this potential problem by increasing the lifetime t of the key. in practice, kerberos
can run with tens of thousands of users. however, it would be a problem to scale
such an approach to all internet users.
secure channel during initialization as discussed earlier, all kdc-based protocols require a secure channel at the time a new user joins the network for transmitting that users key encryption key.
single point of failure all kdc-based protocols, including kerberos, have the
security drawback that they have a single point of failure, namely the database that
contains the key encryption keys, the keks. if the kdc becomes compromised,
all keks in the entire system become invalid and have to be re-established using
secure channels between the kdc and each user.
no perfect forward secrecy if any of the keks becomes compromised, e.g.,
through a hacker or trojan software running on a users computer, the consequences
are serious. first, all future communication can be decrypted by the attacker who
eavesdrops. for instance, if oscar got a hold of alices kek ka , he can recover the
session key from all messages ya that the kdc sends out. even more dramatic
is the fact that oscar can also decrypt past communications if he stored old
messages ya and y. even if alice immediately realizes that her kek has been compromised and she stops using it right away, there is nothing she can do to prevent
oscar from decrypting her past communication. whether a system is vulnerable if
long-term keys are compromised is an important feature of a security system and
there is a special terminology used
definition 13.1. a cryptographic protocol has perfect forward secrecy (pfs) if the
compromise of long-term keys does not allow an attacker to obtain past session
keys.
neither kerberos nor the simpler protocols shown earlier offer pfs. the main
mechanism to assure pfs is to employ public-key techniques, which we study in
the following sections.

342

13 key establishment

13.3 key establishment using asymmetric techniques
public-key algorithms are especially suited for key establishment protocols since
they dont share most of the drawbacks that symmetric key approaches have. in fact,
next to digital signatures, key establishment is the other major application domain
of public-key schemes. they can be used for both key transport and key agreement.
for the former, diffiehellman key exchange, elliptic curve diffiehellman or related protocols are often used. for key transport, any of the public-key encryption
schemes, e.g., rsa or elgamal, is often used. we recall at this point that public-key
primitives are quite slow, and that for this reason actual data encryption is usually
done with symmetric primitives like aes or 3des, after a key has been established
using asymmetric techniques.
at this moment it looks as though public-key schemes solve all key establishment
problems. it turns out, however, that they all require what is termed an authenticated
channel to distribute the public keys. the remainder of this chapter is chiefly devoted
to solving the problem of authenticated public key distribution.

13.3.1 man-in-the-middle attack
the man-in-the-middle attack1 is a serious attack against public-key algorithms.
the basic idea of the attack is that the adversary, oscar, replaces the public keys
sent out by the participants with his own keys. this is possible whenever public
keys are not authenticated. the man-in-the-middle (mim) attack has far-reaching
consequences for asymmetric cryptography. for didactical reasons we will study
the mim attack against the diffiehellman key exchange (dhke). however, it is
extremely important to bear in mind that the attack is applicable against any asymmetric scheme unless the public-keys are protected, e.g., through certificates, a topic
that is discussed in sect. 13.3.2.
we recall that the dhke allows two parties who never met before to agree on a
shared secret by exchanging messages over an insecure channel. for convenience,
we restate the dhke protocol here

1

the man-in-the-middle attack should not be confused with the similarly sounding but in
fact entirely different meet-in-the-middle attack against block ciphers which was introduced in
sect. 5.3.1.

13.3 key establishment using asymmetric techniques

343

diffiehellman key exchange
alice
choose random a  k pr,a
compute a  k pub,a   a mod
p

bob
choose random b  k pr,b
compute b  k pub,b   b mod
p
a


b


kab

 ba

kab  ab mod p

mod p

as we discussed in sect. 8.4, if the parameters are chosen carefully, which includes especially a prime p with a length of 1024 or more bit, the dhke is secure
against eavesdropping, i.e., passive attacks. we consider now the case that an adversary is not restricted to only listening to the channel. rather, oscar can also actively
take part in the message exchange by intercepting, changing and generating messages. the underlying idea of the mim attack is that oscar replaces both alices
and bobs public key by his own. the attack is shown here
man-in-the-middle attack against the dhke
alice
choose a  k pr,a
a  k pub,a   a mod
p

oscar

a

 substitute a   o
b

 substitute b   o
kao

 (b)a

mod p

bob
choose b  k pr,b
b  k pub,b   b mod
p
a


b



 ao

kao
mod p
kbo  bo mod p

kbo  (a)b mod p

lets look at the keys that are being computed by the three players, alice, bob
and oscar. the key alice computes is
kao  (b)a  ( o )a   o a mod p
which is identical to the key that oscar computes as kao  ao  ( a )o   a o mod p.
at the same time bob computes
kbo  (a)b  ( o )b   o b mod p
which is identical to oscars key kbo  bo  ( b )o   b o mod p. note that the two
malicious keys that oscar sends out, a and b, are in fact the same values. with use
different names here merely to stress the fact that alice and bob assume that they
have received each others public keys.

344

13 key establishment

what happens in this attack is that two dhkes are being performed simultaneously, one between alice and oscar and another one between bob and oscar. as
a result, oscar has established a joined key with alice, which we termed kao , and
another one with bob, which we named kbo . however, neither alice nor bob is
aware of the fact that they share a key with oscar and not with each other
both assume that they have computed a joint key kab .
from here on, oscar has much control over encrypted traffic between alice and
bob. as an example, here is how he can read encrypted messages in a way that goes
unnoticed by alice and bob
message manipulation after a man-in-the-middle attack
alice
message x
y  aeskao (x)

oscar

bob

y

 intercept
decrypt x  aes1
kao (x)
re-encrypt
y

aeskbo (x)

y


(y)
decrypt x  aes1
k
bo

for illustrative purposes, we assumed that aes is used for the encryption. of course,
any other symmetric cipher can be used as well. please note that oscar can not only
read the plaintext x but can also alter it prior to re-encrypting it with kbo . this can
have serious consequences, e.g., if the message x describes a financial transaction.

13.3.2 certificates
the underlying problem of the man-in-the-middle attack is that public keys are not
authenticated. we recall from sect. 10.1.3 that message authentication ensures that
the sender of a message is authentic. however, in the scenario at hand bob receives
a public key which is supposedly alices, but he has no way of knowing whether
that is in fact the case. to make this point clear, lets examine how a key of a user
alice would look in practice
ka  (k pub,a , ida ),
where ida is identifying information, e.g., alices ip address or her name together
with date of birth. the actual public key k pub,a , however, is a mere binary string,
e.g., 2048 bit. if oscar performs a mim attack, he would change the key to
ka  (k pub,o , ida ).

13.3 key establishment using asymmetric techniques

345

since everything is unchanged except the anonymous actual bit string, the receiver
will not be able to detect that it is in fact oscars. this observation has far-reaching
consequences which can be summarized in the following statement
even though public-key schemes do not require a secure channel, they require authenticated channels for the distribution of the public keys.

we would like to stress here again that the mim attack is not restricted to the dhke,
but is in fact applicable to any asymmetric crypto scheme. the attack always proceeds the same way oscar intercepts the public key that is being sent and replaces
it with his own.
the problem of trusted distribution of private keys is central in modern publickey cryptography. there are several ways to address the problem of key authentication. the main mechanism is the use of certificates. the idea behind certificates is
quite easy since the authenticity of the message (k pub,a , ida ) is violated by an active attack, we apply a cryptographic mechanism that provides authentication. more
specifically, we use digital signatures.2 thus, a certificate for a user alice in its most
basic form is the following structure
certa  [(k pub,a , ida ), sigk pr (k pub,a , ida )]
the idea is that the receiver of a certificate verifies the signature prior to using the
public key. we recall from chap. 10 that the signature protects the signed message
 which is the structure (k pub,a , ida ) in this case  against manipulation. if oscar
attempts to replace k pub,a by k pub,o it will be detected. thus, it is said that certificates bind the identity of a user to their public key.
certificates require that the receiver has the correct verification key, which is a
public key. if we were to use alices public key for this, we would have the same
problem that we are actually trying to solve. instead, the signatures for certificates
are provided by a mutually trusted third party. this party is called the certification
authority commonly abbreviated as ca. it is the task of the ca to generate and issue
certificates for all users in the system. for certificate generation, we can distinguish
between two main cases. in the first case, the user computes her own asymmetric
key pair and merely requests the ca to sign the public key, as shown in the following
simple protocol for a user named alice

2 macs also provide authentication and could, in principle, also be used for authenticating public keys. however, because macs themselves are symmetric algorithms, we would again need a
secure channel for distributing the mac keys with all the associated drawbacks.

346

13 key establishment

certificate generation with user-provided keys
alice
generate k pr,a , k pub,a

ca
rqst(k pub,a , ida )


verify ida
sa  sigk pr ,ca (k pub,a , ida )
certa  [(k pub,a , ida ), sa ]
cert
a

from a security point of view, the first transaction is crucial. it must be assured
that alices message (k pub,a , ida ) is sent via an authenticated channel. otherwise,
oscar could request a certificate in alices name.
in practice it is often advantageous that the ca not only signs the public keys
but also generates the publicprivate key pairs for each user. in this case, a basic
protocol looks like this
certificate generation with ca-generated keys
alice
request certificate

ca
rqst(ida )


verify ida
generate k pr,a , k pub,a
sa  sigk pr ,ca (k pub,a , ida )
certa  [(k pub,a , ida ), sa ]
certa , k pr,a


for the first transmission, an authenticated channel is needed. in other words
the ca must be assured that it is really alice who is requesting a certificate, and
not oscar who is requesting a certificate in alices name. even more sensitive is the
second transmission consisting of (certa , k pr,a ). because the private key is being
sent here, not only an authenticated but a secure channel is required. in practice,
this could be a certificate delivered by mail on a cd-rom.
before we discuss cas in more detail, lets have a look at the dhke which is
protected with certificates

13.3 key establishment using asymmetric techniques

347

diffiehellman key exchange with certificates
alice
a  k pr,a
a  k pub,a   a mod p
certa  [(a, ida ), sa ]

bob
b  k pr,b
b  k pub,b   b mod p
certb  [(b, idb ), sb ]
cert
a
cert
b

verify certificate
verk pub,ca (certb )
compute session key
kab  ba mod p

verify certificate
verk pub,ca (certa )
compute session key
kab  ab mod p

one very crucial point here is the verification of the certificates. obviously, without verification, the signatures within the certificates would be of no use. as can be
seen in the protocol, verification requires the public key of the ca. this key must
be transmitted via an authenticated channel, otherwise oscar could perform mim
attacks again. it looks like we havent gained much from the introduction of certificates since we again require an authenticated channel however, the difference
from the former situation is that we need the authenticated channel only once,
at set-up time. for instance, public verification keys are nowadays often included
in pc software such as web browsers or microsoft software products. the authenticated channel is here assumed to be given through the installation of original software which has not been manipulated. whats happening here from a more abstract
point of view is extremely interesting, namely a transfer of trust. we saw in the
earlier example of dhke without certificates, that alice and bob have to trust each
others public keys directly. with the introduction of certificates, they only have to
trust the cas public key k pub,ca . if the ca signs other public keys, alice and bob
know that they can also trust those. this is called a chain of trust.

13.3.3 public-key infrastructures (pki) and cas
the entire system that is formed by cas together with the necessary support mechanisms is called a public-key infrastructure, usually referred to as pki. as the reader
can perhaps start to imagine, setting up and running a pki in the real world is a
complex task. issues such as identifying users for certificate issuing and trusted distribution of ca keys have to be solved. there are also many other real-world issues
among the most complex are the existence of many different cas and revocation of
certificates. we discuss some aspects of using certificate systems in practice in the
following.

348

13 key establishment

x.509 certificates
in practice, certificates not only include the id and the public key of a user, they
tend to be quite complex structures with many additional fields. as an example,
we look at the a x.509 certificate in fig. 13.4. x.509 is an important standard for
network authentication services, and the corresponding certificates are widely used
for internet communication, i.e., in s/mime, ipsec and ssl/tls.





    
 
  
 
 
  
   
 
    
 
  
  
 

fig. 13.4 detailed structure of an x.509 certificate

discussing the fields defined in a x.509 certificate gives us some insight into
many aspects of pkis in the real world. we discuss the most relevant ones in the
following
1. certificate algorithm here it is specified which signature algorithm is being
used, e.g., rsa with sha-1 or ecdsa with sha-2, and with which parameters,
e.g., the bit lengths.
2. issuer there are many companies and organizations that issue certificates. this
field specifies who generated the one at hand.
3. period of validity in most cases, a public key is not certified indefinitely but
rather for a limited time, e.g., for one or two years. one reason for doing this
is that private keys which belong to the certificate may become compromised.
by limiting the validity period, there is only a certain time span during which
an attacker can maliciously use the private key. another reason for a restricted
lifetime is that, especially for certificates for companies, it can happen that the

13.3 key establishment using asymmetric techniques

349

user ceases to exist. if the certificates, and thus the public keys, are only valid for
limited time, the damage can be controlled.
4. subject this field contains what was called ida or idb in our earlier examples. it
contains identifying information such as names of people or organizations. note
that not only actual people but also entities like companies can obtain certificates.
5. subjects public key the public key that is to be protected by the certificate
is here. in addition to the binary string which is the public key, the algorithm
(e.g., diffiehellman) and the algorithm parameters, e.g., the modulus p and the
primitive element  , are stored.
6. signature the signature over all other fields of the certificate.
we note that for every signature two public key algorithms are involved the one
whose public key is protected by the certificate and the algorithm with which the
certificate is signed. these can be entirely different algorithms and parameter sets.
for instance, the certificate might be signed with an rsa 2048-bit algorithm, while
the public key within the certificate could belong to a 160-bit elliptic curve scheme.

chain of certificate authorities (cas)
in an ideal world, there would be one ca which issues certificates for, say, all internet users on planet earth. unfortunately, that is not the case. there are many different entities that act as cas. first of all, many countries have their own official
ca, often for certificates that are used for applications that involve government business. second, certificates for websites are currently issued by more than 50 mostly
commercial entities. (most web browsers have the public key of those cas preinstalled.) third, many corporations issue certificate for their own employees and
external entities who do business with them. it would be virtually impossible for a
user to have the private keys of all these different cas at hand. what is done instead
is that cas certify each other.
lets look at an example where alices certificate is issued by ca1 and bobs by
ca2. at the moment, alice is only in possession of the public key of her ca1,
and bob has only k pub,ca2 . if bob sends his certificate to alice, she cannot verify
bobs public key. this situation looks like this
two users with different certificate authorities
alice

bob
k pub,ca2
certb  [(k pub,b , idb ), sigk pr,ca2 (k pub,b , idb )]

k pub,ca1
cert
b

alice can now request ca2s public key, which is itself contained in a certificate
that was signed by alices ca1

350

13 key establishment

verification of a ca public key
alice

ca2
rqst(certca2 )

certca2



verk pub,ca1 (certca2 )
 k pub,ca2 is valid
verk pub,ca2 (certb )
 k pub,b is valid

the structure certca2 contains the public key of ca2 signed by ca1, which
looks like this
certca2  [(k pub,ca2 , idca2 ), sigk pr,ca1 (k pub,ca2 , idca2 )]
the important outcome of the process is that alice can now verify bobs key.
whats happening here is that a certificate chain is being established. ca1 trusts
ca2 which is expressed by ca1 signing the public key k pub,ca2 . now alice can
trust bobs public key since it was signed by ca1. this situation is called a chain
of trust, and it is said that trust is delegated.
in practice, cas can be arranged hierarchically, where each ca signes the public
key of the certificate authorities one level below. alternatively, cas can cross-certify
each other without a strict hierarchical relationship.

certificate revocation lists
one major issue in practice is that it must be possible to revoke certificates. a common reason is that a certificate is stored on a smart card which is lost. another
reason could be that a person left an organization and one wants to make sure that
she is not using the public key that was given to her. the solution in these situations
seems easy just publish a list with all certificates that are currently invalid. such
a list is called a certificate revocation list, or crl. typically, the serial numbers of
certificates are used to identify the revoked certificates. of course, a crl must be
signed by the ca since otherwise attacks are possible.
the problem with clrs is how to transmit them to the users. the most straightforward way is that every user contacts the issuing ca every time a certificate of
another user is received. the major drawback is that now the ca is involved in
every session set-up. this was one major drawback of kdc-based, i.e., symmetrickey, approaches. the promise of certificate-based communication was that no online
contact to a central authority was needed.
an alternative is that crls are sent out periodically. the problem with this approach is that there is always a period during which a certificate is invalid but users

13.4 discussion and further reading

351

have not yet been informed. for instance, if the crl is sent out at 300 am every
morning (a time with relatively little network traffic otherwise), a dishonest person
could have almost a whole day where a revoked certificate is still valid. to counter
this, the crl update period can be shortened, say to one hour. however, this would
be a tremendous burden on the bandwidth of the network. this is an instructive example for the tradeoff between costs in the form of network traffic on one hand, and
security on the other hand. in practice, a reasonable compromise must be found.
in order to keep the size of crls moderate, often only the changes from the last
crl broadcast are sent out. these update-only crls are referred to as delta crls.

13.4 discussion and further reading
key establishment protocols in most modern network security protocols, publickey approaches are used for establishing keys. in this book, we introduced the
diffiehellman key exchange and described a basic key transport protocol in
chap. 6 (cf. fig. 6.5). in practice, often considerably more advanced asymmetric
protocols are used. however, most of them are based on either the diffiehellman
or a key transport protocol. a comprehensive overview on this area is given in [33].
we now give a few examples of generic cryptographic protocols that are often preferred over the basic diffiehellman key exchange. the mti (matsumoto
takashimaimai) protocols are an ensemble of authenticated diffiehellman key
exchanges which were already published in 1986. good descriptions can be found
in [33] and [120]. another popular diffiehellman extension is the station-to-station
(sts) protocol. it uses certificates and provides both user and key authentication.
a discussion about sts variants can be found in [60]. a more recent protocol for
authenticated diffiehellman is the mqv protocol which is discussed in [108]. it is
typically used with elliptic curves.
a prominent practical example for a key establishment protocol is the internet
key exchange (ike) protocol. ike provides key material for ipsec, which is the
official security mechanism for internet traffic. ike is quite complex and offers
many options. at its core, however, is a diffiehellman key agreement followed
by an authentication. the latter can either be achieved with certificates or with preshared keys. a good starting point for more information on ipsec and ike is the
rfc [128] and, more accessibly, reference [161, chapter 16].
certificates and alternatives during the second half of the 1990s there was a
belief that essentially every internet user would need a certificate in order to communicate securely, e.g., for doing ebusiness transactions. pki was a buzzword for
some time, and many companies were formed that provided certificates and pki services. however, it turned out that there are major technical and practical hurdles to a
pki that truly encompasses all or most internet users. what has happened instead is
that nowadays many servers are authenticated with certificates, for instance internet
retailers, whereas most individual users are not. the needed ca verification keys

352

13 key establishment

are often preinstalled in users web browsers. this asymmetric set-up  the server
is authenticated but the user is not  is acceptable since the user is typically the one
who provides crucial information such as her credit card number. a comprehensive
introduction to the large field of pki and certificates is given in the book [2]. an interesting and entertaining discussion about the alleged shortcomings of pki is given
in [74], and an equally instructive rebuttal is online at [107].
we introduced certificates and a public-key infrastructure as the main method
for authenticating public keys. such hierarchical organized certificates are only one
possible approach, though this is the most widely used one. another concept is the
web of trust that relies entirely on trust relationships between parties. the idea is
as follows if alice trusts bob, it is assumed that she also wants to trust all other
users whom bob trusts. this means that every party in such a web of trust implicitly
trusts parties whom it does not know (or has never met before). the most popular
example for such a system are pretty good privacy (pgp) and gnu privacy guard
(gpg), which are widely used for signing and encrypting emails.

13.5 lessons learned








a key transport protocol securely transfers a secret key to other parties.
in a key agreement protocol, two or more parties negotiate a common secret key.
in most common symmetric protocols, the key exchange is coordinated by a
trusted third party. a secure channel between the third party and each user is
only required at set-up time.
symmetric key establishment protocols do not scale well to networks with large
numbers of users and they provide typically no perfect forward secrecy.
the most widely used asymmetric key establishment protocol is the diffie
hellman key exchange.
all asymmetric protocols require that the public keys are authenticated, e.g., with
certificates. otherwise man-in-the-middle attacks are possible.

problems

353

problems
13.1. in this exercise, we want to analyze some variants of key derivation. in practice, one masterkey kmk is exchanged in a secure way (e.g. certificate-based dhke)
between the involved parties. afterwards, the session keys are regularly updated by
use of key derivation. for this purpose, three different methods are at our disposal
(1) k0  kmk  ki+1  ki + 1
(2) k0  h(kmk ) ki+1  h(ki )
(3) k0  h(kmk ) ki+1  h(kmk iki )
where h() marks a (secure) hash function, and ki is the ith session key.
1. what are the main differences between these three methods
2. which method provides perfect forward secrecy
3. assume oscar obtains the nth session key (e.g., via brute-force). which sessions
can he now decrypt (depending on the chosen method)
4. which method remains secure if the masterkey kmk is compromised give a
rationale
13.2. imagine a peer-to-peer network where 1000 users want to communicate in an
authenticated and confidential way without a central trusted third party (ttp).
1. how many keys are collectively needed, if symmetric algorithms are deployed
2. how are these numbers changed, if we bring in a central instance (key distribution center, kdc)
3. what is the main advantage of a kdc against the scenario without a kdc
4. how many keys are necessary if we make use of asymmetric algorithms
also differentiate between keys which every user has to store and keys which are
collectively necessary.
13.3. you have to choose the cryptographic algorithms for a kdc where two different classes of encryption occur



eku,kdc (), where u denotes an arbitrary network node (user),
ekses () for the communication between two users.

you have the choice between two different algorithms, des and 3des (tripledes), and you are advised to use distinct algorithms for both encryption classes.
which algorithm do you use for which class justify your answer including aspects
of security as well as celerity.
13.4. this exercise considers the security of key establishment with the aid of a
kdc. assume that a hacker performs a successful attack against the kdc at the
point of time tx , where all keys are compromised. the attack is detected.
1. which (practical) measures have to be taken in order to prevent decryption of
future communication between the network nodes

354

13 key establishment

2. which steps did the attacker have to take in order to decipher data transmissions
which occurred at an earlier time (t  tx ) does such a kdc system provide
perfect forward secrecy (pfs) or not
13.5. we will now analyze an improved kdc system. in contrast to the previous
problem, all keys eku,kdc () are now refreshed in relatively short intervals



(i+1)

the kdc generates a new (random) key ku,kdc
the kdc transmits the new key to user u, encrypted with the old one
(i+1)
e (i) (ku,kdc )
ku,kdc

which decryptions are possible, if a staff member of the kdc is corruptible and
sells all recent keys e (i)
of the kdc at the point of time tx  we assume that
ku,kdc

this circumstance is not detected until the point of time ty which could be much later,
e.g., one year.
13.6. show a key confirmation attack against the basic kdc protocol introduced in
sect. 13.2.1. describe each step of the attack. your drawing should look similar to
the one showing a key confirmation attack against the second (modified) kdc-based
protocol.
13.7. show that pfs is in fact not given in the simplified kerberos protocol. show
how oscar can decrypt past and future communications if
1. alices kek ka becomes compromised
2. bobs kek kb becomes compromised
13.8. extend the kerberos protocol such that a mutual authentication between alice
and bob is performed. give a rationale that your solution is secure.
13.9. people at your new job are deeply impressed that you worked through this
book. as the first job assignment you are asked to design a digital pay-tv system
which uses encryption to prevent service theft through wire tapping. as key exchange protocol, a strong diffiehellman with, e.g., 2048-bit modulus is being used.
however, since your company wants to use cheap legacy hardware, only des is
available for data encryption algorithm. you decide to use the following key derivation approach
k (i)  f (kab  i).

(13.1)

where f is an irreversible function.
1. first we have to determine whether the attacker can store an entire movie with
reasonable effort (in particular, cost). assume the data rate for the tv link is
1 mbit/s, and that the longest movies we want to protect are 2 hours long. how
many gbytes (where 1m  106 and 1g  109 ) of data must be stored for a 2-hour
film (dont mix up bit and byte here) is this realistic

problems

355

2. we assume that an attacker will be able to find a des key in 10 minutes using
a brute-force attack. note that this is a somewhat optimistic assumption from an
attackers point of view, but we want to provide some medium-term security by
assuming increasingly faster key searches in the future.
how frequently must a key be derived if the goal is to prevent an offline decryption of a 2-hour movie in less than 30 days
13.10. we consider a system in which a key kab is established using the diffie
hellman key exchange protocol, and the encryption keys k(i) are then derived by
computing
(13.2)
k(i)  h(kab  i)
where i is just an integer counter, represented as a 32-bit variable. the values of i
are public (e.g., the encrypting party always indicates which value for i was used
in a header that precedes each ciphertext block). the derived keys are used for the
actual data encryption with a symmetric algorithm. new keys are derived every
60 sec during the communication session.
1. assume the diffiehellman key exchange is done with a 512-bit prime, and the
encryption algorithm is aes. why doesnt it make cryptographic sense to use the
key derivation protocol described above describe the attack that would require
the least computational effort from oscar.
2. assume now that the diffiehellman key exchange is done with a 2048-bit
prime, and the encryption algorithm is des. describe in detail what the advantages are that the key derivation scheme offers compared to a system that just
uses the diffiehellman key for des.
13.11. we reconsider the diffiehellman key exchange protocol. assume now that
oscar runs an active man-in-the-middle attack against the key exchange as explained
in sect. 13.3.1. for the diffiehellman key exchange, use the parameters p  467,
  2, and a  228, b  57 for alice and bob, respectively. oscar uses the value
o  16. compute the key pairs kao and kbo (i) the way oscar computes them, and
(ii) the way alice and bob compute them.
13.12. we consider the diffiehellman key exchange scheme with certificates. we
have a system with the three users alice, bob and charley. the diffiehellman
algorithm uses p  61 and   18. the three secret keys are a  11, b  22 and
c  33. the three ids are id(a)1, id(b)2 and id(c)3.
for signature generation, the elgamal signature scheme is used. we apply the
system parameters p  467, d  127,   2 and  . the ca uses the ephemeral
keys ke  213, 215 and 217 for alices, bobs and charleys signatures, respectively. (in practice, the ca should use a better pseudorandom generator to obtain
the ke values.)
to obtain the certificates, the ca computes xi  4  bi + id(i) and uses this value
as input for the signature algorithm. (given xi , id(i) follows then from id(i) 
xi mod 4.)
1. compute three certificates certa , certb and certc .

356

13 key establishment

2. verify all three certificates.
3. compute the three session keys kab , kac and kbc .
13.13. assume oscar attempts to use an active (substitution) attack against the
diffiehellman key exchange with certificates in the following ways
1. alice wants to communicate with bob. when alice obtains c(b) from bob, oscar replaces it with (a valid) c(o). how will this forgery be detected
2. same scenario oscar tries now to replace only bobs public key bb with his own
public key bo . how will this forgery be detected
13.14. we consider certificate generation with ca-generated keys. assume the second transmission of (certa , k pr,a ) takes place over an authenticated but insecure
channel, i.e., oscar can read this message.
1. show how he can decrypt traffic which is encrypted by means of a diffie
hellman key that alice and bob generated.
2. can he also impersonate alice such that he computes a dh key with bob without
bob noticing
13.15. given is a user domain in which users share the diffiehellman parameters  and p. each users public diffiehellman key is certified by a ca. users
communicate securely by performing a diffiehellman key exchange and then encrypting/decrypting messages with a symmetric algorithm such as aes.
assume oscar gets hold of the cas signature algorithm (and especially its private key), which was used to generate certificates. can he now decrypt old ciphertexts which were exchanged between two users before the ca signature algorithm
was compromised, and which oscar had stored explain your answer.
13.16. another problem in certificate systems is the authenticated distribution of the
cas public key which is needed for certificate verification. assume oscar has full
control over all of bobs communications, that is, he can alter all messages to and
from bob. oscar now replaces the cas public key with his own (note that bob has
no means to authenticate the key that he receives, so he thinks that he received the
ca public key.)
1. (certificate issuing) bob requests a certificate by sending a request containing
(1) bobs id id(b) and (2) bobs public key b from the ca. describe exactly
what oscar has to do so that bob doesnt find out that he has the wrong public
ca key.
2. (protocol execution) describe what oscar has to do to establish a session key
with bob using the authenticated diffiehellman key exchange, such that bob
thinks he is executing the protocol with alice.
13.17. draw a diagram that shows a key transport protocol shown in fig. 6.5 from
sect. 6.1, in which rsa encryption is used.

problems

357

13.18. we consider rsa encryption with certificates in which bob has the rsa
keys. oscar manages to send alice a verification key k pr,ca which is, in fact, oscars
key. show an active attack in which he can decipher encrypted messages that alice
sends to bob. should oscar run a mim attack or should he set up a session only
between himself and alice
13.19. pretty good privacy (pgp) is a widespread scheme for electronic mail security to provide authentication and confidentiality. pgp does not necessarily require the use of certificate authorities. describe the trust model of pgp and how the
public-key management works in practice.

references

1. michel abdalla, mihir bellare, and phillip rogaway. dhaes an encryption scheme
based on the diffiehellman problem.
available at citeseer.ist.psu.edu/
abdalla99dhaes.html, 1999.
2. carlisle adams and steve lloyd. understanding pki concepts, standards, and deployment
considerations. addison-wesley longman publishing, boston, ma, usa, 2002.
3. ansi x9.17-1985. american national standard x9.17 financial institution key management, 1985.
4. ansi x9.31-1998. american national standard x9.31, appendix a.2.4 public key cryptography using reversible algorithms for the financial services industry (rdsa). technical
report, accredited standards committee x9, available at http//www.x9.org, 2001.
5. ansi x9.42-2003. public key cryptography for the financial services industry agreement
of symmetric keys using discrete logarithm cryptography. technical report, american
bankers association, 2003.
6. ansi x9.62-1999. the elliptic curve digital signature algorithm (ecdsa). technical
report, american bankers association, 1999.
7. ansi x9.62-2001. elliptic curve key agreement and key transport protocols. technical
report, american bankers association, 2001.
8. frederik armknecht.
algebraic attacks on certain stream ciphers.
phd thesis,
department of mathematics, university of mannheim, germany, december 2006.
http//madoc.bib.uni-mannheim.de/madoc/volltexte/2006/1352/.
9. standards for efficient cryptography  sec 1 elliptic curve cryptography, september
2000. version 1.0.
10. daniel v. bailey and christof paar. efficient arithmetic in finite field extensions with application in elliptic curve cryptography. journal of cryptology, 14, 2001.
11. elad barkan, eli biham, and nathan keller. instant ciphertext-only cryptanalysis of gsm
encrypted communication. journal of cryptology, 21(3)392429, 2008.
12. p. s. l. m. barreto and v. rijmen.
the whirlpool hashing function, september
2999. (revised may 2003), http//paginas.terra.com.br/informatica/
paulobarreto/whirlpoolpage.html.
13. f. l. bauer. decrypted secrets methods and maxims of cryptology. springer, 4th edition,
2007.
14. mihir bellare, ran canetti, and hugo krawczyk. keying hash functions for message authentication. in crypto 96 proceedings of the 16th annual international cryptology
conference, advances in cryptology, pages 115. springer, 1996.
15. mihir bellare, ran canetti, and hugo krawczyk. message authentication using hash
functionsthe hmac construction. cryptobytes, 2, 1996.
16. c.h. bennett, e. bernstein, g. brassard, and u. vazirani. the strengths and weaknesses of
quantum computation. siam journal on computing, 2615101523, 1997.
c. paar, j. pelzl, understanding cryptography,
c springer-verlag berlin heidelberg 2010
doi 10.1007/978-3-642-04101-3, 

359

360

references

17. daniel j. bernstein. multidigit multiplication for mathematicians. url http//
cr.yp.to/papers.html.
18. daniel j. bernstein, johannes buchmann, and erik dahmen. post-quantum cryptography.
springer, 2009.
19. n. biggs. discrete mathematics. oxford university press, new york, 2nd edition, 2002.
20. e. biham. a fast new des implementation in software. in fourth international workshop
on fast software encryption, volume 1267 of lncs, pages 260272. springer, 1997.
21. eli biham and adi shamir. differential cryptanalysis of the data encryption standard.
springer, 1993.
22. alex biryukov, adi shamir, and david wagner. real time cryptanalysis of a5/1 on a pc. in
fse fast software encryption, pages 118. springer, 2000.
23. j. black, s. halevi, h. krawczyk, t. krovetz, and p. rogaway. umac fast and secure
message authentication. in crypto 99 proceedings of the 19th annual international
cryptology conference, advances in cryptology, volume 99, pages 216233. springer, 1999.
24. i. blake, g. seroussi, n. smart, and j. w. s. cassels. advances in elliptic curve cryptography (london mathematical society lecture note series). cambridge university press, new
york, ny, usa, 2005.
25. ian f. blake, g. seroussi, and n. p. smart. elliptic curves in cryptography. cambridge
university press, new york, ny, usa, 1999.
26. daniel bleichenbacher, wieb bosma, and arjen k. lenstra. some remarks on lucas-based
cryptosystems. in crypto 95 proceedings of the 15th annual international cryptology
conference, advances in cryptology, pages 386396. springer, 1995.
27. l blum, m blum, and m shub. a simple unpredictable pseudorandom number generator.
siam j. comput., 15(2)364383, 1986.
28. manuel blum and shafi goldwasser. an efficient probabilistic public-key encryption scheme
which hides all partial information. in crypto 84 proceedings of the 4th annual international cryptology conference, advances in cryptology, pages 289302, 1984.
29. andrey bogdanov, gregor leander, lars r. knudsen, christof paar, axel poschmann,
matthew j.b. robshaw, yannick seurin, and charlotte vikkelsoe. presentan ultralightweight block cipher. in ches 07 proceedings of the 9th international workshop on
cryptographic hardware and embedded systems, number 4727 in lncs, pages 450466.
springer, 2007.
30. dan boneh and matthew franklin. identity-based encryption from the weil pairing. siam
j. comput., 32(3)586615, 2003.
31. dan boneh and richard j. lipton. algorithms for black-box fields and their application to
cryptography (extended abstract). in crypto 96 proceedings of the 16th annual international cryptology conference, advances in cryptology, pages 283297. springer, 1996.
32. dan boneh, ron rivest, adi shamir, and len adleman. twenty years of attacks on the
rsa cryptosystem. notices of the ams, 46203213, 1999.
33. colin a. boyd and anish mathuria. protocols for key establishment and authentication.
springer, 2003.
34. ecc brainpool. ecc brainpool standard curves and curve generation, 2005. http//
www.ecc-brainpool.org/ecc-standard.htm.
35. johannes buchmann and jintai ding, editors. post-quantum cryptography, second international workshop, pqcrypto 2008, proceedings, volume 5299 of lncs. springer, 2008.
36. johannes buchmann and jintai ding, editors. pqcrypto 2006 international workshop on
post-quantum cryptography, lncs. springer, 2008.
37. german federal office for information security (bsi).
http//www.bsi.
de/english/publications/bsistandards/index.htm.
38. mike burmester and yvo desmedt. a secure and efficient conference key distribution system
(extended abstract). in advances in cryptology  eurocrypt94, pages 275286, 1994.
39. c. m. campbell. design and specification of cryptographic capabilities. nbs special publication 500-27 computer security and the data encryption standard, u.s. department of
commerce, national bureau of standards, pages 5466, 1977.

references

361

40. j.l. carter and m.n. wegman. new hash functions and their use in authentication and set
equality. journal of computer and system sciences, 22(3)265277, 1981.
41. cetin kaya koc, tolga acar, and burton s. kaliski. analyzing and comparing montgomery
multiplication algorithms. ieee micro, 16(3)2633, 1996.
42. p. chodowiec and k. gaj. very compact fpga implementation of the aes algorithm. in
c. d. walter, c. k. koc, and c. paar, editors, ches 03 proceedings of the 5th international
workshop on cryptographic hardware and embedded systems, volume 2779 of lncs, pages
319333. springer, 2003.
43. c. cid, s. murphy, and m. robshaw. algebraic aspects of the advanced encryption standard. springer, 2006.
44. h. cohen, g. frey, and r. avanzi. handbook of elliptic and hyperelliptic curve cryptography. discrete mathematics and its applications. chapman and hall/crc, september
2005.
45. t. collins, d. hopkins, s. langford, and m. sabin. public key cryptographic apparatus and
method, 1997. united states patent us 5,848,159. jan. 1997.
46. common criteria for information technology security evaluation. http//www.
commoncriteriaportal.org/.
47. copacobanaa cost-optimized parallel code breaker.
http//www.
copacobana.org/.
48. sony corporation.
clefia  new block cipher algorithm based on state-ofthe-art design technologies, 2007.
http//www.sony.net/sonyinfo/news/
press/200703/07-028e/index.html.
49. ronald cramer and victor shoup. a practical public key cryptosystem provably secure
against adaptive chosen ciphertext attack. crypto 98 proceedings of the 18th annual
international cryptology conference, advances in cryptology, 14621325, 1998.
50. cryptool

educational
tool
for
cryptography
and
cryptanalysis.
https//www.cryptool.org/.
51. j. daemen and v. rijmen. aes proposal rijndael. in first advanced encryption standard
(aes) conference, ventura, california, usa, 1998.
52. joan daemen and vincent rijmen. the design of rijndael. springer, 2002.
53. b. den boer and a. bosselaers. an attack on the last two rounds of md4. in crypto 91
proceedings of the 11th annual international cryptology conference, advances in cryptology, lncs, pages 194203. springer, 1992.
54. b. den boer and a. bosselaers. collisions for the compression function of md5. in advances
in cryptology - eurocrypt93, lncs, pages 293304. springer, 1994.
55. alexander w. dent. a brief history of provably-secure public-key encryption. cryptology
eprint archive, report 2009/090, 2009. http//eprint.iacr.org/.
56. diehard battery of tests of randomness cd, 1995.
http//i.cs.hku.hk/
diehard/.
57. w. diffie. the first ten years of public-key cryptography. innovations in internetworking,
pages 510527, 1988.
58. w. diffie and m. e. hellman. new directions in cryptography. ieee transactions on information theory, it-22644654, 1976.
59. w. diffie and m. e. hellman. exhaustive cryptanalysis of the nbs data encryption standard. computer, 10(6)7484, june 1977.
60. whitfield diffie, paul c. van oorschot, and michael j. wiener. authentication and authenticated key exchanges. des. codes cryptography, 2(2)107125, 1992.
61. hans dobbertin. alf swindles ann. cryptobytes, 3(1), 1995.
62. hans dobbertin. the status of md5 after a recent attack. cryptobytes, 2(2), 1996.
63. saar drimer, tim guneysu, and christof paar. dsps, brams and a pinch of logic new
recipes for aes on fpgas. ieee symposium on field-programmable custom computing
machines (fccm), 099108, 2008.
64. morris dworkin.
recommendation for block cipher modes of operation the ccm mode for authentication and confidentiality, may 2004.
http//csrc.nist.gov/publications/nistpubs/800-38c/sp800-38c
updated-july202007.pdf.

362

references

65. morris dworkin. recommendation for block cipher modes of operation the cmac
mode for authentication, nist special publication 800-38d, may 2005. http//csrc.
nist.gov/publications/nistpubs/800-38d/sp-800-38d.pdf.
66. morris dworkin.
recommendation for block cipher modes of operation galois counter mode (gcm) and gmac, nist special publication 800-38d,
november 2007.
http//csrc.nist.gov/publications/nistpubs/
800-38d/sp-800-38d.pdf.
67. h. eberle and c.p. thacker. a 1 gbit/second gaas des chip. in custom integrated circuits
conference, pages 19.7/14. ieee, 1992.
68. aes lounge, 2007. http//www.iaik.tu-graz.ac.at/research/krypto
/aes/.
69. estreamthe ecrypt stream cipher project, 2007. http//www.ecrypt.
eu.org/stream/.
70. the side channel cryptanalysis lounge, 2007.
http//www.crypto.ruhruni-bochum.de/ensclounge.html.
71. thomas eisenbarth, sandeep kumar, christof paar, axel poschmann, and leif uhsadel. a
survey of lightweight cryptography implementations. ieee design  test of computers
 special issue on secure ics for secure embedded computing, 24(6)522  533, november/december 2007.
72. s. e. eldridge and c. d. walter. hardware implementation of montgomerys modular multiplication algorithm. ieee transactions on computers, 42(6)693699, july 1993.
73. t. elgamal. a public-key cryptosystem and a signature scheme based on discrete logarithms.
ieee transactions on information theory, it-31(4)469472, 1985.
74. c. ellison and b. schneier. ten risks of pki what youre not being told about
public key infrastructure. computer security journal, 16(1)17, 2000. see also
http//www.counterpane.com/pki-risks.html.
75. m. feldhofer, j. wolkerstorfer, and v. rijmen. aes implementation on a grain of sand.
information security, iee proceedings, 152(1)1320, 2005.
76. amos fiat and adi shamir. how to prove yourself practical solutions to identification and
signature problems. in crypto 86 proceedings of the 6th annual international cryptology conference, advances in cryptology, pages 186194. springer, 1987.
77. federal information processing standards publications  fips pubs.
http//www.itl. nist.gov/fipspubs/index.htm.
78. electronic frontier foundation.
frequently asked questions (faq)
about the electronic frontier foundations des cracker machine, 1998.
http//w2.eff.org/privacy/crypto/cryptomisc/descracker/html/
19980716effdesfaq.html.
79. j. franke, t. kleinjung, c. paar, j. pelzl, c. priplata, and c. stahlke. shark  a realizable
special hardware sieving device for factoring 1024-bit integers. in josyula r. rao and berk
sunar, editors, ches 05 proceedings of the 7th international workshop on cryptographic
hardware and embedded systems, volume 3659 of lncs, pages 119130. springer, august
2005.
80. bundesamt fur sicherheit in der informationstechnik.
anwendungshinweise
und interpretationen zum schema (ais). funktionalitatsklassen und evaluationsmethodologie fur physikalische zufallszahlengeneratoren. ais 31, version 1, 2001.
http//www.bsi.bund.de/zertifiz/zert/interpr/ais31.pdf.
81. oded goldreich. foundations of cryptography basic tools. cambridge university press,
new york, ny, usa, 2000.
82. oded goldreich. zero-knowledge a tutorial by oded goldreich, 2001. http//
www.wisdom.weizmann.ac.il/oded/zk-tut02.html.
83. oded goldreich. foundations of cryptography volume 2, basic applications. cambridge
university press, new york, ny, usa, 2004.
84. oded goldreich. on post-modern cryptography. cryptology eprint archive, report
2006/461, 2006. http//eprint.iacr.org/.

references

363

85. jovan dj. golic. on the security of shift register based keystream generators. in fast software
encryption, cambridge security workshop, pages 90100. springer, 1994.
86. tim good and mohammed benaissa. aes on fpga from the fastest to the smallest. ches
05 proceedings of the 7th international workshop on cryptographic hardware and embedded systems, pages 427440, 2005.
87. l. grover. a fast quantum-mechanical algorithm for database search. in proceedings of
the twenty-eighth annual acm symposium on theory of computing, pages 212219. acm,
1996.
88. tim guneysu, timo kasper, martin novotny, christof paar, and andy rupp. cryptanalysis
with copacobana. ieee transactions on computers, 57(11)14981513, 2008.
89. s. halevi and h. krawczyk. mmh message authentication in software in the gbit/second
rates. in proceedings of the 4th workshop on fast software encryption, volume 1267, pages
172189. springer, 1997.
90. d. r. hankerson, a. j. menezes, and s. a. vanstone. guide to elliptic curve cryptography.
springer, 2004.
91. m. hellman. a cryptanalytic time-memory tradeoff. ieee transactions on information
theory, 26(4)401406, 1980.
92. shoichi hirose. some plausible constructions of double-block-length hash functions. in
fse fast software encryption, volume 4047 of lncs, pages 210225. springer, 2006.
93. deukjo hong, jaechul sung, and seokhie hong et al. hight a new block cipher suitable
for low-resource device. in ches 06 proceedings of the 8th international workshop on
cryptographic hardware and embedded systems, pages 4659. springer, 2006.
94. international organization for standardization (iso). iso/iec 15408, 15443-1, 15446,
19790, 19791, 19792, 21827.
95. international organization for standardization (iso). iso/iec 9796-11991, 9796-22000,
9796-32002, 19912002.
96. international organization for standardization (iso). iso/iec 10118-4, information
technologysecurity techniqueshash-functionspart 4 hash-functions using modular
arithmetic, 1998. http//www.iso.org/iso/.
97. d. kahn. the codebreakers. the story of secret writing. macmillan, 1967.
98. jens-peter kaps, gunnar gaubatz, and berk sunar. cryptography on a speck of dust. computer, 40(2)3844, 2007.
99. a. karatsuba and y. ofman. multiplication of multidigit numbers on automata. soviet
physics doklady (english translation), 7(7)595596, 1963.
100. ann hibner koblitz, neal koblitz, and alfred menezes. elliptic curve cryptography the
serpentine course of a paradigm shift. cryptology eprint archive, report 2008/390, 2008.
http//eprint.iacr.org/cgi-bin/cite.plentry2008/390.
101. neal koblitz. introduction to elliptic curves and modular forms. springer, 1993.
102. neal koblitz. the uneasy relationship between mathematics and cryptography. notices of
the ams, pages 973979, september 2007.
103. neal koblitz, alfred menezes, and scott vanstone. the state of elliptic curve cryptography.
des. codes cryptography, 19(2-3)173193, 2000.
104. cetin kaya koc. cryptographic engineering. springer, 2008.
105. s. kumar, c. paar, j. pelzl, g. pfeiffer, and m. schimmler. breaking ciphers with
copacobanaa cost-optimized parallel code breaker. in ches 06 proceedings of
the 8th international workshop on cryptographic hardware and embedded systems, lncs.
springer, october 2006.
106. matthew kwan.
reducing the gate count of bitslice des, 1999.
http//
www.darkside.com.au/bitslice/bitslice.ps.
107. ben laurie. seven and a half non-risks of pki what you shouldnt be told about public
key infrastructure. http//www.apache-ssl.org/7.5things.txt.
108. laurie law, alfred menezes, minghua qu, jerry solinas, and scott vanstone. an efficient
protocol for authenticated key agreement. des. codes cryptography, 28(2)119134, 2003.

364

references

109. arjen k. lenstra and eric r. verheul. the xtr public key system. in crypto 00 proceedings of the 20th annual international cryptology conference, advances in cryptology,
pages 119. springer, 2000.
110. rudolf lidl and harald niederreiter. introduction to finite fields and their applications.
cambridge university press, 2nd edition, 1994.
111. chae hoon lim and tymur korkishko. mcryptona lightweight block cipher for security of
low-cost rfid tags and sensors. in information security applications, volume 3786, pages
243258. springer, 2006.
112. yehuda lindell. composition of secure multi-party protocols a comprehensive study.
springer, 2003.
113. stefan mangard, elisabeth oswald, and thomas popp. power analysis attacks revealing
the secrets of smart cards (advances in information security). springer, 2007.
114. mitsuru matsui. linear cryptanalysis method for des cipher. in advances in cryptology eurocrypt 93, 1993.
115. mitsuru matsui. how far can we go on the x64 processors in fse fast software encryption, volume 4047 of lncs, pages 341358. springer, 2006.
116. mitsuru matsui and s. fukuda. how to maximize software performance of symmetric primitives on pentium iii and 4 processors. in fse fast software encryption, volume 3557 of
lncs, pages 398412. springer, 2005.
117. mitsuru matsui and junko nakajima. on the power of bitslice implementation on intel core2
processor. in ches 07 proceedings of the 9th international workshop on cryptographic
hardware and embedded systems, pages 121134. springer, 2007.
118. ueli m. maurer and stefan wolf. the relationship between breaking the diffiehellman
protocol and computing discrete logarithms. siam journal on computing, 28(5)16891721,
1999.
119. d. mcgrew and j. viega. rfc 4543 the use of galois message authentication code
(gmac) in ipsec esp and ah. technical report, corporation for national research initiatives, internet engineering task force, network working group, may 2006. available at
http//rfc.net/rfc4543.html.
120. a. j. menezes, p. c. van oorschot, and s. a. vanstone. handbook of applied cryptography.
crc press, boca raton, florida, usa, 1997.
121. ralph c. merkle. secure communications over insecure channels. commun. acm,
21(4)294299, 1978.
122. sean murphy and matthew j. b. robshaw. essential algebraic structure within the aes.
in crypto 02 proceedings of the 22nd annual international cryptology conference, advances in cryptology, pages 116. springer, 2002.
123. david naccache and david mrahi. cryptographic smart cards. ieee micro, 16(3)1424,
1996.
124. block cipher modes workshops. http//csrc.nist.gov/groups/st/toolkit/
bcm/workshops.html.
125. nist test suite for random numbers. http//csrc.nist.gov/rng/.
126. national institute of standards and technology (nist).
digital signature standards (dss), fips186-3.
technical report, federal information processing standards publication (fips), june 2009.
available at http//csrc.nist.gov/
publications/fips/fips186-3/fips186-3.pdf.
127. j. nechvatal. public key cryptography. in gustavus j. simmons, editor, contemporary
cryptology the science of information integrity, pages 177288. ieee press, piscataway,
nj, usa, 1994.
128. security architecture for the internet protocol.
http//www.rfc-editor.
org/rfc/rfc4301.txt.
129. i. niven, h.s. zuckerman, and h.l. montgomery. an introduction to the theory of numbers
(5th edition). wiley, 1991.
130. nsa suite b cryptography.
http//www.nsa.gov/ia/programs/suiteb
cryptography/index.shtml.

references

365

131. philippe oechslin. making a faster cryptanalytic time-memory trade-off. in crypto
03 proceedings of the 23rd annual international cryptology conference, advances in
cryptology, volume 2729 of lncs, pages 617630, 2003.
132. the openssl project, 2009. http//www.openssl.org/.
133. european parliament.
directive 1999/93/ec of the european parliament and of
the council of 13 december 1999 on a community framework for electronic
signatures, 1999.
http//europa.eu/eur-lex/pri/en/oj/dat/2000/l
013/l01320000119en00120020.pdf.
134. d. pointcheval and j. stern. security proofs for signature schemes. in u. maurer, editor, advances in cryptology  eurocrypt96, volume 1070 of lncs, pages 387398. springer,
1996.
135. axel poschmann.
lightweight cryptography  cryptographic engineering for a
pervasive world.
phd thesis, department of electrical engineering and computer sciences, ruhr-university bochum, germany, april 2009.
http//www.
crypto.ruhr-uni-bochum.de/entheses.html.
136. b. preneel, r. govaerts, and j. vandewalle. hash functions based on block ciphers a synthetic approach. lncs, 773368378, 1994.
137. bart preneel. mdc-2 and mdc-4. in henk c. a. van tilborg, editor, encyclopedia of
cryptography and security. springer, 2005.
138. electronic signatures in global and national commerce act, united states of america,
2000.
139. jean-jacques quisquater, louis guillou, marie annick, and tom berson. how to explain
zero-knowledge protocols to your children. in crypto 89 proceedings of the 9th annual
international cryptology conference, advances in cryptology, pages 628631. springer,
1989.
140. m. o. rabin. digitalized signatures and public-key functions as intractable as factorization. technical report, massachusetts institute of technology, 1979.
141. w. rankl and w. effing. smart card handbook. john wiley  sons, inc., 2003.
142. rc4 page. http//www.wisdom.weizmann.ac.il/itsik/rc4/rc4.html.
143. r. l. rivest, a. shamir, and l. adleman. a method for obtaining digital signatures and
public-key cryptosystems. communications of the acm, 21(2)120126, february 1978.
144. ron
rivest.
the
rc4
encryption
algorithm,
march
1992.
http//www.rsasecurity.com.
145. dorothy elizabeth robling denning. cryptography and data security. addison-wesley
longman publishing co., inc., 1982.
146. matthew robshaw and olivier billet, editors. new stream cipher designs the estream
finalists, volume 4986 of lncs. springer, 2008.
147. carsten rolfes, axel poschmann, gregor leander, and christof paar. ultra-lightweight implementations for smart devicessecurity for 1000 gate equivalents. in proceedings of the 8th
smart card research and advanced application ifip conference  cardis 2008, volume
5189 of lncs, pages 89103. springer, 2008.
148. k. h. rosen. elementary number theory, 5th edition. addison-wesley, 2005.
149. public key cryptography standard (pkcs), 1991. http//www.rsasecurity.
com/rsalabs/node.aspid2124.
150. claus-peter schnorr. efficient signature generation by smartcards. journal of cryptology,
4161174, 1991.
151. a. shamir. factoring large numbers with the twinkle device. in ches 99 proceedings of the 1st international workshop on cryptographic hardware and embedded systems,
volume 1717 of lncs, pages 212. springer, august 1999.
152. a. shamir and e. tromer. factoring large numbers with the twirl device. in crypto
03 proceedings of the 23rd annual international cryptology conference, advances in
cryptology, volume 2729 of lncs, pages 126. springer, 2003.
153. p. shor. polynomial-time algorithms for prime factorization and discrete logarithms. siam
journal on computing, communication theory of secrecy systems, 2614841509, 1997.

366

references

154.
155.
156.
157.

j. h. silverman. the arithmetic of elliptic curves. springer, 1986.
j. h. silverman. advanced topics in the arithmetic of elliptic curves. springer, 1994.
j. h. silverman. a friendly introduction to number theory. prentice hall, 3rd edition, 2006.
simon singh. the code book the science of secrecy from ancient egypt to quantum
cryptography. anchor, august 2000.
jerome a. solinas. efficient arithmetic on koblitz curves. designs, codes and cryptography,
19(2-3)195249, 2000.
j.h. song, r. poovendran, j. lee, and t. iwata.
rfc 4493 the aes-cmac
algorithm.
technical report, corporation for national research initiatives, internet engineering task force, network working group, june 2006.
available at
http//rfc.net/rfc4493.html.
nist special publication sp800-38d recommendation for block cipher modes of operation galois counter mode (gcm) and gmac, november 2007. available at http//
csrc.nist.gov/publications/nistpubs/800-38d/sp-800-38d.pdf.
w. stallings. cryptography and network security principles and practice. prentice hall,
4th edition, 2005.
tsuyoshi takagi. fast rsa-type cryptosystem modulo pk q. in crypto 98 proceedings of
the 18th annual international cryptology conference, advances in cryptology, pages 318
326. springer, 1998.
s. trimberger, r. pang, and a. singh. a 12 gbps des encryptor/decryptor core in an
fpga. in c. k. koc and c. paar, editors, ches 00 proceedings of the 2nd international
workshop on cryptographic hardware and embedded systems, volume 1965 of lncs, pages
157163. springer, august 17-18, 2000.
trivium specifications.
http//www.ecrypt.eu.org/stream/p3ciphers/
trivium/triviump3.pdf.
walter tuchman. a brief history of the data encryption standard. in internet besieged
countering cyberspace scofflaws, pages 275280. acm press/addison-wesley, 1998.
annual workshop on elliptic curve cryptography, ecc.
http//cacr.math.
uwaterloo.ca/conferences/.
digital signature law survey. https//dsls.rechten.uvt.nl/.
henk c. a. van tilborg, editor. encyclopedia of cryptography and security. springer, 2005.
ingrid verbauwhede, frank hoornaert, joos vandewalle, and hugo de man. asic
cryptographical processor based on des, 1991.
http//www.ivgroup.ee.
ucla.edu/pdf/1991euroasic.pdf.
sharcs - special-purpose hardware for attacking cryptographic systems.
http//www.sharcs.org/.
waifi  international workshop on the arithmetic of finite fields.
http//
www.waifi.org/.
andre weimerskirch and christof paar.
generalizations of the karatsuba algorithm for efficient implementations.
cryptology eprint archive, report 2006/224.
http//eprint.iacr.org/2006/224.
d. whiting, r. housley, and n. ferguson. rfc 3610 counter with cbc-mac (ccm).
technical report, corporation for national research initiatives, internet engineering task
force, network working group, september 2003.
m.j. wiener. efficient des key search an update. cryptobytes, 3(2)68, autumn
1997.
thomas wollinger, jan pelzl, and christof paar. cantor versus harley optimization and
analysis of explicit formulae for hyperelliptic curve cryptosystems. ieee transactions on
computers, 54(7)861872, 2005.

158.
159.

160.

161.
162.

163.

164.
165.
166.
167.
168.
169.

170.
171.
172.

173.

174.
175.

index

3des, see triple des
a5/1 cipher, 31
access control, 264
active attack, 225
adleman, leonard, 173
advanced encryption standard, 57, 87, 88
affine mapping, 103
byte substitution layer, 90, 101
diffusion layer, 90, 103
hardware implementation, 115
key addition layer, 90, 106
key schedule, 106
key whitening, 106
layers of, 90
mixcolumn, 90, 103, 104
overview, 89
s-box, 90, 101
selection process, 88
shiftrows, 90, 103
software implementation, 115
state of, 90
t-box, 115
aes, see advanced encryption standard
affine cipher, 19
affine mapping, 103
alice and bob, 4
anonymity, 264
asymmetric cryptography, see public-key
cryptography
attack
brute-force, see brute-force attack
buffer overflow, 11
auditing, 264
authenticated channel, 342, see channel
authenticated encryption, 143
authentication tag, 320

availability, 264
avalanche effect, 66
baby-step giant-step method, 221
biham, eli, 75, 76
binary extended euclidean algorithm, 168
birthday attack, 299
birthday paradox, 299
bit-slicing, 82
block cipher, 30
confusion, 57
diffusion, 57
block ciphers
and hash functions, 305
blowfish, 81, 307
brute-force attack, 7, 136
for discrete logarithms, 220
bsi, 22
ca, see certification authority
caesar cipher, see shift cipher
cardinality, see group
carmichael number, 189
cast, 81
cbc, see cipher block chaining mode
cbc-mac, 143, 326
cc, see common criteria
ccm, 327
certificate, 155
chain of, 350
certificate revocation list, 350, 351
delta crl, 351
certificates, 345
certification authority, 345
cfb, see cipher feedback mode
chain of trust, 347, 350
challenge-response protocol, 340
367

368
channel, 4
chinese remainder theorem, 184
chosen plaintext attack, 27
cipher block chaining mode, 128
cipher feedback mode, 131
ciphertext, 5
classified encryption, 89
cleartext, see plaintext
cmac, 327
cocks, clifford, 149
collision resistance, 299
strong, 299
weak, 298
common criteria, 22
confidentiality, 263
with block ciphers, 124
confusion, 90
coprime, 17
counter mode, 132
cramershoup, 232
crl, see certificate revocation list
crt, see chinese remainder theorem
cryptanalysis, 3, 9
classical, 10
implementation attacks, 10
social engineering, 10
cryptographic checksum, see message
authentication code
cryptography, 2, 3
asymmetric, 3
protocol, 3
symmetric, 3, 4
cryptology, 3
csprng, see random number generator,
cryptographically secure
ctr, see counter mode
cyclic group, see group
data encryption standard, 55
e permutation, 63
pc  1 permutation, 67
pc  2 permutation, 68
p permutation, 66
f -function, 62
analytical attacks, 75
bit-slicing, 76
challenge, 75
copacobana code-breaking machine, 74
cracker, 73
decryption, 69
deep crack code-breaking machine, 73
differential cryptanalysis, 75
exhaustive key search, 73
final permutation, 61

index
hardware implementation, 77
initial permutation, 61
key schedule, 67
linear cryptanalysis, 75
overview, 58
s-box, 63
data origin authentication, 263
decryption exponent, 175
des, see data encryption standard
desx, 142
deterministic encryption
rsa, 192
deterministic encryption, stream ciphers, 48
dhaes, 232
dhke, see diffiehellman key exchange
dhp, see diffiehellman problem
differential cryptanalysis, 66
diffie, whitfield, 149
diffiehellman key exchange, 154, 206
diffiehellman problem, 225
digital signature, 154, 259
elgamal, 270
principle, 261
properties, 260
rsa, 264
verification, 262
digital signature algorithm, 277
key generation, 277, 283
security of, 281
signature, 278, 283
verification, 278
digital signature standard, 277
diophantine equation, 160
dirichlets drawer principle, 298
discrete logarithm problem, 153, 155, 205, 216
elliptic curves (ecdlp), 247
generalized, 218
in dsa, 281
divide-and-conquer attack, 138
dlp, see discrete logarithm problem
dobbertin, hans, 304
domain parameters
for diffiehellman key exchange, 206
double encryption, 138
double-and-add, 248
dsa, see digital signature algorithm
dss, see digital signature standard
eavesdropping, 4
eax, 143
ecb, see electronic code book mode
ecdh, see elliptic curve diffiehellman key
exchange

index
ecdhp, see elliptic curve diffiehellman
problem
ecdlp, 247
ecdsa, 282
security of, 286
verification, 284
ecrypt, 49
estream, 49
ede, see encryptiondecryptionencryption
eea, see extended euclidean algorithm
electronic code book mode, 124
elgamal
cryptosystem, 226
security, 230, 274
set-up, 227
elgamal digital signature, 270
acceleration through precomputation, 273
key generation, 270
elgamal encryption scheme, 226
elliptic curve
domain parameters, 250
elliptic curve diffiehellman key exchange,
249
elliptic curve diffiehellman problem, 251
elliptic curve digital signature algorithm, see
ecdsa
elliptic curves
koblitz curves, 254
ellis, james, 149
emsa, 269
encoding method for signature with
appendix, see emsas
encryption exponent, 175
encryptiondecryptionencryption, 140
enigma, 2, 57
ephemeral key, 332
equivalence class, 15
estream, 49
euclids algorithm, see euclidean algorithm
euclidean algorithm, 157
binary, 168
eulers phi function, 165
eulers theorem, 167
exhaustive key search, see brute-force attack
existential forgery
elgamal digital signature, 275
rsa digital signature, 267
exponentiation
square-and-multiply algorithm, 180
sliding window algorithm, 198
extended euclidean algorithm, 160
extension field
gf(2m ), 95
addition, 95

369
irreducible polynomial, 97
multiplication, 97
polynomial, 95
polynomial arithmetic, 95
subtraction, 95
fault injection attack, 199
feistel network, 58
generalized, 311
sha-1, 311
feistel, horst, 56
fermat test, 189
fermats last theorem, 166
fermats little theorem, 166, 213, 272
field
cardinality, 93
characteristic, 93
extension, see extension field
order, 93
prime, 93
fingerprint of a message, 295
finite field, 90
fips, 56, 88
flip-flop, see linear feedback shift register
galois counter mode, 134, 327
galois fields, see finite fields
gardner, martin, 195
gc, 143
gcd, see greatest common divisor
gchq, see government communications
headquarters
gcm, see galois counter mode
generalized discrete logarithm problem, 218
generator, see group
gmac, 327
government communications headquarters,
149
greatest common divisor, 17, 157
group, 91, 208
abelian, 92
cardinality, 211
cyclic, 212
finite, 210
generator, 212
order, 211
primitive element, 212
group order, see group
grovers algorithm, 144
gsm, 333
hamming weight, 182
hash function, 293
compression function, 303

370
cryptographic, 143
hash functions
from block ciphers, 305
hash value, 293
hasses bound, see hasses theorem
hasses theorem, 247
hellman, martin, 149
hmac, see message authentication code
hybrid protocols, 154
hybrid scheme, 4
hyperelliptic curve cryptosystems, 254
hyperelliptic curves, 156
iacr, 21
idea, 82
identity based cryptosystems, 254
ieee 802.11i, 87
ike, 351
implementation attacks, see cryptanalysisimplementation attacks
index-calculus algorithm, 223, 251
initialization vector, 48
in cbc mode, 128
integer factorization problem, 153, 155
integrity, 134, 263, 320
inverse
multiplicative, 17
ipsec, 87, 321, 328, 348
iv, see initialization vector
kasumi, 49, 81
kdc, see key distribution center
kdf, see key derivation function
kek, see key encryption key
kerberos, 339
kerckhoffs principle, 11
key, 5
ephemeral, 227
key agreement, 332
key confirmation, 339
key derivation function, 333
key distribution center, 336
key distribution problem, 151
key encryption, 152
key encryption key, 336
key establishment, 331
mti protocol, 351
key freshness, 333
key generation, 175
key predistribution, 334
key space, 5
key stream, 31
key transport, 332
key update, 333

index
key whitening, 78, 141
keyed hash function, see message authentication code
lagranges theorem, 215
lattice-based public-key schemes, 156
letter frequency analysis, see substitution
cipher
lfsr, see linear feedback shift register
lightweight ciphers, 78
linear congruential generator, 35
linear feedback shift register, 41
degree of, 41
feedback coefficients, 43
feedback path, 41
flip-flop, 41
known plaintext attack, 45
maximum length, 44
linear recurrence, see lfsr
lucifer, 56
mac, 134, 143, see message authentication
code
cbc-mac, 143, 326
omac, 143, 327
pmac, 143, 327
mac, secret prefix, 322
mac, secret suffix, 322
malleable, 192
elgamal encryption, 232
rsa, 192
malware, 11
man-in-the-middle attack, 225, 342
mars, 81, 88, 307
matsui, mitsuru, 75
mceliece cryptosystems, 156
md4 family, 304
md5, 304
mdc-2 hash function, 313
meet-in-the-middle attack, 138
merkle, ralph, 149
merkledamgard construction, 303
and sha-1, 307
message authentication, 134, 263, 321
message authentication code, 319
hmac, 321
principle, 320
message digest, see hash function, 295
message expansion factor, 228
millerrabin, see primality test
mim, see man-in-the-middle attack
misty1, 82
mmh, see multilinear-modular-hashing
modulo operation, 14

index
moores law, 12, 197
mq public-key schemes, 156
multilinear-modular-hashing, 328
multiparty computation, 21
multiplication table, 210
multivariate quadratic public-key schemes, 156
national institute of standards and technology,
88
national security agency, 56, 89
nist, see national institute of standards and
technology
nonce, 48, 333
nonrepudiation, 151, 263
nsa, see national security agency
oaep, 192
ocb, 143
ofb, see output feedback mode
omac, 143, 327
one-time pad, 37
one-way function, 153, 205, 333
hash functions and one-wayness, 297
order, see group
oscar, 4
otp, see one-time pad
out-of-band transmission, 334
output feedback mode, 130
padding
rsa digital signature, 268
padding, for block cipher encryption, 124
parallelization of encryption, 133
perfect forward secrecy, 341
pfs, see perfect forward secrecy
physical security, 264
pigeonhole principle, 298
pki, 347
plaintext, 5
pmac, 143, 327
pohlighellman algorithm for discrete
logarithms, 222
pollards rho method, 222, 251
post-quantum cryptography, 169
preimage resistance, 297
present, 31, 78, 307
primality test, 188
fermat, 189
fermat test, 188, 189
millerrabin, 188, 190, 191
probabilistic test, 189
prime
likelihood, 187
prime number theorem, 188

371
primes
generalized mersenne, 254
primitive element, 212
private exponent, 175
prng, see random number generator,
pseudorandom
probabilistic encryption, 128, 229
probabilistic signature scheme (pss), see
rsa digital signature
product ciphers, 57
provable security
hmac, 325
public exponent, 175
public-key cryptography, 149
public-key infrastructure, see pki
quantum computer, 88, 144
rainbow tables, 144
random number generator
cryptographically secure, 36
for prime generation, 187
pseudorandom, 35
true, 35
rc4 cipher, 31
rc6, 82, 88, 307
relative security, 38
relatively prime, 17
replay attack, 338
rfid, 79
rijndael, see advanced encryption standard
and hash functions, 306
ring, 16
ripemd, 304
rivest, ronald, 173, 304
rivestshamiradleman, see rsa
round key, 67
rsa, 174
exponentiation, 179
attacks, 194
chinese remainder theorem, 184
decryption, 175
encryption, 174
factoring attack, 194
factoring records, 194
implementation, 197
key generation, 175
padding, 192
schoolbook, 192
short public exponent, 183
side-channel attacks, 195
speed-ups, 183
rsa digital signature, 264
attacks, 267

372
padding, 268
probabilistic signature scheme (pss), 268
s/mime, 348
secg, 254
second preimage resistance, 298
secret-key, see cryptography-symmetric
secure channel, 151
secure hash algorithm, see sha
security
bit level, 11
long-term, 12
short-term, 12
security by obscurity, 11
security level, 156
security objectives, 263
security service, 263
serpent, 88, 307
session keys, 332
sha, 304
sha-0, 304
sha-1, 307
implementation, 312
padding, 308
sha-2, 304
sha-3, 313
shamir, adi, 75, 173
shanks algorithm, 221, 251
shannon, claude, 57
shift cipher, 18
shors algorithm, 144, 169
side-channel attacks
rsa, 195
signaturgesetz, 263
simple power analysis, 196
single point of failure, 341
single-key, see cryptography-symmetric
skype, 87
small subgroup attack, 231, 274
smart card, 187, 288
social engineering, see cryptanalysis-social
engineering
spa, see simple power analysis
square-and-multiply, 229, 267, 273
square-and-multiply algorithm, see exponentiation

index
ssh, 87
ssl/tls, 348
station-to-station protocol, 351
stream cipher, 30, 31
key stream, 34
sts, see station-to-station protocol
subgroup, 214
subkey, 67
substitution attack, 125
substitution cipher, 6
brute-force attack, 7
letter frequency analysis, 8
symmetric-key, see cryptography-symmetric
t-boxes, 116
time-memory tradeoff
discrete logarithms, 221
time-memory tradeoff attacks, 143
timelinesss, 340
timing attack, 199
tls, 4, 87, 321, 328
traffic analysis, 125
triple des, 55, 78
effective key length, 141
triple encryption, 140
trivium, 46
trng, see random number generator, true
trusted authority, 335
twofish, 82, 88
umac, 328
unconditional security, 36
unicity distance, 136
universal hashing, 328
vernam, gilbert, 34
warm-up phase, 48
web of trust, 352
wi-fi, 87
williamson, graham, 149
wpa, 5
xor gate, 32
zero-knowledge proofs, 21

